
/home/svc-audio-dspsw/kymera_builds/builds/2020/kymera_2005191628/kalimba/kymera/tools/KCSMaker/out/7120/streplus_rom_release/download/debugbin/download_aec_reference.elf:     file format elf32-littlekalimba

Disassembly of section .text_minim:

84200000 <$_aec_reference_create>:

/* ********************************** API functions ************************************* */


bool aec_reference_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200000:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
84200002:	17 00       	r5 = r0 + Null;
84200004:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84200006:	ff fd 02 f0 	call (m) 0x4e6;
8420000a:	21 e7 
8420000c:	16 00       	r4 = r0 + Null;
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    /* Setup Response to Creation Request.   Assume Failure*/
    if(!base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data))
8420000e:	03 f0 00 60 	r1 = Null + 4096;
84200012:	44 08       	r2 = r6 + Null;
84200014:	3a 00       	r0 = r5 + Null;
84200016:	ff fd 02 f0 	call (m) 0x4bc;
8420001a:	27 e5 
8420001c:	10 04       	Null = r0 - Null;
8420001e:	03 62       	if NE jump (m) Lc_aec_reference_create_3;

84200020 <Lc_aec_reference_create_2>:
    {
        return(FALSE);
84200020:	02 00       	r0 = Null + Null;
84200022:	73 6e       	jump (m) Lc_aec_reference_create_14;

84200024 <Lc_aec_reference_create_3>:
    }

    /* Processing is in timer task.  This prevents kicks from
       propagating to the main processing function */
    base_op_stop_kicks(op_data, SOURCE_SIDE);
84200024:	43 20       	r1 = Null + 1;
84200026:	3a 00       	r0 = r5 + Null;
84200028:	ff fd 02 f0 	call (m) 0x550;
8420002c:	29 e9 

    /* Initialize extended data for operator.  Assume intialized to zero*/
    op_extra_data->cap_id = base_op_get_cap_id(op_data);
8420002e:	3a 00       	r0 = r5 + Null;
84200030:	ff fd 02 f0 	call (m) 0x4ea;
84200034:	3b e5 
84200036:	62 f0 5a 8e 	M[r4 + 360] = r0;
    op_extra_data->ReInitFlag = TRUE;
8420003a:	41 20       	rMAC = Null + 1;
8420003c:	61 f0 5d 8e 	M[r4 + 372] = rMAC;
    op_extra_data->Cur_mode = AEC_REFERENCE_SYSMODE_FULL;
84200040:	61 f0 5b 8e 	M[r4 + 364] = rMAC;
    op_extra_data->kick_id = TIMER_ID_INVALID;
84200044:	60 f0 5e 8e 	M[r4 + 376] = Null;
                         (AEC_REFERENCE_DEFAULT_TASK_PERIOD >= AEC_REFERENCE_MIN_TASK_PERIOD) &&
                         ((SECOND%AEC_REFERENCE_DEFAULT_TASK_PERIOD)==0)),
                        AEC_REFERENCE_DEFAULT_TASK_PERIOD_Not_Accepted);

    /* set default task period */
    if(!aec_reference_set_task_period(op_extra_data, AEC_REFERENCE_DEFAULT_TASK_PERIOD, 1))
84200048:	03 f0 e8 43 	r1 = Null + 1000;
8420004c:	0c 00       	r2 = rMAC + Null;
8420004e:	32 00       	r0 = r4 + Null;
84200050:	08 f0 39 e5 	call (m) $_aec_reference_set_task_period;
84200054:	10 04       	Null = r0 - Null;
84200056:	43 60       	if EQ jump (m) Lc_aec_reference_create_8;

84200058 <Lc_aec_reference_create_4>:
    }


#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* set minimum tag length for mic output metadata tags */
    op_extra_data->mic_metadata_min_tag_len = AEC_REFERENCE_MIC_METADATA_MIN_TAG_LEN;
84200058:	01 3b       	rMAC = Null + 60;
8420005a:	61 f0 c5 8e 	M[r4 + 788] = rMAC;

    /* create time to play with default params */
    op_extra_data->mic_time_to_play = ttp_init();
8420005e:	ff fd ca f0 	call (m) 0x19462;
84200062:	25 e0 
84200064:	62 f0 c8 8e 	M[r4 + 800] = r0;
    if (op_extra_data->mic_time_to_play != NULL)
84200068:	61 f0 c8 88 	rMAC = M[r4 + 800];
8420006c:	38 60       	if EQ jump (m) Lc_aec_reference_create_8;

8420006e <Lc_aec_reference_create_5>:
    {
        ttp_params params;
        ttp_get_default_params(&params, TTP_TYPE_PCM);
8420006e:	43 20       	r1 = Null + 1;
84200070:	42 11       	r0 = FP + 20;
84200072:	ff fd ca f0 	call (m) 0x194aa;
84200076:	39 e1 
        ttp_configure_params(op_extra_data->mic_time_to_play, &params);
84200078:	43 11       	r1 = FP + 20;
8420007a:	62 f0 c8 88 	r0 = M[r4 + 800];
8420007e:	ff fd ca f0 	call (m) 0x195f0;
84200082:	33 eb 
       but is not declared as such because we may want it to be configurable in the future */

    /* For Atlas this must be less than for equal to the ping/pong period.
       Also set AEC_REFERENCE_TIME_PERIOD
    */
    op_extra_data->mic_rate_ability  = RATEMATCHING_SUPPORT_NONE;
84200084:	60 f0 cc 8b 	MB[r4 + 460] = Null;
    op_extra_data->spkr_rate_ability = RATEMATCHING_SUPPORT_NONE;
84200088:	60 f0 7c 8e 	M[r4 + 496] = Null;
    op_extra_data->mic_shift  = AEC_REFERENCE_DEFAULT_EP_SHIFT;
8420008c:	60 f0 7a 8e 	M[r4 + 488] = Null;
    op_extra_data->spkr_shift = -AEC_REFERENCE_DEFAULT_EP_SHIFT;
84200090:	60 f0 81 8e 	M[r4 + 516] = Null;

    /* Note:  sample rate config must be sent before the operator's terminals may be connected
       input_rate and output_rate are initialized to zero and checked in the connect operation */

    /*allocate the volume control shared memory */
    op_extra_data->shared_volume_ptr = allocate_shared_volume_cntrl();
84200094:	ff fd a0 f0 	call (m) 0x14256;
84200098:	23 ee 
8420009a:	62 f0 59 8e 	M[r4 + 356] = r0;
    if(!op_extra_data->shared_volume_ptr)
8420009e:	61 f0 59 88 	rMAC = M[r4 + 356];
842000a2:	25 60       	if EQ jump (m) Lc_aec_reference_create_10;

842000a4 <Lc_aec_reference_create_6>:
    {
        goto aFailed;
    }

    if(!cpsInitParameters(&op_extra_data->parms_def,(unsigned*)AEC_REFERENCE_GetDefaults(op_extra_data->cap_id),(unsigned*)&op_extra_data->params,sizeof(AEC_REFERENCE_PARAMETERS)))
842000a4:	62 f0 5a 88 	r0 = M[r4 + 360];
842000a8:	18 f0 2b ec 	call (m) $_AEC_REFERENCE_GetDefaults;
842000ac:	13 00       	r1 = r0 + Null;
842000ae:	05 f0 94 40 	r3 = Null + 148;
842000b2:	64 f0 d0 20 	r2 = r4 + 208;
842000b6:	62 f0 7c 21 	r0 = r4 + 380;
842000ba:	ff fd 03 f0 	call (m) 0x742;
842000be:	29 e4 
842000c0:	10 04       	Null = r0 - Null;
842000c2:	0d 60       	if EQ jump (m) Lc_aec_reference_create_8;

842000c4 <Lc_aec_reference_create_7>:
    {
        goto aFailed;
    }

#if defined(IO_DEBUG)
    op_extra_data->aec_latency_ptr = &op_extra_data->sync_block;
842000c4:	61 f0 ac 22 	rMAC = r4 + 684;
842000c8:	61 f0 d0 8e 	M[r4 + 832] = rMAC;

    /* chance to fix up */
    patch_fn_shared(aec_reference);

    /* We don't have a new constant table to add - only register our interest in the IIR RESAMPLER constant tables. */
    iir_resamplerv2_add_config_to_list(NULL);
842000cc:	02 00       	r0 = Null + Null;
842000ce:	ff fd 73 f1 	call (m) 0x2e896;
842000d2:	29 ee 
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
842000d4:	81 f0 00 e8 	rMAC = M[r6 + Null];
842000d8:	48 8e       	M[rMAC + 4] = Null;
842000da:	16 6e       	jump (m) Lc_aec_reference_create_13;

842000dc <Lc_aec_reference_create_8>:

    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
  aFailed:
    if(op_extra_data->shared_volume_ptr)
842000dc:	62 f0 59 88 	r0 = M[r4 + 356];
842000e0:	06 60       	if EQ jump (m) Lc_aec_reference_create_10;

842000e2 <Lc_aec_reference_create_9>:
    {
        release_shared_volume_cntrl(op_extra_data->shared_volume_ptr);
842000e2:	ff fd a0 f0 	call (m) 0x1427a;
842000e6:	39 ec 
        op_extra_data->shared_volume_ptr = NULL;
842000e8:	60 f0 59 8e 	M[r4 + 356] = Null;

842000ec <Lc_aec_reference_create_10>:
    }

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* free it if we created time to play context for mic */
    if (op_extra_data->mic_time_to_play != NULL)
842000ec:	62 f0 c8 88 	r0 = M[r4 + 800];
842000f0:	06 60       	if EQ jump (m) Lc_aec_reference_create_12;

842000f2 <Lc_aec_reference_create_11>:
    {
        ttp_free(op_extra_data->mic_time_to_play);
842000f2:	ff fd cd f0 	call (m) 0x19b54;
842000f6:	23 e3 
        op_extra_data->mic_time_to_play = NULL;
842000f8:	60 f0 c8 8e 	M[r4 + 800] = Null;

842000fc <Lc_aec_reference_create_12>:
842000fc:	01 f0 00 60 	rMAC = Null + 4096;
84200100:	82 f0 00 e8 	r0 = M[r6 + Null];
84200104:	51 8e       	M[r0 + 4] = rMAC;

84200106 <Lc_aec_reference_create_13>:

    /* We don't have a new constant table to add - only register our interest in the IIR RESAMPLER constant tables. */
    iir_resamplerv2_add_config_to_list(NULL);

    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
84200106:	42 20       	r0 = Null + 1;

84200108 <Lc_aec_reference_create_14>:
    }
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */

    base_op_change_response_status(response_data, STATUS_CMD_FAILED);
    return TRUE;
}
84200108:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
8420010a:	d8 4c       	rts;

8420010c <$_aec_reference_destroy>:
     */
    op_extra_data->channel_status = 0;
}

bool aec_reference_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420010c:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
8420010e:	17 00       	r5 = r0 + Null;
84200110:	1a 09       	r8 = r1 + Null;
84200112:	20 09       	r6 = r2 + Null;
84200114:	29 09       	r7 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84200116:	ff fd 01 f0 	call (m) 0x4e6;
8420011a:	31 ee 
8420011c:	16 00       	r4 = r0 + Null;
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    /* Setup Response to Destroy Request.*/
    if(!base_op_destroy(op_data, message_data, response_id, response_data))
8420011e:	4d 08       	r3 = r7 + Null;
84200120:	44 08       	r2 = r6 + Null;
84200122:	53 08       	r1 = r8 + Null;
84200124:	3a 00       	r0 = r5 + Null;
84200126:	ff fd 01 f0 	call (m) 0x370;
8420012a:	2b e2 
8420012c:	10 04       	Null = r0 - Null;
8420012e:	03 62       	if NE jump (m) Lc_aec_reference_destroy_3;

84200130 <Lc_aec_reference_destroy_2>:
    {
        return(FALSE);
84200130:	02 00       	r0 = Null + Null;
84200132:	1a 6e       	jump (m) Lc_aec_reference_destroy_6;

84200134 <Lc_aec_reference_destroy_3>:
    }

    /* Make sure everything is cleared */
    aec_reference_cleanup(op_data);
84200134:	3a 00       	r0 = r5 + Null;
84200136:	0a f0 37 e3 	call (m) $_aec_reference_cleanup;

    /* calling the "destroy" assembly function - this frees up all the capability-internal memory */
    /*free volume control shared memory*/
    release_shared_volume_cntrl(op_extra_data->shared_volume_ptr);
8420013a:	62 f0 59 88 	r0 = M[r4 + 356];
8420013e:	ff fd a0 f0 	call (m) 0x1427a;
84200142:	3d e9 
    op_extra_data->shared_volume_ptr = NULL;
84200144:	60 f0 59 8e 	M[r4 + 356] = Null;

    /* delete the configuration list */
    iir_resamplerv2_delete_config_list();
84200148:	ff fd 73 f1 	call (m) 0x2e8d2;
8420014c:	2b ec 

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* delete mic time-to-play object */
    if(op_extra_data->mic_time_to_play != NULL)
8420014e:	62 f0 c8 88 	r0 = M[r4 + 800];
84200152:	06 60       	if EQ jump (m) Lc_aec_reference_destroy_5;

84200154 <Lc_aec_reference_destroy_4>:
    {
        ttp_free(op_extra_data->mic_time_to_play);
84200154:	ff fd cd f0 	call (m) 0x19b54;
84200158:	21 e0 
        op_extra_data->mic_time_to_play = NULL;
8420015a:	60 f0 c8 8e 	M[r4 + 800] = Null;

8420015e <Lc_aec_reference_destroy_5>:
8420015e:	91 f0 00 e8 	rMAC = M[r7 + Null];
84200162:	48 8e       	M[rMAC + 4] = Null;
    }
#endif

    base_op_change_response_status(response_data,STATUS_OK);
    return(TRUE);
84200164:	42 20       	r0 = Null + 1;

84200166 <Lc_aec_reference_destroy_6>:
}
84200166:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200168:	d8 4c       	rts;

8420016a <$_aec_reference_stop_reset>:
    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
}

bool aec_reference_stop_reset(OPERATOR_DATA *op_data,void *message_data, unsigned *response_id, void **response_data)
{
8420016a:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
8420016c:	16 00       	r4 = r0 + Null;
8420016e:	2f 00       	r5 = r3 + Null;
    patch_fn_shared(aec_reference);

    if(!base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data))
84200170:	03 f0 00 60 	r1 = Null + 4096;
84200174:	3c 00       	r2 = r5 + Null;
84200176:	ff fd 01 f0 	call (m) 0x4bc;
8420017a:	27 ea 
8420017c:	10 04       	Null = r0 - Null;
8420017e:	03 62       	if NE jump (m) Lc_aec_reference_stop_reset_3;

84200180 <Lc_aec_reference_stop_reset_2>:
    {
        return(FALSE);
84200180:	02 00       	r0 = Null + Null;
84200182:	11 6e       	jump (m) Lc_aec_reference_stop_reset_6;

84200184 <Lc_aec_reference_stop_reset_3>:
    }
    /* do something only if the current state is "running" */
    if (opmgr_op_is_running(op_data))
84200184:	32 00       	r0 = r4 + Null;
84200186:	ff fd 2a f0 	call (m) 0x5700;
8420018a:	3b eb 
8420018c:	10 04       	Null = r0 - Null;
8420018e:	04 60       	if EQ jump (m) Lc_aec_reference_stop_reset_5;

84200190 <Lc_aec_reference_stop_reset_4>:
    {
        aec_reference_cleanup(op_data);
84200190:	32 00       	r0 = r4 + Null;
84200192:	0a f0 3b e0 	call (m) $_aec_reference_cleanup;

84200196 <Lc_aec_reference_stop_reset_5>:
    }
    /* Mark the operator as stopped. */
    base_op_stop_operator(op_data);
84200196:	32 00       	r0 = r4 + Null;
84200198:	ff fd 01 f0 	call (m) 0x54a;
8420019c:	33 ed 
8420019e:	39 e8       	rMAC = M[r5 + Null];
842001a0:	48 8e       	M[rMAC + 4] = Null;
    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
842001a2:	42 20       	r0 = Null + 1;

842001a4 <Lc_aec_reference_stop_reset_6>:
}
842001a4:	f2 48       	popm <FP, r4, r5, rLink>;
842001a6:	d8 4c       	rts;

842001a8 <$_aec_reference_connect>:

    return retval;
}

bool aec_reference_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842001a8:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
842001aa:	11 09       	r7 = r0 + Null;
842001ac:	18 09       	r6 = r1 + Null;
842001ae:	2a 09       	r8 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
842001b0:	ff fd 01 f0 	call (m) 0x4e6;
842001b4:	37 e9 
842001b6:	16 00       	r4 = r0 + Null;
}

bool aec_reference_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);    /* extract the terminal_id */
842001b8:	87 f0 00 e8 	r5 = M[r6 + Null];
    tCbuffer* pterminal_buf = OPMGR_GET_OP_CONNECT_BUFFER(message_data);
842001bc:	88 f0 01 88 	r6 = M[r6 + 4];
    tCbuffer **bufp = NULL;

    patch_fn_shared(aec_reference);

    L3_DBG_MSG1("AEC REFERENCE --- connect TID = %x", terminal_id);
842001c0:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842001c4:	c8 24       	Null = rMAC - 3;
842001c6:	08 68       	if LT jump (m) Lc_aec_reference_connect_3;

842001c8 <Lc_aec_reference_connect_2>:
842001c8:	55 f1 02 f0 	r0 = Null + 357564416;
842001cc:	00 40 
842001ce:	3b 00       	r1 = r5 + Null;
842001d0:	ff fd 05 f0 	call (m) 0xcde;
842001d4:	2f e8 

842001d6 <Lc_aec_reference_connect_3>:


    /* Setup Response to Connection Request.   Assume Failure*/
    if(!base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data))
842001d6:	03 f0 00 60 	r1 = Null + 4096;
842001da:	54 08       	r2 = r8 + Null;
842001dc:	4a 08       	r0 = r7 + Null;
842001de:	ff fd 01 f0 	call (m) 0x4bc;
842001e2:	3f e6 
842001e4:	10 04       	Null = r0 - Null;
842001e6:	03 62       	if NE jump (m) Lc_aec_reference_connect_5;

842001e8 <Lc_aec_reference_connect_4>:
    {
        return(FALSE);
842001e8:	02 00       	r0 = Null + Null;
842001ea:	c9 6e       	jump (m) Lc_aec_reference_connect_42;

842001ec <Lc_aec_reference_connect_5>:
    }

    /* Only allow connection if operator has been configured */
    if((op_extra_data->input_rate==0) || (op_extra_data->output_rate==0) )
842001ec:	60 f0 70 88 	Null = M[r4 + 448];
842001f0:	13 60       	if EQ jump (m) Lc_aec_reference_connect_10;

842001f2 <Lc_aec_reference_connect_6>:
842001f2:	60 f0 71 88 	Null = M[r4 + 452];
842001f6:	10 60       	if EQ jump (m) Lc_aec_reference_connect_10;

842001f8 <Lc_aec_reference_connect_7>:
        return(TRUE);
    }

    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id) || !pterminal_buf)
842001f8:	3b 00       	r1 = r5 + Null;
842001fa:	4a 08       	r0 = r7 + Null;
842001fc:	ff fd 01 f0 	call (m) 0x496;
84200200:	3b e4 
84200202:	10 04       	Null = r0 - Null;
84200204:	04 60       	if EQ jump (m) Lc_aec_reference_connect_9;

84200206 <Lc_aec_reference_connect_8>:
84200206:	0f f8 00 c2 	Null = r6 - Null;
8420020a:	08 62       	if NE jump (m) Lc_aec_reference_connect_11;

8420020c <Lc_aec_reference_connect_9>:
8420020c:	01 f0 03 60 	rMAC = Null + 4099;
84200210:	a2 f0 00 e8 	r0 = M[r8 + Null];
84200214:	51 8e       	M[r0 + 4] = rMAC;

84200216 <Lc_aec_reference_connect_10>:
    }

    /* Only allow connection if operator has been configured */
    if((op_extra_data->input_rate==0) || (op_extra_data->output_rate==0) )
    {
        return(TRUE);
84200216:	42 20       	r0 = Null + 1;
84200218:	b2 6e       	jump (m) Lc_aec_reference_connect_42;

8420021a <Lc_aec_reference_connect_11>:
        base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    /* check if the terminal is already connected and if not , connect the terminal */
    if(terminal_id & TERMINAL_SINK_MASK)
8420021a:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
8420021e:	00 00 
84200220:	56 60       	if EQ jump (m) Lc_aec_reference_connect_26;

84200222 <Lc_aec_reference_connect_12>:
    {
        terminal_id &= ~ TERMINAL_SINK_MASK;
84200222:	bf ff 77 ff 	r5 = r5 AND 0xff7fffff;
84200226:	ff 1f 

        if(terminal_id==AEC_REF_MIC_TERMINAL1)
84200228:	b8 24       	Null = r5 - 2;
8420022a:	3c 62       	if NE jump (m) Lc_aec_reference_connect_21;

8420022c <Lc_aec_reference_connect_13>:
        {
            RATEMATCHING_SUPPORT ability;

            /* get info about overridden endpoints */
            op_extra_data->mic_endpoint = opmgr_override_get_endpoint(op_data,
                                                                      AEC_REF_MIC_TERMINAL1 | TERMINAL_SINK_MASK);
8420022c:	08 f0 03 f0 	r1 = Null + 8388610;
84200230:	02 40 
84200232:	4a 08       	r0 = r7 + Null;
84200234:	ff fd 29 f0 	call (m) 0x546c;
84200238:	39 e1 
8420023a:	62 f0 a2 8e 	M[r4 + 648] = r0;

            if (!opmgr_override_get_ratematch_ability(op_extra_data->mic_endpoint,
                                                      &ability))
8420023e:	c3 11       	r1 = FP + 28;
84200240:	62 f0 a2 88 	r0 = M[r4 + 648];
84200244:	ff fd 29 f0 	call (m) 0x555a;
84200248:	37 e8 
8420024a:	10 04       	Null = r0 - Null;
8420024c:	e0 61       	if EQ jump (m) Lc_aec_reference_connect_9;

8420024e <Lc_aec_reference_connect_14>:
            /* Save rate matching ability HW or SW*/
            op_extra_data->mic_rate_ability   = RATEMATCHING_SUPPORT_SW;
            op_extra_data->mic_rate_enactment = RATEMATCHING_SUPPORT_SW;
#else
            /* Save rate matching ability HW or SW*/
            op_extra_data->mic_rate_ability   = ability;
8420024e:	e1 d0       	rMAC = MBS[FP + 28];
84200250:	61 f0 cc 8b 	MB[r4 + 460] = rMAC;
            op_extra_data->mic_rate_enactment = RATEMATCHING_SUPPORT_NONE;
84200254:	60 f0 cd 8b 	MB[r4 + 461] = Null;
#endif
            if (op_extra_data->mic_sync_enable)
84200258:	60 f0 cd 88 	Null = M[r4 + 820];
8420025c:	0b 60       	if EQ jump (m) Lc_aec_reference_connect_17;

8420025e <Lc_aec_reference_connect_15>:
            {
                /* Mic output will be synchronised to speaker input, SW or HW depends on
                 * it's ability.
                 */
                op_extra_data->mic_rate_enactment = op_extra_data->mic_rate_ability;
8420025e:	61 f0 cd 8b 	MB[r4 + 461] = rMAC;
                if (op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
84200262:	88 24       	Null = rMAC - 2;
84200264:	07 62       	if NE jump (m) Lc_aec_reference_connect_17;

84200266 <Lc_aec_reference_connect_16>:
                {
                    opmgr_override_set_ratematch_enacting(op_extra_data->mic_endpoint,
                                                          TRUE);
84200266:	43 20       	r1 = Null + 1;
84200268:	62 f0 a2 88 	r0 = M[r4 + 648];
8420026c:	ff fd 29 f0 	call (m) 0x554a;
84200270:	3f e6 

84200272 <Lc_aec_reference_connect_17>:
                }
            }

#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            /* see if mic graph wants to use an external rate adjust operator */
            aec_reference_mic_check_external_rate_adjust_op(op_extra_data);
84200272:	32 00       	r0 = r4 + Null;
84200274:	08 f0 25 e7 	call (m) $_aec_reference_mic_check_external_rate_adjust_op;
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

            if (!opmgr_override_get_sample_rate(op_extra_data->mic_endpoint,
                                                &op_extra_data->mic_rate))
84200278:	63 f0 c8 21 	r1 = r4 + 456;
8420027c:	62 f0 a2 88 	r0 = M[r4 + 648];
84200280:	ff fd 29 f0 	call (m) 0x54ec;
84200284:	2d e3 
84200286:	10 04       	Null = r0 - Null;
84200288:	c2 61       	if EQ jump (m) Lc_aec_reference_connect_9;

8420028a <Lc_aec_reference_connect_18>:
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
        {
            op_extra_data->spkr_in_endpoint = opmgr_override_get_endpoint(op_data,
                                                                          AEC_REF_INPUT_TERMINAL1 | TERMINAL_SINK_MASK);
        }
        bufp = &op_extra_data->input_stream[terminal_id];
8420028a:	7a 54       	r0 = r5 LSHIFT 2;
8420028c:	31 00       	rMAC = r4 + Null;
8420028e:	51 00       	rMAC = r0 + rMAC;
84200290:	0b 00       	r1 = rMAC + Null;
inline static bool IsSpeakerInputTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_INPUT_TERMINAL1)
          || (term_idx==AEC_REF_INPUT_TERMINAL2)
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
84200292:	78 24       	Null = r5 - 1;
84200294:	13 60       	if EQ jump (m) Lc_aec_reference_connect_23;

84200296 <Lc_aec_reference_connect_19>:
84200296:	b8 25       	Null = r5 - 6;
84200298:	61 64       	if NC jump (m) Lc_aec_reference_connect_38;

8420029a <Lc_aec_reference_connect_20>:
8420029a:	f8 26       	Null = r5 - 11;
8420029c:	09 f0 9f e0 	if LS jump (m) Lc_aec_reference_connect_23;

842002a0 <Lc__ite_14>:
842002a0:	5d 6e       	jump (m) Lc_aec_reference_connect_38;

842002a2 <Lc_aec_reference_connect_21>:
                base_op_change_response_status(response_data,
                                               STATUS_INVALID_CMD_PARAMS);
                return TRUE;
            }
        }
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
842002a2:	38 04       	Null = r5 - Null;
842002a4:	f3 63       	if NE jump (m) Lc_aec_reference_connect_18;

842002a6 <Lc_aec_reference_connect_22>:
        {
            op_extra_data->spkr_in_endpoint = opmgr_override_get_endpoint(op_data,
                                                                          AEC_REF_INPUT_TERMINAL1 | TERMINAL_SINK_MASK);
842002a6:	08 f0 03 f0 	r1 = Null + 8388608;
842002aa:	00 40 
842002ac:	4a 08       	r0 = r7 + Null;
842002ae:	ff fd 28 f0 	call (m) 0x546c;
842002b2:	3f ed 
842002b4:	62 f0 a5 8e 	M[r4 + 660] = r0;
        }
        bufp = &op_extra_data->input_stream[terminal_id];
842002b8:	33 00       	r1 = r4 + Null;

842002ba <Lc_aec_reference_connect_23>:
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(tCbuffer *buff)
{
    if (buff->metadata != NULL)
842002ba:	81 f0 06 88 	rMAC = M[r6 + 24];
842002be:	4e 60       	if EQ jump (m) Lc_aec_reference_connect_38;

842002c0 <Lc_aec_reference_connect_24>:
         */
        if(IsSpeakerInputTerminal(terminal_id) &&
           buff_has_metadata(pterminal_buf))
        {
            /* set metadata buffer if it hasn't been set already */
            if(NULL == op_extra_data->spkr_input_metadata_buffer)
842002c0:	61 f0 c2 88 	rMAC = M[r4 + 776];
842002c4:	4b 62       	if NE jump (m) Lc_aec_reference_connect_38;

842002c6 <Lc_aec_reference_connect_25>:
            {
                op_extra_data->spkr_input_metadata_buffer = pterminal_buf;
842002c6:	68 f0 c2 8e 	M[r4 + 776] = r6;
842002ca:	48 6e       	jump (m) Lc_aec_reference_connect_38;

842002cc <Lc_aec_reference_connect_26>:
        }
#endif /* AEC_REFERENCE_SUPPORT_METADATA */
    }
    else
    {
        if(terminal_id==AEC_REF_SPKR_TERMINAL1)
842002cc:	78 24       	Null = r5 - 1;
842002ce:	31 62       	if NE jump (m) Lc_aec_reference_connect_33;

842002d0 <Lc_aec_reference_connect_27>:
        {
            RATEMATCHING_SUPPORT ability;

            op_extra_data->spkr_endpoint = opmgr_override_get_endpoint(op_data,
                                                                       AEC_REF_SPKR_TERMINAL1);
842002d0:	43 20       	r1 = Null + 1;
842002d2:	4a 08       	r0 = r7 + Null;
842002d4:	ff fd 28 f0 	call (m) 0x546c;
842002d8:	39 ec 
842002da:	62 f0 a3 8e 	M[r4 + 652] = r0;

            if (!opmgr_override_get_ratematch_ability(op_extra_data->spkr_endpoint,
                                                      &ability))
842002de:	03 12       	r1 = FP + 32;
842002e0:	62 f0 a3 88 	r0 = M[r4 + 652];
842002e4:	ff fd 29 f0 	call (m) 0x555a;
842002e8:	37 e3 
842002ea:	10 04       	Null = r0 - Null;
842002ec:	90 61       	if EQ jump (m) Lc_aec_reference_connect_9;

842002ee <Lc_aec_reference_connect_28>:

#if defined(ENABLE_FORCE_SW_RATEMATCH)
            op_extra_data->spkr_rate_ability   = RATEMATCHING_SUPPORT_SW;
            op_extra_data->spkr_rate_enactment = RATEMATCHING_SUPPORT_SW;
#else
            op_extra_data->spkr_rate_ability   = ability;
842002ee:	01 d1       	rMAC = MBS[FP + 32];
842002f0:	61 f0 7c 8e 	M[r4 + 496] = rMAC;
            op_extra_data->spkr_rate_enactment = RATEMATCHING_SUPPORT_NONE;
842002f4:	60 f0 7e 8e 	M[r4 + 504] = Null;
#endif

#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            /* see if speaker graph wants to use an external rate adjust operator */
            aec_reference_spkr_check_external_rate_adjust_op(op_extra_data);
842002f8:	32 00       	r0 = r4 + Null;
842002fa:	08 f0 33 e0 	call (m) $_aec_reference_spkr_check_external_rate_adjust_op;
#endif
            if (!opmgr_override_get_sample_rate(op_extra_data->spkr_endpoint,
                                                &op_extra_data->spkr_rate))
842002fe:	63 f0 ec 21 	r1 = r4 + 492;
84200302:	62 f0 a3 88 	r0 = M[r4 + 652];
84200306:	ff fd 28 f0 	call (m) 0x54ec;
8420030a:	27 ef 
8420030c:	10 04       	Null = r0 - Null;
8420030e:	7f 61       	if EQ jump (m) Lc_aec_reference_connect_9;

84200310 <Lc_aec_reference_connect_29>:
        }
        else if(terminal_id==AEC_REF_REFERENCE_TERMINAL)
        {
            op_extra_data->sync_block.speaker_data = 0;
        }
        bufp = &op_extra_data->output_stream[terminal_id];
84200310:	7a 54       	r0 = r5 LSHIFT 2;
84200312:	31 00       	rMAC = r4 + Null;
84200314:	51 00       	rMAC = r0 + rMAC;
84200316:	13 f0 40 20 	r1 = rMAC + 64;
{
    return ((AEC_REF_OUTPUT_TERMINAL1 <= term_idx &&
            AEC_REF_OUTPUT_TERMINAL4 >= term_idx) ||
            (AEC_REF_OUTPUT_TERMINAL5 <= term_idx &&
                         AEC_REF_OUTPUT_TERMINAL8 >= term_idx)
            );
8420031a:	f8 24       	Null = r5 - 3;
8420031c:	1f 64       	if NC jump (m) Lc_aec_reference_connect_38;

8420031e <Lc_aec_reference_connect_30>:
8420031e:	b8 25       	Null = r5 - 6;
84200320:	09 f0 ab e0 	if LS jump (m) Lc_aec_reference_connect_35;

84200324 <Lc_aec_reference_connect_31>:
84200324:	78 27       	Null = r5 - 13;
84200326:	1a 64       	if NC jump (m) Lc_aec_reference_connect_38;

84200328 <Lc_aec_reference_connect_32>:
84200328:	38 2c       	Null = r5 - 16;
8420032a:	09 f0 a1 e0 	if LS jump (m) Lc_aec_reference_connect_35;

8420032e <Lc__ite_15>:
8420032e:	16 6e       	jump (m) Lc_aec_reference_connect_38;

84200330 <Lc_aec_reference_connect_33>:
                                               STATUS_INVALID_CMD_PARAMS);
                return TRUE;
            }

        }
        else if (terminal_id==AEC_REF_OUTPUT_TERMINAL1)
84200330:	f8 24       	Null = r5 - 3;
84200332:	1e 62       	if NE jump (m) Lc_aec_reference_connect_40;

84200334 <Lc_aec_reference_connect_34>:
        {
            op_extra_data->mic_out_endpoint = opmgr_override_get_endpoint(op_data,
                                                                          AEC_REF_OUTPUT_TERMINAL1);
84200334:	c3 20       	r1 = Null + 3;
84200336:	4a 08       	r0 = r7 + Null;
84200338:	ff fd 28 f0 	call (m) 0x546c;
8420033c:	35 e9 
8420033e:	62 f0 a4 8e 	M[r4 + 656] = r0;
            op_extra_data->sync_block.mic_data = 0;
84200342:	60 f0 ae 8e 	M[r4 + 696] = Null;
        }
        else if(terminal_id==AEC_REF_REFERENCE_TERMINAL)
        {
            op_extra_data->sync_block.speaker_data = 0;
        }
        bufp = &op_extra_data->output_stream[terminal_id];
84200346:	63 f0 4c 20 	r1 = r4 + 76;

8420034a <Lc_aec_reference_connect_35>:
8420034a:	81 f0 06 88 	rMAC = M[r6 + 24];
8420034e:	06 60       	if EQ jump (m) Lc_aec_reference_connect_38;

84200350 <Lc_aec_reference_connect_36>:
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
       /* set metadata buffer for mic outputs */
       if(IsMicrophoneOutputTerminal(terminal_id) &&
          buff_has_metadata(pterminal_buf))
       {
           if(NULL == op_extra_data->mic_metadata_buffer)
84200350:	61 f0 c3 88 	rMAC = M[r4 + 780];
84200354:	03 62       	if NE jump (m) Lc_aec_reference_connect_38;

84200356 <Lc_aec_reference_connect_37>:
           {   /* first connected mic output buffer with metadata */
               op_extra_data->mic_metadata_buffer = pterminal_buf;
84200356:	68 f0 c3 8e 	M[r4 + 780] = r6;

8420035a <Lc_aec_reference_connect_38>:
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */

    }

    /* set the stream buffer for this terminal and rebuild the graphs if needed */
    if(aec_reference_update_stream_and_validate_channels(op_data, bufp, pterminal_buf))
8420035a:	44 08       	r2 = r6 + Null;
8420035c:	4a 08       	r0 = r7 + Null;
8420035e:	12 f0 29 e2 	call (m) $_aec_reference_update_stream_and_validate_channels;
84200362:	10 04       	Null = r0 - Null;
84200364:	59 61       	if EQ jump (m) Lc_aec_reference_connect_10;

84200366 <Lc_aec_reference_connect_39>:
84200366:	a1 f0 00 e8 	rMAC = M[r8 + Null];
8420036a:	48 8e       	M[rMAC + 4] = Null;
8420036c:	55 6f       	jump (m) Lc_aec_reference_connect_10;

8420036e <Lc_aec_reference_connect_40>:
        {
            op_extra_data->mic_out_endpoint = opmgr_override_get_endpoint(op_data,
                                                                          AEC_REF_OUTPUT_TERMINAL1);
            op_extra_data->sync_block.mic_data = 0;
        }
        else if(terminal_id==AEC_REF_REFERENCE_TERMINAL)
8420036e:	38 04       	Null = r5 - Null;
84200370:	d0 63       	if NE jump (m) Lc_aec_reference_connect_29;

84200372 <Lc_aec_reference_connect_41>:
        {
            op_extra_data->sync_block.speaker_data = 0;
84200372:	60 f0 af 8e 	M[r4 + 700] = Null;
        }
        bufp = &op_extra_data->output_stream[terminal_id];
84200376:	63 f0 40 20 	r1 = r4 + 64;
8420037a:	f0 6f       	jump (m) Lc_aec_reference_connect_38;

8420037c <Lc_aec_reference_connect_42>:
    if(aec_reference_update_stream_and_validate_channels(op_data, bufp, pterminal_buf))
    {
        base_op_change_response_status(response_data,STATUS_OK);
    }
    return TRUE;
}
8420037c:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
8420037e:	d8 4c       	rts;

84200380 <$_aec_reference_disconnect>:

bool aec_reference_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200380:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84200382:	10 09       	r6 = r0 + Null;
84200384:	1f 00       	r5 = r1 + Null;
84200386:	29 09       	r7 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84200388:	ff fd 00 f0 	call (m) 0x4e6;
8420038c:	3f ea 
8420038e:	16 00       	r4 = r0 + Null;
}

bool aec_reference_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_DISCONNECT_TERMINAL_ID(message_data);
84200390:	3f e8       	r5 = M[r5 + Null];
    tCbuffer **bufp = NULL;

    patch_fn_shared(aec_reference);

    L3_DBG_MSG1("AEC REFERENCE --- disconnect TID = %x", terminal_id);
84200392:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200396:	c8 24       	Null = rMAC - 3;
84200398:	08 68       	if LT jump (m) Lc_aec_reference_disconnect_3;

8420039a <Lc_aec_reference_disconnect_2>:
8420039a:	55 f1 02 f0 	r0 = Null + 357564451;
8420039e:	23 40 
842003a0:	3b 00       	r1 = r5 + Null;
842003a2:	ff fd 04 f0 	call (m) 0xcde;
842003a6:	3d e9 

842003a8 <Lc_aec_reference_disconnect_3>:

    /* Setup Response to Disconnection Request. Assume Failure*/
    if(!base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data))
842003a8:	03 f0 00 60 	r1 = Null + 4096;
842003ac:	4c 08       	r2 = r7 + Null;
842003ae:	42 08       	r0 = r6 + Null;
842003b0:	ff fd 00 f0 	call (m) 0x4bc;
842003b4:	2d e8 
842003b6:	10 04       	Null = r0 - Null;
842003b8:	03 62       	if NE jump (m) Lc_aec_reference_disconnect_5;

842003ba <Lc_aec_reference_disconnect_4>:
    {
        return(FALSE);
842003ba:	02 00       	r0 = Null + Null;
842003bc:	9a 6e       	jump (m) Lc_aec_reference_disconnect_53;

842003be <Lc_aec_reference_disconnect_5>:
    }

    /* check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources.  */
    if(!base_op_is_terminal_valid(op_data, terminal_id))
842003be:	3b 00       	r1 = r5 + Null;
842003c0:	42 08       	r0 = r6 + Null;
842003c2:	ff fd 00 f0 	call (m) 0x496;
842003c6:	35 e6 
842003c8:	10 04       	Null = r0 - Null;
842003ca:	07 62       	if NE jump (m) Lc_aec_reference_disconnect_7;

842003cc <Lc_aec_reference_disconnect_6>:
842003cc:	01 f0 03 60 	rMAC = Null + 4099;
842003d0:	92 f0 00 e8 	r0 = M[r7 + Null];
842003d4:	51 8e       	M[r0 + 4] = rMAC;
842003d6:	79 6e       	jump (m) Lc_aec_reference_disconnect_47;

842003d8 <Lc_aec_reference_disconnect_7>:
        base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    /* check if the terminal is connected and if so , disconnect the terminal */
    if(terminal_id & TERMINAL_SINK_MASK)
842003d8:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
842003dc:	00 00 
842003de:	3c 60       	if EQ jump (m) Lc_aec_reference_disconnect_28;

842003e0 <Lc_aec_reference_disconnect_8>:
inline static bool IsSpeakerInputTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_INPUT_TERMINAL1)
          || (term_idx==AEC_REF_INPUT_TERMINAL2)
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
842003e0:	bf ff 77 ff 	r5 = r5 AND 0xff7fffff;
842003e4:	ff 1f 
842003e6:	08 60       	if EQ jump (m) Lc_aec_reference_disconnect_12;

842003e8 <Lc_aec_reference_disconnect_9>:
842003e8:	78 24       	Null = r5 - 1;
842003ea:	06 60       	if EQ jump (m) Lc_aec_reference_disconnect_12;

842003ec <Lc_aec_reference_disconnect_10>:
842003ec:	b8 25       	Null = r5 - 6;
842003ee:	26 64       	if NC jump (m) Lc_aec_reference_disconnect_25;

842003f0 <Lc_aec_reference_disconnect_11>:
842003f0:	f8 26       	Null = r5 - 11;
842003f2:	08 f0 c1 e0 	if HI jump (m) Lc_aec_reference_disconnect_24;

842003f6 <Lc_aec_reference_disconnect_12>:
        terminal_id &= ~ TERMINAL_SINK_MASK;

#ifdef AEC_REFERENCE_SUPPORT_METADATA
        if(IsSpeakerInputTerminal(terminal_id))
        {
            tCbuffer *this_buf = op_extra_data->input_stream[terminal_id];
842003f6:	7a 54       	r0 = r5 LSHIFT 2;
842003f8:	b1 e8       	rMAC = M[r4 + r0];
            if(this_buf == op_extra_data->spkr_input_metadata_buffer)
842003fa:	62 f0 c2 88 	r0 = M[r4 + 776];
842003fe:	88 04       	Null = rMAC - r0;
84200400:	15 62       	if NE jump (m) Lc_aec_reference_disconnect_22;

84200402 <Lc_aec_reference_disconnect_13>:
            {
                /* disconnecting buffer is the metadata buffer,
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
84200402:	02 00       	r0 = Null + Null;
                int idx;
                for(idx=0; idx < MAX_NUMBER_SPEAKERS; idx++)
84200404:	03 00       	r1 = Null + Null;
84200406:	03 6e       	jump (m) Lc_aec_reference_disconnect_15;

84200408 <Lc_aec_reference_disconnect_14>:
                {
                    tCbuffer *inp_buf = op_extra_data->input_stream[SpeakerInputTerminalByIndex(idx)];
84200408:	98 24       	Null = r1 - 2;
8420040a:	03 66       	if GE jump (m) Lc_aec_reference_disconnect_16;

8420040c <Lc_aec_reference_disconnect_15>:
8420040c:	1c 00       	r2 = r1 + Null;
8420040e:	02 6e       	jump (m) Lc_aec_reference_disconnect_17;

84200410 <Lc_aec_reference_disconnect_16>:
84200410:	1c 21       	r2 = r1 + 4;

84200412 <Lc_aec_reference_disconnect_17>:
84200412:	64 54       	r2 = r2 LSHIFT 2;
                    if(inp_buf != NULL &&
                       inp_buf != this_buf &&
                       buff_has_metadata(inp_buf))
84200414:	34 e9       	r2 = M[r4 + r2];
84200416:	05 60       	if EQ jump (m) Lc_aec_reference_disconnect_20;

84200418 <Lc_aec_reference_disconnect_18>:
84200418:	60 04       	Null = r2 - rMAC;
8420041a:	03 60       	if EQ jump (m) Lc_aec_reference_disconnect_20;

8420041c <Lc_aec_reference_disconnect_19>:
8420041c:	a5 89       	r3 = M[r2 + 24];
8420041e:	65 62       	if NE jump (m) Lc_aec_reference_disconnect_51;

84200420 <Lc_aec_reference_disconnect_20>:
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
                int idx;
                for(idx=0; idx < MAX_NUMBER_SPEAKERS; idx++)
84200420:	5b 20       	r1 = r1 + 1;
84200422:	18 26       	Null = r1 - 8;
84200424:	f2 69       	if LT jump (m) Lc_aec_reference_disconnect_14;

84200426 <Lc_aec_reference_disconnect_21>:
                    {
                        new_metadata_buf = inp_buf;
                        break;
                    }
                }
                op_extra_data->spkr_input_metadata_buffer = new_metadata_buf;
84200426:	62 f0 c2 8e 	M[r4 + 776] = r0;

8420042a <Lc_aec_reference_disconnect_22>:
                op_extra_data->mic_ext_rate_adjust_op = 0;
            }
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

        }
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
8420042a:	38 04       	Null = r5 - Null;
8420042c:	03 62       	if NE jump (m) Lc_aec_reference_disconnect_24;

8420042e <Lc_aec_reference_disconnect_23>:
        {
            op_extra_data->spkr_in_endpoint=NULL;
8420042e:	60 f0 a5 8e 	M[r4 + 660] = Null;

84200432 <Lc_aec_reference_disconnect_24>:
        }
        bufp = &op_extra_data->input_stream[terminal_id];
84200432:	7a 54       	r0 = r5 LSHIFT 2;
84200434:	33 00       	r1 = r4 + Null;
84200436:	d3 00       	r1 = r0 + r1;
84200438:	3f 6e       	jump (m) Lc_aec_reference_disconnect_45;

8420043a <Lc_aec_reference_disconnect_25>:
                op_extra_data->spkr_input_metadata_buffer = new_metadata_buf;
            }
        }
#endif /* AEC_REFERENCE_SUPPORT_METADATA */

        if(terminal_id==AEC_REF_MIC_TERMINAL1)
8420043a:	b8 24       	Null = r5 - 2;
8420043c:	fb 63       	if NE jump (m) Lc_aec_reference_disconnect_24;

8420043e <Lc_aec_reference_disconnect_26>:
        {
            op_extra_data->mic_endpoint=NULL;
8420043e:	60 f0 a2 8e 	M[r4 + 648] = Null;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            if(op_extra_data->mic_ext_rate_adjust_op != 0)
84200442:	62 f0 a0 88 	r0 = M[r4 + 640];
84200446:	f6 61       	if EQ jump (m) Lc_aec_reference_disconnect_24;

84200448 <Lc_aec_reference_disconnect_27>:
            {
                /* set external op to passthrough mode */
                stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->mic_ext_rate_adjust_op, TRUE);
84200448:	43 20       	r1 = Null + 1;
8420044a:	ff fd 9c f0 	call (m) 0x13d48;
8420044e:	3f e7 
                op_extra_data->mic_ext_rate_adjust_op = 0;
84200450:	60 f0 a0 8e 	M[r4 + 640] = Null;
84200454:	ef 6f       	jump (m) Lc_aec_reference_disconnect_24;

84200456 <Lc_aec_reference_disconnect_28>:
{
    return ((AEC_REF_OUTPUT_TERMINAL1 <= term_idx &&
            AEC_REF_OUTPUT_TERMINAL4 >= term_idx) ||
            (AEC_REF_OUTPUT_TERMINAL5 <= term_idx &&
                         AEC_REF_OUTPUT_TERMINAL8 >= term_idx)
            );
84200456:	f8 24       	Null = r5 - 3;
84200458:	3a 64       	if NC jump (m) Lc_aec_reference_disconnect_48;

8420045a <Lc_aec_reference_disconnect_29>:
8420045a:	b8 25       	Null = r5 - 6;
8420045c:	09 f0 8f e0 	if LS jump (m) Lc_aec_reference_disconnect_32;

84200460 <Lc_aec_reference_disconnect_30>:
84200460:	78 27       	Null = r5 - 13;
84200462:	26 64       	if NC jump (m) Lc_aec_reference_disconnect_44;

84200464 <Lc_aec_reference_disconnect_31>:
84200464:	38 2c       	Null = r5 - 16;
84200466:	08 f0 c9 e0 	if HI jump (m) Lc_aec_reference_disconnect_44;

8420046a <Lc_aec_reference_disconnect_32>:
    else
    {
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
        if(IsMicrophoneOutputTerminal(terminal_id))
        {
            tCbuffer *this_buf = op_extra_data->output_stream[terminal_id];
8420046a:	7a 54       	r0 = r5 LSHIFT 2;
8420046c:	31 00       	rMAC = r4 + Null;
8420046e:	51 00       	rMAC = r0 + rMAC;
84200470:	09 a8       	rMAC = M[rMAC + 64];
            if(this_buf == op_extra_data->mic_metadata_buffer)
84200472:	62 f0 c3 88 	r0 = M[r4 + 780];
84200476:	88 04       	Null = rMAC - r0;
84200478:	17 62       	if NE jump (m) Lc_aec_reference_disconnect_42;

8420047a <Lc_aec_reference_disconnect_33>:
            {
                /* disconnecting buffer is the mic metadata buffer,
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
8420047a:	02 00       	r0 = Null + Null;
                int idx;
                for(idx=0; idx < MAX_NUMBER_MICS; idx++)
8420047c:	03 00       	r1 = Null + Null;
8420047e:	03 6e       	jump (m) Lc_aec_reference_disconnect_35;

84200480 <Lc_aec_reference_disconnect_34>:
                {
                    tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
84200480:	98 24       	Null = r1 - 2;
84200482:	03 66       	if GE jump (m) Lc_aec_reference_disconnect_36;

84200484 <Lc_aec_reference_disconnect_35>:
84200484:	dc 20       	r2 = r1 + 3;
84200486:	02 6e       	jump (m) Lc_aec_reference_disconnect_37;

84200488 <Lc_aec_reference_disconnect_36>:
84200488:	5c 22       	r2 = r1 + 9;

8420048a <Lc_aec_reference_disconnect_37>:
8420048a:	65 f0 40 20 	r3 = r4 + 64;
8420048e:	64 54       	r2 = r2 LSHIFT 2;
                    if(out_buf != NULL &&
                       out_buf != this_buf &&
                       buff_has_metadata(out_buf))
84200490:	2c e9       	r2 = M[r3 + r2];
84200492:	05 60       	if EQ jump (m) Lc_aec_reference_disconnect_40;

84200494 <Lc_aec_reference_disconnect_38>:
84200494:	60 04       	Null = r2 - rMAC;
84200496:	03 60       	if EQ jump (m) Lc_aec_reference_disconnect_40;

84200498 <Lc_aec_reference_disconnect_39>:
84200498:	a5 89       	r3 = M[r2 + 24];
8420049a:	29 62       	if NE jump (m) Lc_aec_reference_disconnect_52;

8420049c <Lc_aec_reference_disconnect_40>:
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
                int idx;
                for(idx=0; idx < MAX_NUMBER_MICS; idx++)
8420049c:	5b 20       	r1 = r1 + 1;
8420049e:	18 26       	Null = r1 - 8;
842004a0:	f0 69       	if LT jump (m) Lc_aec_reference_disconnect_34;

842004a2 <Lc_aec_reference_disconnect_41>:
                    {
                        new_metadata_buf = out_buf;
                        break;
                    }
                }
                op_extra_data->mic_metadata_buffer = new_metadata_buf;
842004a2:	62 f0 c3 8e 	M[r4 + 780] = r0;

842004a6 <Lc_aec_reference_disconnect_42>:
                op_extra_data->spkr_ext_rate_adjust_op = 0;
            }
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

        }
        else if(terminal_id==AEC_REF_OUTPUT_TERMINAL1)
842004a6:	f8 24       	Null = r5 - 3;
842004a8:	03 62       	if NE jump (m) Lc_aec_reference_disconnect_44;

842004aa <Lc_aec_reference_disconnect_43>:
        {
            op_extra_data->mic_out_endpoint=NULL;
842004aa:	60 f0 a4 8e 	M[r4 + 656] = Null;

842004ae <Lc_aec_reference_disconnect_44>:
        }
        bufp = &op_extra_data->output_stream[terminal_id];
842004ae:	7a 54       	r0 = r5 LSHIFT 2;
842004b0:	96 01       	r4 = r0 + r4;
842004b2:	63 f0 40 20 	r1 = r4 + 64;

842004b6 <Lc_aec_reference_disconnect_45>:
    }

    /* clear the stream buffer for this terminal and rebuild the graphs if needed */
    if(aec_reference_update_stream_and_validate_channels(op_data, bufp, NULL))
842004b6:	04 00       	r2 = Null + Null;
842004b8:	42 08       	r0 = r6 + Null;
842004ba:	11 f0 2d e7 	call (m) $_aec_reference_update_stream_and_validate_channels;
842004be:	10 04       	Null = r0 - Null;
842004c0:	04 60       	if EQ jump (m) Lc_aec_reference_disconnect_47;

842004c2 <Lc_aec_reference_disconnect_46>:
842004c2:	91 f0 00 e8 	rMAC = M[r7 + Null];
842004c6:	48 8e       	M[rMAC + 4] = Null;

842004c8 <Lc_aec_reference_disconnect_47>:

    /* check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources.  */
    if(!base_op_is_terminal_valid(op_data, terminal_id))
    {
        base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
        return TRUE;
842004c8:	42 20       	r0 = Null + 1;
842004ca:	13 6e       	jump (m) Lc_aec_reference_disconnect_53;

842004cc <Lc_aec_reference_disconnect_48>:
                op_extra_data->mic_metadata_buffer = new_metadata_buf;
            }
        }
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */

        if(terminal_id==AEC_REF_SPKR_TERMINAL1)
842004cc:	78 24       	Null = r5 - 1;
842004ce:	f0 63       	if NE jump (m) Lc_aec_reference_disconnect_44;

842004d0 <Lc_aec_reference_disconnect_49>:
        {
            op_extra_data->spkr_endpoint=NULL;
842004d0:	60 f0 a3 8e 	M[r4 + 652] = Null;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            if(op_extra_data->spkr_ext_rate_adjust_op != 0)
842004d4:	62 f0 a1 88 	r0 = M[r4 + 644];
842004d8:	eb 61       	if EQ jump (m) Lc_aec_reference_disconnect_44;

842004da <Lc_aec_reference_disconnect_50>:
            {
                /* set external op to passthrough mode */
                stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->spkr_ext_rate_adjust_op, TRUE);
842004da:	43 20       	r1 = Null + 1;
842004dc:	ff fd 9c f0 	call (m) 0x13d48;
842004e0:	2d e3 
                op_extra_data->spkr_ext_rate_adjust_op = 0;
842004e2:	60 f0 a1 8e 	M[r4 + 644] = Null;
842004e6:	e4 6f       	jump (m) Lc_aec_reference_disconnect_44;

842004e8 <Lc_aec_reference_disconnect_51>:
                    tCbuffer *inp_buf = op_extra_data->input_stream[SpeakerInputTerminalByIndex(idx)];
                    if(inp_buf != NULL &&
                       inp_buf != this_buf &&
                       buff_has_metadata(inp_buf))
                    {
                        new_metadata_buf = inp_buf;
842004e8:	22 00       	r0 = r2 + Null;
                        break;
842004ea:	9e 6f       	jump (m) Lc_aec_reference_disconnect_21;

842004ec <Lc_aec_reference_disconnect_52>:
                    tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
                    if(out_buf != NULL &&
                       out_buf != this_buf &&
                       buff_has_metadata(out_buf))
                    {
                        new_metadata_buf = out_buf;
842004ec:	22 00       	r0 = r2 + Null;
                        break;
842004ee:	da 6f       	jump (m) Lc_aec_reference_disconnect_41;

842004f0 <Lc_aec_reference_disconnect_53>:
    {
        base_op_change_response_status(response_data,STATUS_OK);
    }

    return TRUE;
}
842004f0:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842004f2:	d8 4c       	rts;

842004f4 <$_aec_reference_start>:

    return TRUE;
}

bool aec_reference_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842004f4:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842004f6:	16 00       	r4 = r0 + Null;
842004f8:	2f 00       	r5 = r3 + Null;
    patch_fn_shared(aec_reference);

    /* Setup Response to Start Request.   Assume Failure*/
    if(!base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data))
842004fa:	03 f0 00 60 	r1 = Null + 4096;
842004fe:	3c 00       	r2 = r5 + Null;
84200500:	ef fd ff ff 	call (m) 0x4bc;
84200504:	3d ed 
84200506:	10 04       	Null = r0 - Null;
84200508:	03 62       	if NE jump (m) Lc_aec_reference_start_3;

8420050a <Lc_aec_reference_start_2>:
    {
        return(FALSE);
8420050a:	02 00       	r0 = Null + Null;
8420050c:	15 6e       	jump (m) Lc_aec_reference_start_8;

8420050e <Lc_aec_reference_start_3>:
    }
    /* do something only if the current state is "connected" */
    if (opmgr_op_is_running(op_data))
8420050e:	32 00       	r0 = r4 + Null;
84200510:	ff fd 28 f0 	call (m) 0x5700;
84200514:	31 ef 
84200516:	10 04       	Null = r0 - Null;
84200518:	0c 62       	if NE jump (m) Lc_aec_reference_start_6;

8420051a <Lc_aec_reference_start_4>:
        base_op_change_response_status(response_data,STATUS_OK);
        return(TRUE);
    }

    /* Validate channel configuration */
    if(!validate_channels_and_build(op_data))
8420051a:	32 00       	r0 = r4 + Null;
8420051c:	0b f0 23 ed 	call (m) $_validate_channels_and_build;
84200520:	10 04       	Null = r0 - Null;
84200522:	09 60       	if EQ jump (m) Lc_aec_reference_start_7;

84200524 <Lc_aec_reference_start_5>:
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84200524:	32 00       	r0 = r4 + Null;
84200526:	ef fd ff ff 	call (m) 0x4e6;
8420052a:	21 ee 
    }
#ifdef AEC_REFERENCE_SPKR_TTP
    {
        AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
        /* initialisation for timed playback in speaker path */
        aec_reference_spkr_ttp_init(op_extra_data);
8420052c:	14 f0 31 e8 	call (m) $_aec_reference_spkr_ttp_init;

84200530 <Lc_aec_reference_start_6>:
84200530:	39 e8       	rMAC = M[r5 + Null];
84200532:	48 8e       	M[rMAC + 4] = Null;

84200534 <Lc_aec_reference_start_7>:
    }
    /* do something only if the current state is "connected" */
    if (opmgr_op_is_running(op_data))
    {
        base_op_change_response_status(response_data,STATUS_OK);
        return(TRUE);
84200534:	42 20       	r0 = Null + 1;

84200536 <Lc_aec_reference_start_8>:
    }
#endif /* AEC_REFERENCE_SPKR_TTP */

    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
}
84200536:	f2 48       	popm <FP, r4, r5, rLink>;
84200538:	d8 4c       	rts;

8420053a <$_aec_reference_get_data_format>:

    return TRUE;
}

bool aec_reference_get_data_format(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420053a:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420053c:	2e 00       	r4 = r3 + Null;
    /* Set up the a default success response information */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
8420053e:	03 00       	r1 = Null + Null;
84200540:	34 00       	r2 = r4 + Null;
84200542:	ef fd ff ff 	call (m) 0x4bc;
84200546:	3b eb 
84200548:	10 04       	Null = r0 - Null;
8420054a:	03 62       	if NE jump (m) Lc_aec_reference_get_data_format_3;

8420054c <Lc_aec_reference_get_data_format_2>:
    {
        return FALSE;
8420054c:	02 00       	r0 = Null + Null;
8420054e:	05 6e       	jump (m) Lc_aec_reference_get_data_format_4;

84200550 <Lc_aec_reference_get_data_format_3>:
    }

    ((OP_STD_RSP*)*response_data)->resp_data.data = AUDIO_DATA_FORMAT_FIXP;
84200550:	41 20       	rMAC = Null + 1;
84200552:	32 e8       	r0 = M[r4 + Null];
84200554:	91 8e       	M[r0 + 8] = rMAC;
    return TRUE;
84200556:	0a 00       	r0 = rMAC + Null;

84200558 <Lc_aec_reference_get_data_format_4>:
}
84200558:	f1 48       	popm <FP, r4, rLink>;
8420055a:	d8 4c       	rts;

8420055c <$_aec_reference_buffer_details>:

    return TRUE;
}

bool aec_reference_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420055c:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
8420055e:	12 09       	r8 = r0 + Null;
84200560:	18 09       	r6 = r1 + Null;
84200562:	23 09       	r9 = r2 + Null;
84200564:	29 09       	r7 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84200566:	ef fd ff ff 	call (m) 0x4e6;
8420056a:	21 ec 
8420056c:	16 00       	r4 = r0 + Null;
}

bool aec_reference_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned term_id = OPMGR_GET_OP_BUF_DETAILS_TERMINAL_ID(message_data);
8420056e:	87 f0 00 e8 	r5 = M[r6 + Null];
    OP_BUF_DETAILS_RSP *resp;

    patch_fn_shared(aec_reference);

    if(!base_op_buffer_details(op_data, message_data, response_id, response_data))
84200572:	4d 08       	r3 = r7 + Null;
84200574:	5c 08       	r2 = r9 + Null;
84200576:	43 08       	r1 = r6 + Null;
84200578:	52 08       	r0 = r8 + Null;
8420057a:	ef fd ff ff 	call (m) 0x37c;
8420057e:	23 e0 
84200580:	10 04       	Null = r0 - Null;
84200582:	03 62       	if NE jump (m) Lc_aec_reference_buffer_details_3;

84200584 <Lc_aec_reference_buffer_details_2>:
    {
        return FALSE;
84200584:	02 00       	r0 = Null + Null;
84200586:	8e 6e       	jump (m) Lc_aec_reference_buffer_details_30;

84200588 <Lc_aec_reference_buffer_details_3>:
    }
    resp = (OP_BUF_DETAILS_RSP*)*response_data;
84200588:	98 f0 00 e8 	r6 = M[r7 + Null];

    if ( term_id & TERMINAL_SINK_MASK)
8420058c:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
84200590:	00 00 
84200592:	0d 60       	if EQ jump (m) Lc_aec_reference_buffer_details_7;

84200594 <Lc_aec_reference_buffer_details_4>:
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
}
inline static bool IsMicrophoneTerminal(unsigned term_idx)
{
    term_idx &= ~TERMINAL_SINK_MASK;
84200594:	bf ff 71 ff 	rMAC = r5 AND 0xff7fffff;
84200598:	ff 1f 

    if(term_idx < AEC_REF_MIC_TERMINAL1)
8420059a:	88 24       	Null = rMAC - 2;
8420059c:	02 f0 f3 e1 	if C jump (m) Lc_aec_reference_buffer_details_28;

842005a0 <Lc_aec_reference_buffer_details_5>:
            resp->needs_override = TRUE;
            resp->b.buffer_size  = 0;
        }
        else
        {
            if(op_extra_data->input_buffer_size != 0)
842005a0:	61 f0 cf 88 	rMAC = M[r4 + 828];
842005a4:	10 60       	if EQ jump (m) Lc_aec_reference_buffer_details_9;

842005a6 <Lc_aec_reference_buffer_details_6>:
            {
                /* buffer size based on user configuration */
                resp->b.buffer_size = op_extra_data->input_buffer_size;
842005a6:	81 f0 04 8e 	M[r6 + 16] = rMAC;
842005aa:	18 6e       	jump (m) Lc_aec_reference_buffer_details_10;

842005ac <Lc_aec_reference_buffer_details_7>:
inline static bool IsSpeakerTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_SPKR_TERMINAL1)
          || (term_idx==AEC_REF_SPKR_TERMINAL2)
          || ( (term_idx>=AEC_REF_SPKR_TERMINAL3)
              && (term_idx<=AEC_REF_SPKR_TERMINAL8) ) );
842005ac:	78 24       	Null = r5 - 1;
842005ae:	2d 62       	if NE jump (m) Lc_aec_reference_buffer_details_15;

842005b0 <Lc_aec_reference_buffer_details_8>:
    if ( term_id & TERMINAL_SINK_MASK)
    {
        if(IsMicrophoneTerminal(term_id))
        {
            /* override MIC endpoints */
            resp->needs_override = TRUE;
842005b0:	81 f0 08 82 	rMAC = MBU[r6 + 8];
842005b4:	11 ff fb 1f 	rMAC = rMAC AND 0xfffffffb;
842005b8:	c9 c8       	rMAC = rMAC OR 0x4;
842005ba:	81 f0 08 8a 	MB[r6 + 8] = rMAC;
            resp->b.buffer_size  = 0;
842005be:	80 f0 04 8e 	M[r6 + 16] = Null;
842005c2:	21 6e       	jump (m) Lc_aec_reference_buffer_details_14;

842005c4 <Lc_aec_reference_buffer_details_9>:
                /* buffer size based on sample rate. task period + 2ms for safety,
                 * 2ms extra should be enough as assumption is that scheduling jitter
                 * assumed will not be too high.
                 */
                resp->b.buffer_size  =
                    frac_mult(op_extra_data->input_rate,FRACTIONAL(0.002)+op_extra_data->task_period_frac);
842005c4:	62 f0 70 88 	r0 = M[r4 + 448];
842005c8:	61 f0 66 88 	rMAC = M[r4 + 408];
842005cc:	06 f1 13 f0 	r1 = rMAC + 4294967;
842005d0:	37 31 
842005d2:	00 f3 72 c9 	r0 = r0 * r1 (frac);
842005d6:	82 f0 04 8e 	M[r6 + 16] = r0;

842005da <Lc_aec_reference_buffer_details_10>:

#ifdef AEC_REFERENCE_SUPPORT_METADATA
            /* currently metadata is supported only for
             * speaker input channels.
             */
            L3_DBG_MSG("AEC_REFERENCE: metadata is supported for speaker inputs");
842005da:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842005de:	c8 24       	Null = rMAC - 3;
842005e0:	07 68       	if LT jump (m) Lc_aec_reference_buffer_details_12;

842005e2 <Lc_aec_reference_buffer_details_11>:
842005e2:	55 f1 02 f0 	r0 = Null + 357564489;
842005e6:	49 40 
842005e8:	ff fd 03 f0 	call (m) 0xccc;
842005ec:	25 e7 

842005ee <Lc_aec_reference_buffer_details_12>:
            resp->metadata_buffer = op_extra_data->spkr_input_metadata_buffer;
842005ee:	61 f0 c2 88 	rMAC = M[r4 + 776];
842005f2:	81 f0 03 8e 	M[r6 + 12] = rMAC;

842005f6 <Lc_aec_reference_buffer_details_13>:
             */
            if(op_extra_data->mic_metadata_enable &&
               IsMicrophoneOutputTerminal(term_id))
            {
                resp->metadata_buffer = op_extra_data->mic_metadata_buffer;
                resp->supports_metadata = TRUE;
842005f6:	81 f0 08 82 	rMAC = MBU[r6 + 8];
842005fa:	11 ff ef 1f 	rMAC = rMAC AND 0xffffffef;
842005fe:	c9 c9       	rMAC = rMAC OR 0x10;
84200600:	81 f0 08 8a 	MB[r6 + 8] = rMAC;

84200604 <Lc_aec_reference_buffer_details_14>:
            }
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */
        }
    }

    return TRUE;
84200604:	42 20       	r0 = Null + 1;
84200606:	4e 6e       	jump (m) Lc_aec_reference_buffer_details_30;

84200608 <Lc_aec_reference_buffer_details_15>:
84200608:	b8 24       	Null = r5 - 2;
8420060a:	d3 61       	if EQ jump (m) Lc_aec_reference_buffer_details_8;

8420060c <Lc_aec_reference_buffer_details_16>:
8420060c:	f8 25       	Null = r5 - 7;
8420060e:	04 64       	if NC jump (m) Lc_aec_reference_buffer_details_18;

84200610 <Lc_aec_reference_buffer_details_17>:
84200610:	38 27       	Null = r5 - 12;
84200612:	f9 ff 9f ef 	if LS jump (m) Lc_aec_reference_buffer_details_8;

84200616 <Lc_aec_reference_buffer_details_18>:
            resp->needs_override = TRUE;
            resp->b.buffer_size  = 0;
        }
        else
        {
            if(op_extra_data->output_buffer_size != 0)
84200616:	61 f0 ce 88 	rMAC = M[r4 + 824];
8420061a:	14 60       	if EQ jump (m) Lc_aec_reference_buffer_details_21;

8420061c <Lc_aec_reference_buffer_details_19>:
            {
                /* buffer size based on user configuration */
                resp->b.buffer_size = op_extra_data->output_buffer_size;
8420061c:	81 f0 04 8e 	M[r6 + 16] = rMAC;

                if(AEC_REF_REFERENCE_TERMINAL == term_id)
84200620:	38 04       	Null = r5 - Null;
84200622:	26 62       	if NE jump (m) Lc_aec_reference_buffer_details_23;

84200624 <Lc_aec_reference_buffer_details_20>:
                     * within [ref_delay, ref_delay+jitter] range. For that reason we add an extra
                     * for ref buffer so mic output can use full output_buffer_size
                     */
                    unsigned ref_extra =
                        frac_mult(op_extra_data->output_rate,
                                  op_extra_data->task_period_frac + FRACTIONAL(0.001));
84200624:	62 f0 71 88 	r0 = M[r4 + 452];
84200628:	61 f0 66 88 	rMAC = M[r4 + 408];
8420062c:	83 f0 13 f0 	r1 = rMAC + 2147483;
84200630:	9b 28 
84200632:	00 f3 72 c9 	r0 = r0 * r1 (frac);

                    resp->b.buffer_size += ref_extra;
84200636:	81 f0 04 88 	rMAC = M[r6 + 16];
8420063a:	51 00       	rMAC = r0 + rMAC;
8420063c:	81 f0 04 8e 	M[r6 + 16] = rMAC;
84200640:	17 6e       	jump (m) Lc_aec_reference_buffer_details_23;

84200642 <Lc_aec_reference_buffer_details_21>:
                }
            }
            else
            {
                unsigned two_task_period_size = frac_mult(op_extra_data->output_rate,
                                                          2*op_extra_data->task_period_frac) + 1;
84200642:	62 f0 71 88 	r0 = M[r4 + 452];
84200646:	63 f0 66 88 	r1 = M[r4 + 408];
8420064a:	1b 54       	r1 = r1 LSHIFT 1;
8420064c:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84200650:	51 20       	rMAC = r0 + 1;
                /* buffer size based on sample rate */
                resp->b.buffer_size  = frac_mult(op_extra_data->output_rate,FRACTIONAL(0.0087));
84200652:	62 f0 71 88 	r0 = M[r4 + 452];
84200656:	11 f0 83 f6 	r1 = Null + 18683107;
8420065a:	e3 68 
8420065c:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84200660:	82 f0 04 8e 	M[r6 + 16] = r0;
                /* given that this is for cvc-like operators and limited task periods that the
				 * operator supports, 8.7ms would be adequate for all use cases. In case of very
				 * high task period is used make sure output has space for at least two task period.
                 */
                resp->b.buffer_size = MAX(resp->b.buffer_size,
                                          two_task_period_size);
84200664:	50 04       	Null = r0 - rMAC;
84200666:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_buffer_details_23;

8420066a <Lc_aec_reference_buffer_details_22>:
8420066a:	81 f0 04 8e 	M[r6 + 16] = rMAC;

8420066e <Lc_aec_reference_buffer_details_23>:
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
            /* Support metadta for microphone output channels (reference channel not included)
             * if enabled by the user.
             */
            if(op_extra_data->mic_metadata_enable &&
               IsMicrophoneOutputTerminal(term_id))
8420066e:	60 f0 c6 88 	Null = M[r4 + 792];
84200672:	c9 61       	if EQ jump (m) Lc_aec_reference_buffer_details_14;

84200674 <Lc_aec_reference_buffer_details_24>:
{
    return ((AEC_REF_OUTPUT_TERMINAL1 <= term_idx &&
            AEC_REF_OUTPUT_TERMINAL4 >= term_idx) ||
            (AEC_REF_OUTPUT_TERMINAL5 <= term_idx &&
                         AEC_REF_OUTPUT_TERMINAL8 >= term_idx)
            );
84200674:	f8 24       	Null = r5 - 3;
84200676:	c7 65       	if NC jump (m) Lc_aec_reference_buffer_details_14;

84200678 <Lc_aec_reference_buffer_details_25>:
84200678:	b8 25       	Null = r5 - 6;
8420067a:	09 f0 8b e0 	if LS jump (m) Lc_aec_reference_buffer_details_27;

8420067e <Lc_aec_reference_buffer_details_26>:
8420067e:	38 2c       	Null = r5 - 16;
84200680:	f8 ff 85 ef 	if HI jump (m) Lc_aec_reference_buffer_details_14;

84200684 <Lc_aec_reference_buffer_details_27>:
            {
                resp->metadata_buffer = op_extra_data->mic_metadata_buffer;
84200684:	61 f0 c3 88 	rMAC = M[r4 + 780];
84200688:	81 f0 03 8e 	M[r6 + 12] = rMAC;
8420068c:	b5 6f       	jump (m) Lc_aec_reference_buffer_details_13;

8420068e <Lc_aec_reference_buffer_details_28>:

    if(term_idx < AEC_REF_MIC_TERMINAL1)
    {
        return FALSE;
    }
    if(term_idx <= AEC_REF_MIC_TERMINAL4)
8420068e:	48 25       	Null = rMAC - 5;
84200690:	f9 ff a1 ee 	if LS jump (m) Lc_aec_reference_buffer_details_8;

84200694 <Lc_aec_reference_buffer_details_29>:
    {
        return TRUE;
    }
    return (term_idx >= AEC_REF_MIC_TERMINAL5);
84200694:	02 00       	r0 = Null + Null;
84200696:	08 27       	Null = rMAC - 12;
84200698:	22 f0 42 ce 	if C r0 = Null + 1;
    }
    resp = (OP_BUF_DETAILS_RSP*)*response_data;

    if ( term_id & TERMINAL_SINK_MASK)
    {
        if(IsMicrophoneTerminal(term_id))
8420069c:	10 04       	Null = r0 - Null;
8420069e:	89 63       	if NE jump (m) Lc_aec_reference_buffer_details_8;

842006a0 <Lc__ite_16>:
842006a0:	80 6f       	jump (m) Lc_aec_reference_buffer_details_5;

842006a2 <Lc_aec_reference_buffer_details_30>:
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */
        }
    }

    return TRUE;
}
842006a2:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842006a4:	d8 4c       	rts;

842006a6 <$_aec_reference_get_sched_info>:

bool aec_reference_get_sched_info(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842006a6:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842006a8:	12 09       	r8 = r0 + Null;
842006aa:	1e 00       	r4 = r1 + Null;
842006ac:	21 09       	r7 = r2 + Null;
842006ae:	2b 09       	r9 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
842006b0:	ef fd ff ff 	call (m) 0x4e6;
842006b4:	37 e1 
842006b6:	10 09       	r6 = r0 + Null;

bool aec_reference_get_sched_info(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    OP_SCHED_INFO_RSP* resp;
    unsigned terminal_id = OPMGR_GET_OP_SCHED_INFO_TERMINAL_ID(message_data);
842006b8:	37 e8       	r5 = M[r4 + Null];

    patch_fn_shared(aec_reference);

    resp = base_op_get_sched_info_ex(op_data, message_data, response_id);
842006ba:	4c 08       	r2 = r7 + Null;
842006bc:	33 00       	r1 = r4 + Null;
842006be:	52 08       	r0 = r8 + Null;
842006c0:	ef fd fe ff 	call (m) 0x41c;
842006c4:	3d ea 
842006c6:	16 00       	r4 = r0 + Null;
    if (resp == NULL)
842006c8:	09 62       	if NE jump (m) Lc_aec_reference_get_sched_info_3;

842006ca <Lc_aec_reference_get_sched_info_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
842006ca:	03 f0 00 60 	r1 = Null + 4096;
842006ce:	5c 08       	r2 = r9 + Null;
842006d0:	52 08       	r0 = r8 + Null;
842006d2:	ef fd fe ff 	call (m) 0x4bc;
842006d6:	2b ef 
842006d8:	34 6e       	jump (m) Lc_aec_reference_get_sched_info_15;

842006da <Lc_aec_reference_get_sched_info_3>:
    }
    *response_data = resp;
842006da:	b6 f0 00 ee 	M[r9 + Null] = r4;

    /* block_size set to 1 if ep marked as "real", else it can be any arbitrary
     * value so simplifying the code by choosing 1. */
    resp->block_size = 1;
842006de:	41 20       	rMAC = Null + 1;
842006e0:	b1 8e       	M[r4 + 8] = rMAC;

    /* The real endpoints are locally clocked if the respective overridden
     * endpoint is locally clocked. */
    if ((terminal_id & TERMINAL_SINK_MASK) && !IsMicrophoneTerminal(terminal_id))
842006e2:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
842006e6:	00 00 
842006e8:	0e 60       	if EQ jump (m) Lc_aec_reference_get_sched_info_6;

842006ea <Lc_aec_reference_get_sched_info_4>:
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
}
inline static bool IsMicrophoneTerminal(unsigned term_idx)
{
    term_idx &= ~TERMINAL_SINK_MASK;
842006ea:	bf ff 71 ff 	rMAC = r5 AND 0xff7fffff;
842006ee:	ff 1f 

    if(term_idx < AEC_REF_MIC_TERMINAL1)
842006f0:	88 24       	Null = rMAC - 2;
842006f2:	02 f0 9f e0 	if C jump (m) Lc_aec_reference_get_sched_info_9;

842006f6 <Lc_aec_reference_get_sched_info_5>:
    {
        resp->locally_clocked = opmgr_override_is_locally_clocked(op_extra_data->spkr_endpoint);
842006f6:	82 f0 a3 88 	r0 = M[r6 + 652];
842006fa:	ff fd 26 f0 	call (m) 0x5496;
842006fe:	3d ec 
84200700:	32 8f       	M[r4 + 16] = r0;
84200702:	05 6e       	jump (m) Lc_aec_reference_get_sched_info_8;

84200704 <Lc_aec_reference_get_sched_info_6>:
inline static bool IsSpeakerTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_SPKR_TERMINAL1)
          || (term_idx==AEC_REF_SPKR_TERMINAL2)
          || ( (term_idx>=AEC_REF_SPKR_TERMINAL3)
              && (term_idx<=AEC_REF_SPKR_TERMINAL8) ) );
84200704:	78 24       	Null = r5 - 1;
84200706:	0f 62       	if NE jump (m) Lc_aec_reference_get_sched_info_11;

84200708 <Lc_aec_reference_get_sched_info_7>:
    {
        resp->locally_clocked = opmgr_override_is_locally_clocked(op_extra_data->mic_endpoint);
    }
    else
    {
        resp->locally_clocked = TRUE;
84200708:	41 20       	rMAC = Null + 1;
8420070a:	31 8f       	M[r4 + 16] = rMAC;

8420070c <Lc_aec_reference_get_sched_info_8>:
    }

    return TRUE;
8420070c:	42 20       	r0 = Null + 1;
8420070e:	19 6e       	jump (m) Lc_aec_reference_get_sched_info_15;

84200710 <Lc_aec_reference_get_sched_info_9>:

    if(term_idx < AEC_REF_MIC_TERMINAL1)
    {
        return FALSE;
    }
    if(term_idx <= AEC_REF_MIC_TERMINAL4)
84200710:	48 25       	Null = rMAC - 5;
84200712:	f9 ff f7 ef 	if LS jump (m) Lc_aec_reference_get_sched_info_7;

84200716 <Lc_aec_reference_get_sched_info_10>:
    {
        return TRUE;
    }
    return (term_idx >= AEC_REF_MIC_TERMINAL5);
84200716:	02 00       	r0 = Null + Null;
84200718:	08 27       	Null = rMAC - 12;
8420071a:	22 f0 42 ce 	if C r0 = Null + 1;
     * value so simplifying the code by choosing 1. */
    resp->block_size = 1;

    /* The real endpoints are locally clocked if the respective overridden
     * endpoint is locally clocked. */
    if ((terminal_id & TERMINAL_SINK_MASK) && !IsMicrophoneTerminal(terminal_id))
8420071e:	10 04       	Null = r0 - Null;
84200720:	f4 63       	if NE jump (m) Lc_aec_reference_get_sched_info_7;

84200722 <Lc__ite_17>:
84200722:	ea 6f       	jump (m) Lc_aec_reference_get_sched_info_5;

84200724 <Lc_aec_reference_get_sched_info_11>:
inline static bool IsSpeakerTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_SPKR_TERMINAL1)
          || (term_idx==AEC_REF_SPKR_TERMINAL2)
          || ( (term_idx>=AEC_REF_SPKR_TERMINAL3)
              && (term_idx<=AEC_REF_SPKR_TERMINAL8) ) );
84200724:	b8 24       	Null = r5 - 2;
84200726:	f1 61       	if EQ jump (m) Lc_aec_reference_get_sched_info_7;

84200728 <Lc_aec_reference_get_sched_info_12>:
84200728:	f8 25       	Null = r5 - 7;
8420072a:	04 64       	if NC jump (m) Lc_aec_reference_get_sched_info_14;

8420072c <Lc_aec_reference_get_sched_info_13>:
8420072c:	38 27       	Null = r5 - 12;
8420072e:	f9 ff db ef 	if LS jump (m) Lc_aec_reference_get_sched_info_7;

84200732 <Lc_aec_reference_get_sched_info_14>:
    {
        resp->locally_clocked = opmgr_override_is_locally_clocked(op_extra_data->spkr_endpoint);
    }
    else if (((terminal_id & TERMINAL_SINK_MASK) == 0) && !IsSpeakerTerminal(terminal_id))
    {
        resp->locally_clocked = opmgr_override_is_locally_clocked(op_extra_data->mic_endpoint);
84200732:	82 f0 a2 88 	r0 = M[r6 + 648];
84200736:	ff fd 26 f0 	call (m) 0x5496;
8420073a:	21 eb 
8420073c:	32 8f       	M[r4 + 16] = r0;
8420073e:	e7 6f       	jump (m) Lc_aec_reference_get_sched_info_8;

84200740 <Lc_aec_reference_get_sched_info_15>:
    {
        resp->locally_clocked = TRUE;
    }

    return TRUE;
}
84200740:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200742:	d8 4c       	rts;

84200744 <$_aec_reference_timer_task>:
{
    patch_fn_shared(aec_reference);
}

void aec_reference_timer_task(void *kick_object)
{
84200744:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200746:	13 09       	r9 = r0 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84200748:	ef fd fe ff 	call (m) 0x4e6;
8420074c:	3f ec 
8420074e:	16 00       	r4 = r0 + Null;
void aec_reference_timer_task(void *kick_object)
{
    OPERATOR_DATA         *op_data = (OPERATOR_DATA*) kick_object;
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    TIME next_fire_time;
    unsigned                 sink_kicks=0,source_kicks=0;
84200750:	40 de       	M[FP + 32] = Null;
84200752:	48 de       	M[FP + 36] = Null;

    base_op_profiler_start(op_data);
84200754:	5a 08       	r0 = r9 + Null;
84200756:	ef fd fe ff 	call (m) 0x51e;
8420075a:	29 ee 

    patch_fn_shared(aec_reference_run);

    if(op_extra_data->ReInitFlag==TRUE)
8420075c:	61 f0 5d 88 	rMAC = M[r4 + 372];
84200760:	48 24       	Null = rMAC - 1;
84200762:	14 62       	if NE jump (m) Lc_aec_reference_timer_task_7;

84200764 <Lc_aec_reference_timer_task_2>:
    {
        op_extra_data->ReInitFlag=FALSE;
84200764:	60 f0 5d 8e 	M[r4 + 372] = Null;

        /* Handle Reinitialize */
        if(op_extra_data->mic_sidetone_op)
84200768:	62 f0 77 88 	r0 = M[r4 + 476];
8420076c:	05 60       	if EQ jump (m) Lc_aec_reference_timer_task_4;

8420076e <Lc_aec_reference_timer_task_3>:
        {
            initialize_sidetone_filter_op(op_extra_data->mic_sidetone_op);
8420076e:	ff fd 1b f4 	call 0x83e74;
84200772:	26 e8 
84200774:	08 6e       	jump (m) Lc_aec_reference_timer_task_6;

84200776 <Lc_aec_reference_timer_task_4>:
        }
        else if(op_extra_data->sidetone_method == AEC_SIDETONE_IN_HW)
84200776:	61 f0 bc 81 	rMAC = MBS[r4 + 444];
8420077a:	48 24       	Null = rMAC - 1;
8420077c:	04 62       	if NE jump (m) Lc_aec_reference_timer_task_6;

8420077e <Lc_aec_reference_timer_task_5>:
        {
            aec_reference_init_hw_sidetone(op_extra_data);
8420077e:	32 00       	r0 = r4 + Null;
84200780:	10 f0 23 e1 	call (m) $_aec_reference_init_hw_sidetone;

84200784 <Lc_aec_reference_timer_task_6>:
        }

        aec_reference_set_mic_gains(op_data);
84200784:	5a 08       	r0 = r9 + Null;
84200786:	06 f0 29 ee 	call (m) $_aec_reference_set_mic_gains;

8420078a <Lc_aec_reference_timer_task_7>:
    }

    if(op_extra_data->mic_sidetone_op)
8420078a:	62 f0 77 88 	r0 = M[r4 + 476];
8420078e:	0b 60       	if EQ jump (m) Lc_aec_reference_timer_task_9;

84200790 <Lc_aec_reference_timer_task_8>:
    {
        update_sidetone_filter_op(op_extra_data->mic_sidetone_op,
                                  op_extra_data->params.OFFSET_CONFIG & AEC_REFERENCE_CONFIG_SIDETONEENA,
                                  op_extra_data->shared_volume_ptr->ndvc_filter_sum_lpdnz);
84200790:	61 f0 59 88 	rMAC = M[r4 + 356];
84200794:	4c 88       	r2 = M[rMAC + 4];
84200796:	61 f0 34 88 	rMAC = M[r4 + 208];
8420079a:	cb c1       	r1 = rMAC AND 0x10;
8420079c:	ff fd 1b f4 	call 0x83e1c;
842007a0:	20 e4 
842007a2:	08 6e       	jump (m) Lc_aec_reference_timer_task_11;

842007a4 <Lc_aec_reference_timer_task_9>:
    }
    else if(op_extra_data->sidetone_method == AEC_SIDETONE_IN_HW)
842007a4:	61 f0 bc 81 	rMAC = MBS[r4 + 444];
842007a8:	48 24       	Null = rMAC - 1;
842007aa:	04 62       	if NE jump (m) Lc_aec_reference_timer_task_11;

842007ac <Lc_aec_reference_timer_task_10>:
    {
       aec_reference_update_hw_sidetone(op_extra_data);
842007ac:	32 00       	r0 = r4 + Null;
842007ae:	0f f0 37 ef 	call (m) $_aec_reference_update_hw_sidetone;

842007b2 <Lc_aec_reference_timer_task_11>:
        */
       && (0 != (op_extra_data->params.OFFSET_CONFIG & AEC_REFERENCE_CONFIG_SIDETONEENA))
       /* Also check that both speaker and mic still connected */
       && (NULL != op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
       && (NULL != op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1])
       )
842007b2:	62 f0 6c 88 	r0 = M[r4 + 432];
842007b6:	0e 60       	if EQ jump (m) Lc_aec_reference_timer_task_16;

842007b8 <Lc_aec_reference_timer_task_12>:
842007b8:	61 f0 34 88 	rMAC = M[r4 + 208];
842007bc:	c9 c1       	rMAC = rMAC AND 0x10;
842007be:	0a 60       	if EQ jump (m) Lc_aec_reference_timer_task_16;

842007c0 <Lc_aec_reference_timer_task_13>:
842007c0:	71 a8       	rMAC = M[r4 + 68];
842007c2:	08 60       	if EQ jump (m) Lc_aec_reference_timer_task_16;

842007c4 <Lc_aec_reference_timer_task_14>:
842007c4:	b1 88       	rMAC = M[r4 + 8];
842007c6:	06 60       	if EQ jump (m) Lc_aec_reference_timer_task_16;

842007c8 <Lc_aec_reference_timer_task_15>:
    {
        /* Run sidetone graph */
        cbops_process_data(op_extra_data->sidetone_graph, CBOPS_MAX_COPY_SIZE-1);
842007c8:	03 f0 7f 4b 	r1 = Null + 1919;
842007cc:	ff fd a5 f3 	call 0x752f0;
842007d0:	24 e9 

842007d2 <Lc_aec_reference_timer_task_16>:
    }

    op_extra_data->task_decim_counter++;
842007d2:	61 f0 6b 88 	rMAC = M[r4 + 428];
842007d6:	49 20       	rMAC = rMAC + 1;
842007d8:	61 f0 6b 8e 	M[r4 + 428] = rMAC;
    if(op_extra_data->task_decim_counter >= op_extra_data->task_decim_factor)
842007dc:	62 f0 6a 88 	r0 = M[r4 + 424];
842007e0:	88 04       	Null = rMAC - r0;
842007e2:	03 64       	if NC jump (m) Lc_aec_reference_timer_task_18;

842007e4 <Lc_aec_reference_timer_task_17>:
    {
        op_extra_data->task_decim_counter = 0;
842007e4:	60 f0 6b 8e 	M[r4 + 428] = Null;

842007e8 <Lc_aec_reference_timer_task_18>:
    }
    if(op_extra_data->task_decim_counter == 0)
842007e8:	60 f0 6b 88 	Null = M[r4 + 428];
842007ec:	01 f0 d9 e4 	if NE jump (m) Lc_aec_reference_timer_task_78;

842007f0 <Lc_aec_reference_timer_task_19>:
    {
        /* Process the speaker path if we have speaker graph and
         * speaker is still connected
         */
        bool spkr_graph_active = (NULL != op_extra_data->spkr_graph) &&
            (NULL != op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1]);
842007f0:	61 f0 7f 88 	rMAC = M[r4 + 508];
842007f4:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_21;

842007f6 <Lc_aec_reference_timer_task_20>:
842007f6:	72 a8       	r0 = M[r4 + 68];
842007f8:	01 00       	rMAC = Null + Null;
842007fa:	80 04       	Null = Null - r0;
842007fc:	21 f0 41 ce 	if NE rMAC = Null + 1;
84200800:	02 6e       	jump (m) Lc_aec_reference_timer_task_22;

84200802 <Lc_aec_reference_timer_task_21>:
84200802:	01 00       	rMAC = Null + Null;

84200804 <Lc_aec_reference_timer_task_22>:
84200804:	51 de       	M[FP + 40] = rMAC;

        /* Process the mic path if we have mic graph and
         * mic is still connected
         */
        bool mic_graph_active = (NULL != op_extra_data->mic_graph) &&
            (NULL != op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1]);
84200806:	61 f0 75 88 	rMAC = M[r4 + 468];
8420080a:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_24;

8420080c <Lc_aec_reference_timer_task_23>:
8420080c:	b1 88       	rMAC = M[r4 + 8];
8420080e:	07 00       	r5 = Null + Null;
84200810:	40 04       	Null = Null - rMAC;
84200812:	21 f0 47 ce 	if NE r5 = Null + 1;
84200816:	02 6e       	jump (m) Lc_aec_reference_timer_task_25;

84200818 <Lc_aec_reference_timer_task_24>:
84200818:	07 00       	r5 = Null + Null;

8420081a <Lc_aec_reference_timer_task_25>:
         * 1- we have a rate monitor op for speaker, and/or
         * 2- speaker hasn't started consuming (to detect start of flow)
         */
        if(spkr_graph_active &&
           (op_extra_data->spkr_rate_monitor_op != NULL ||
            !op_extra_data->spkr_flow_started))
8420081a:	51 d8       	rMAC = M[FP + 40];
8420081c:	1a 60       	if EQ jump (m) Lc_aec_reference_timer_task_30;

8420081e <Lc_aec_reference_timer_task_26>:
8420081e:	61 f0 80 88 	rMAC = M[r4 + 512];
84200822:	04 62       	if NE jump (m) Lc_aec_reference_timer_task_28;

84200824 <Lc_aec_reference_timer_task_27>:
84200824:	60 f0 cc 88 	Null = M[r4 + 816];
84200828:	14 62       	if NE jump (m) Lc_aec_reference_timer_task_30;

8420082a <Lc_aec_reference_timer_task_28>:
             */
                op_extra_data->spkr_new_amount =
                     cbuffer_calc_new_amount(
                         op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1],
                         &op_extra_data->spkr_last_address,
                         TRUE /* This is an output buffer */);
8420082a:	44 20       	r2 = Null + 1;
8420082c:	63 f0 28 23 	r1 = r4 + 808;
84200830:	72 a8       	r0 = M[r4 + 68];
84200832:	ff fd cd f1 	call (m) 0x3a35a;
84200836:	29 e9 
84200838:	62 f0 cb 8e 	M[r4 + 812] = r0;

            /* Set a flag showing that speaker output has started consuming samples. */
            if(!op_extra_data->spkr_flow_started)
8420083c:	60 f0 cc 88 	Null = M[r4 + 816];
84200840:	08 62       	if NE jump (m) Lc_aec_reference_timer_task_30;

84200842 <Lc_aec_reference_timer_task_29>:
            {
                op_extra_data->spkr_flow_started = op_extra_data->spkr_new_amount != 0;
84200842:	01 00       	rMAC = Null + Null;
84200844:	60 f0 cb 88 	Null = M[r4 + 812];
84200848:	21 f0 41 ce 	if NE rMAC = Null + 1;
8420084c:	61 f0 cc 8e 	M[r4 + 816] = rMAC;

84200850 <Lc_aec_reference_timer_task_30>:
            }
        }
#endif /* AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT */

        /*  - Run MIC cbops */
        if(mic_graph_active)
84200850:	38 04       	Null = r5 - Null;
84200852:	89 60       	if EQ jump (m) Lc_aec_reference_timer_task_58;

84200854 <Lc_aec_reference_timer_task_31>:
        {
            if(op_extra_data->spkr_ref_active
               || op_extra_data->mic_sync_enable)
84200854:	60 f0 87 88 	Null = M[r4 + 540];
84200858:	04 62       	if NE jump (m) Lc_aec_reference_timer_task_33;

8420085a <Lc_aec_reference_timer_task_32>:
8420085a:	60 f0 cd 88 	Null = M[r4 + 820];
8420085e:	04 60       	if EQ jump (m) Lc_aec_reference_timer_task_34;

84200860 <Lc_aec_reference_timer_task_33>:
            {
                /* keep REFERENCE path and MIC output synchronised */
                aec_reference_update_mic_reference_sync(op_extra_data);
84200860:	32 00       	r0 = r4 + Null;
84200862:	0e f0 3b ee 	call (m) $_aec_reference_update_mic_reference_sync;

84200866 <Lc_aec_reference_timer_task_34>:
            }

            if(!op_extra_data->mic_graph_no_output)
84200866:	60 f0 db 88 	Null = M[r4 + 876];
8420086a:	76 62       	if NE jump (m) Lc_aec_reference_timer_task_57;

8420086c <Lc_aec_reference_timer_task_35>:
            {
                /* Mic graph with output */
                unsigned b4_space = 0;
                unsigned after_space;
                unsigned amount_produced;
                tCbuffer *mic_buf = op_extra_data->output_stream[AEC_REF_OUTPUT_TERMINAL1];
8420086c:	68 f0 13 88 	r6 = M[r4 + 76];
                b4_space = cbuffer_calc_amount_space_in_words(mic_buf);
84200870:	42 08       	r0 = r6 + Null;
84200872:	ff fd ca f1 	call (m) 0x39d88;
84200876:	37 e8 
84200878:	17 00       	r5 = r0 + Null;
                cbops_process_data(op_extra_data->mic_graph, CBOPS_MAX_COPY_SIZE-1);
8420087a:	03 f0 7f 4b 	r1 = Null + 1919;
8420087e:	62 f0 75 88 	r0 = M[r4 + 468];
84200882:	ff fd a5 f3 	call 0x752f0;
84200886:	2e e3 
                after_space = cbuffer_calc_amount_space_in_words(mic_buf);
84200888:	42 08       	r0 = r6 + Null;
8420088a:	ff fd ca f1 	call (m) 0x39d88;
8420088e:	3f e7 

                /* Don't tolerate cbops writing more than available space */
                PL_ASSERT(b4_space >= after_space);
84200890:	b8 04       	Null = r5 - r0;
84200892:	02 f0 95 e0 	if C jump (m) Lc_aec_reference_timer_task_37;

84200896 <Lc_aec_reference_timer_task_36>:
84200896:	03 f0 25 60 	r1 = Null + 4133;
8420089a:	02 f0 13 60 	r0 = Null + 4115;
8420089e:	ff fd b3 f0 	call (m) 0x16ff0;
842008a2:	33 ea 
842008a4:	eb 6e       	jump (m) Lc_aec_reference_timer_task_80;

842008a6 <Lc_aec_reference_timer_task_37>:
                amount_produced = b4_space - after_space;
842008a6:	2f f7 0a c2 	r8 = r5 - r0;

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
                if(op_extra_data->mic_metadata_buffer!= NULL
                   && buff_has_metadata(op_extra_data->mic_metadata_buffer))
842008aa:	61 f0 c3 88 	rMAC = M[r4 + 780];
842008ae:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_40;

842008b0 <Lc_aec_reference_timer_task_38>:
842008b0:	89 89       	rMAC = M[rMAC + 24];
842008b2:	05 60       	if EQ jump (m) Lc_aec_reference_timer_task_40;

842008b4 <Lc_aec_reference_timer_task_39>:
                {
                    aec_reference_mic_generate_metadata_with_ttp(op_extra_data, b4_space - after_space);
842008b4:	53 08       	r1 = r8 + Null;
842008b6:	32 00       	r0 = r4 + Null;
842008b8:	05 f0 33 ed 	call (m) $_aec_reference_mic_generate_metadata_with_ttp;

842008bc <Lc_aec_reference_timer_task_40>:
                   !op_extra_data->spkr_flow_started
#else
                   /* insert silence until speaker graph hasn't started */
                   !op_extra_data->spkr_ref_active
#endif
                   )
842008bc:	31 a8       	rMAC = M[r4 + 64];
842008be:	53 60       	if EQ jump (m) Lc_aec_reference_timer_task_58;

842008c0 <Lc_aec_reference_timer_task_41>:
842008c0:	60 f0 cc 88 	Null = M[r4 + 816];
842008c4:	50 62       	if NE jump (m) Lc_aec_reference_timer_task_58;

842008c6 <Lc_aec_reference_timer_task_42>:
                     * Note: The synchronisation is normally done by the speaker latency operator
                     * however we don't have a running speaker graph at this situation, so is done
                     * manually here.
                     */

                    unsigned mic_out_data = cbuffer_calc_amount_data_in_words(mic_buf);
842008c6:	42 08       	r0 = r6 + Null;
842008c8:	ff fd ca f1 	call (m) 0x39dd4;
842008cc:	2d e8 
842008ce:	17 00       	r5 = r0 + Null;
                    /* if we have more than one mic, get max amount amnong all */
                    unsigned idx;
                    for(idx = 1; idx < op_extra_data->num_mic_channels; ++idx)
842008d0:	08 71       	r6 = Null + 1;
842008d2:	0f 6e       	jump (m) Lc_aec_reference_timer_task_48;

842008d4 <Lc_aec_reference_timer_task_43>:
                    {
                        tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
842008d4:	82 f0 09 20 	r0 = r6 + 9;

842008d8 <Lc_aec_reference_timer_task_44>:
842008d8:	61 f0 40 20 	rMAC = r4 + 64;
842008dc:	52 54       	r0 = r0 LSHIFT 2;
                        if(NULL != out_buf)
842008de:	8a e8       	r0 = M[rMAC + r0];
842008e0:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_47;

842008e2 <Lc_aec_reference_timer_task_45>:
                        {
                            unsigned out_data = cbuffer_calc_amount_data_in_words(out_buf);
842008e2:	ff fd ca f1 	call (m) 0x39dd4;
842008e6:	33 e7 
                            mic_out_data = MAX(out_data, mic_out_data);
842008e8:	d0 05       	Null = r0 - r5;
842008ea:	02 64       	if NC jump (m) Lc_aec_reference_timer_task_47;

842008ec <Lc_aec_reference_timer_task_46>:
842008ec:	17 00       	r5 = r0 + Null;

842008ee <Lc_aec_reference_timer_task_47>:
                     */

                    unsigned mic_out_data = cbuffer_calc_amount_data_in_words(mic_buf);
                    /* if we have more than one mic, get max amount amnong all */
                    unsigned idx;
                    for(idx = 1; idx < op_extra_data->num_mic_channels; ++idx)
842008ee:	08 75       	r6 = r6 + 1;

842008f0 <Lc_aec_reference_timer_task_48>:
842008f0:	61 f0 85 88 	rMAC = M[r4 + 532];
842008f4:	1f f8 00 c2 	Null = r6 - rMAC;
842008f8:	02 f0 91 e0 	if C jump (m) Lc_aec_reference_timer_task_51;

842008fc <Lc_aec_reference_timer_task_49>:
                    {
                        tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
842008fc:	80 f0 02 24 	Null = r6 - 2;
84200900:	f2 ff d5 ef 	if C jump (m) Lc_aec_reference_timer_task_43;

84200904 <Lc_aec_reference_timer_task_50>:
84200904:	02 21       	r0 = Null + 4;
84200906:	e9 6f       	jump (m) Lc_aec_reference_timer_task_44;

84200908 <Lc_aec_reference_timer_task_51>:
                        {
                            unsigned out_data = cbuffer_calc_amount_data_in_words(out_buf);
                            mic_out_data = MAX(out_data, mic_out_data);
                        }
                    }
                    tCbuffer *ref_buf = op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL];
84200908:	68 f0 10 88 	r6 = M[r4 + 64];
                    unsigned ref_data = cbuffer_calc_amount_data_in_words(ref_buf);
8420090c:	42 08       	r0 = r6 + Null;
8420090e:	ff fd ca f1 	call (m) 0x39dd4;
84200912:	27 e6 
84200914:	11 09       	r7 = r0 + Null;
                    unsigned ideal_amount = mic_out_data +
                        op_extra_data->sync_block.ref_delay +
                        (op_extra_data->sync_block.jitter/2);
84200916:	62 f0 ab 88 	r0 = M[r4 + 684];
8420091a:	61 f0 b0 88 	rMAC = M[r4 + 704];
8420091e:	12 50       	r0 = r0 LSHIFT -1;
84200920:	51 00       	rMAC = r0 + rMAC;
84200922:	cf 01       	r5 = rMAC + r5;
                    /* We only insert, dropping is done via waiting for mic buffer to fill up */
                    unsigned amount_to_insert = 0;
                    if(ideal_amount > ref_data)
84200924:	9f f7 00 c2 	Null = r5 - r7;
84200928:	09 f0 bd e0 	if LS jump (m) Lc_aec_reference_timer_task_58;

8420092c <Lc_aec_reference_timer_task_52>:
                    {
                        unsigned ref_space = cbuffer_calc_amount_space_in_words(ref_buf);
8420092c:	42 08       	r0 = r6 + Null;
8420092e:	ff fd ca f1 	call (m) 0x39d88;
84200932:	3b e2 
                        amount_to_insert = ideal_amount - ref_data;
84200934:	9f f7 03 c2 	r1 = r5 - r7;
                         * Note: limit to amount_produced*3/2, since we own only the write
                         * side of the buffer, although the read sides are syncronised by
                         * consumer but there is a chance the this operator preempt the consumer
                         * right at the middle of read pointer update. For that reason we apply this limit
                         */
                        amount_to_insert = MIN(amount_to_insert, amount_produced*3/2);
84200938:	01 fa 94 d9 	r2 = r8 * 3 (int);
8420093c:	24 50       	r2 = r2 LSHIFT -1;
8420093e:	18 05       	Null = r1 - r2;
84200940:	02 64       	if NC jump (m) Lc_aec_reference_timer_task_54;

84200942 <Lc_aec_reference_timer_task_53>:
84200942:	23 00       	r1 = r2 + Null;

84200944 <Lc_aec_reference_timer_task_54>:
                        amount_to_insert = MIN(amount_to_insert, ref_space);
84200944:	98 04       	Null = r1 - r0;
84200946:	02 64       	if NC jump (m) Lc_aec_reference_timer_task_56;

84200948 <Lc_aec_reference_timer_task_55>:
84200948:	13 00       	r1 = r0 + Null;

8420094a <Lc_aec_reference_timer_task_56>:

                        /* insert silence */
                        cbuffer_block_fill(ref_buf, amount_to_insert, 0);
8420094a:	04 00       	r2 = Null + Null;
8420094c:	42 08       	r0 = r6 + Null;
8420094e:	ff fd ca f1 	call (m) 0x39ea6;
84200952:	39 ea 
84200954:	08 6e       	jump (m) Lc_aec_reference_timer_task_58;

84200956 <Lc_aec_reference_timer_task_57>:
                }
            }
            else /* if(!op_extra_data->mic_graph_no_output) */
            {
                /* run cbops process for mic graph without output */
                cbops_process_data(op_extra_data->mic_graph, CBOPS_MAX_COPY_SIZE-1);
84200956:	03 f0 7f 4b 	r1 = Null + 1919;
8420095a:	62 f0 75 88 	r0 = M[r4 + 468];
8420095e:	ff fd a4 f3 	call 0x752f0;
84200962:	32 ec 

84200964 <Lc_aec_reference_timer_task_58>:
            }
        }

        /*  - Run SPKR cbops */
        if(spkr_graph_active)
84200964:	51 d8       	rMAC = M[FP + 40];
84200966:	51 60       	if EQ jump (m) Lc_aec_reference_timer_task_71;

84200968 <Lc_aec_reference_timer_task_59>:
        {
#ifdef AEC_REFERENCE_SUPPORT_METADATA
            unsigned max_to_process = CBOPS_MAX_COPY_SIZE-1;
84200968:	01 f0 7f 4b 	rMAC = Null + 1919;
8420096c:	59 de       	M[FP + 44] = rMAC;
            tCbuffer *met_buf = op_extra_data->spkr_input_metadata_buffer;
            unsigned before_amount = 0;
8420096e:	00 09       	r6 = Null + Null;
            if(met_buf!= NULL && buff_has_metadata(met_buf))
84200970:	67 f0 c2 88 	r5 = M[r4 + 776];
84200974:	18 60       	if EQ jump (m) Lc_aec_reference_timer_task_64;

84200976 <Lc_aec_reference_timer_task_60>:
84200976:	b9 89       	rMAC = M[r5 + 24];
84200978:	1f 60       	if EQ jump (m) Lc_aec_reference_timer_task_65;

8420097a <Lc_aec_reference_timer_task_61>:
            {
                /* amount of metadata available */
                unsigned meta_data_available = buff_metadata_available_octets(met_buf)/OCTETS_PER_SAMPLE;
8420097a:	3a 00       	r0 = r5 + Null;
8420097c:	ff fd 9f f0 	call (m) 0x14958;
84200980:	3d ee 
84200982:	7f f2 d9 c8 	r7 = r0 LSHIFT -2;

                /* get amount in the buffer before running cbops */
                before_amount = cbuffer_calc_amount_data_in_words(met_buf);
84200986:	3a 00       	r0 = r5 + Null;
84200988:	ff fd ca f1 	call (m) 0x39dd4;
8420098c:	2d e2 
8420098e:	10 09       	r6 = r0 + Null;

                /* if we have metadata enabled then limit the amount to
                 * process to the amount of available metadata
                 */
                max_to_process = MIN(max_to_process, meta_data_available);
84200990:	59 d8       	rMAC = M[FP + 44];
84200992:	9f f1 00 c2 	Null = rMAC - r7;
84200996:	03 64       	if NC jump (m) Lc_aec_reference_timer_task_63;

84200998 <Lc_aec_reference_timer_task_62>:
84200998:	e9 f0 0b 8e 	M[FP + 44] = r7;

8420099c <Lc_aec_reference_timer_task_63>:
#ifdef AEC_REFERENCE_SPKR_TTP
                /* Run TTP error control for speaker graph */
                aec_reference_spkr_ttp_run(op_extra_data, &max_to_process);
8420099c:	c3 12       	r1 = FP + 44;
8420099e:	32 00       	r0 = r4 + Null;
842009a0:	11 f0 23 ec 	call (m) $_aec_reference_spkr_ttp_run;

842009a4 <Lc_aec_reference_timer_task_64>:
#endif
            }

            /* run cbops process */
            cbops_process_data(op_extra_data->spkr_graph, max_to_process);
842009a4:	5b d8       	r1 = M[FP + 44];
842009a6:	62 f0 7f 88 	r0 = M[r4 + 508];
842009aa:	ff fd a4 f3 	call 0x752f0;
842009ae:	26 ea 

            if(met_buf!= NULL && buff_has_metadata(met_buf))
842009b0:	38 04       	Null = r5 - Null;
842009b2:	09 62       	if NE jump (m) Lc_aec_reference_timer_task_66;

842009b4 <Lc__ite_18>:
842009b4:	26 6e       	jump (m) Lc_aec_reference_timer_task_70;

842009b6 <Lc_aec_reference_timer_task_65>:
                aec_reference_spkr_ttp_run(op_extra_data, &max_to_process);
#endif
            }

            /* run cbops process */
            cbops_process_data(op_extra_data->spkr_graph, max_to_process);
842009b6:	03 f0 7f 4b 	r1 = Null + 1919;
842009ba:	62 f0 7f 88 	r0 = M[r4 + 508];
842009be:	ff fd a4 f3 	call 0x752f0;
842009c2:	32 e9 

842009c4 <Lc_aec_reference_timer_task_66>:
842009c4:	b9 89       	rMAC = M[r5 + 24];
842009c6:	1d 60       	if EQ jump (m) Lc_aec_reference_timer_task_70;

842009c8 <Lc_aec_reference_timer_task_67>:
                 * The assumption is that the write pointer of
                 * input buffer isn't changed during cbops
                 * process.
                 */
                unsigned amount_processed;
                unsigned after_amount = cbuffer_calc_amount_data_in_words(met_buf);
842009c8:	3a 00       	r0 = r5 + Null;
842009ca:	ff fd ca f1 	call (m) 0x39dd4;
842009ce:	2b e0 
#ifdef TODO_AEC_REFERENCE_TTP
                /* for the moment don't tolerate cbops doing anything wrong */
                PL_ASSERT(after_amount <= before_amount);
842009d0:	8f f2 00 c2 	Null = r0 - r6;
842009d4:	08 f0 99 e1 	if HI jump (m) Lc_aec_reference_timer_task_79;

842009d8 <Lc_aec_reference_timer_task_68>:
                amount_processed = before_amount - after_amount;
842009d8:	00 f2 38 c2 	r6 = r6 - r0;
                     */
                    unsigned buff_size = cbuffer_get_size_in_words(met_buf);
                    amount_processed = buff_size + before_amount - after_amount;
                }
#endif /* TODO_AEC_REFERENCE_TTP */
                if(amount_processed > 0)
842009dc:	0f f8 00 c2 	Null = r6 - Null;
842009e0:	10 60       	if EQ jump (m) Lc_aec_reference_timer_task_70;

842009e2 <Lc_aec_reference_timer_task_69>:
                {
                    /* delete metadata tags for consumed input */
                    unsigned b4idx, afteridx;
                    buff_metadata_tag_list_delete(
                        buff_metadata_remove(met_buf, OCTETS_PER_SAMPLE * amount_processed, &b4idx, &afteridx));
842009e2:	45 13       	r3 = FP + 52;
842009e4:	04 13       	r2 = FP + 48;
842009e6:	01 f8 d3 c8 	r1 = r6 LSHIFT 2;
842009ea:	3a 00       	r0 = r5 + Null;
842009ec:	ff fd 9f f0 	call (m) 0x149ca;
842009f0:	3f ee 
842009f2:	ff fd 9d f0 	call (m) 0x145ee;
842009f6:	3d ef 
                    /* update timestamp */
                    aec_reference_spkr_ttp_update_last_timestamp(op_extra_data, amount_processed);
842009f8:	43 08       	r1 = r6 + Null;
842009fa:	32 00       	r0 = r4 + Null;
842009fc:	12 f0 23 e2 	call (m) $_aec_reference_spkr_ttp_update_last_timestamp;

84200a00 <Lc_aec_reference_timer_task_70>:
                }
            }
#else /* AEC_REFERENCE_SUPPORT_METADATA */
            cbops_process_data(op_extra_data->spkr_graph, CBOPS_MAX_COPY_SIZE-1);
#endif /* AEC_REFERENCE_SUPPORT_METADATA*/
            base_op_profiler_add_kick(op_data);
84200a00:	5a 08       	r0 = r9 + Null;
84200a02:	ef fd fd ff 	call (m) 0x53a;
84200a06:	39 e9 

84200a08 <Lc_aec_reference_timer_task_71>:
        }

        /* Check for Kicks (outputs).   Use Output 1 available data*/
        if(op_extra_data->sync_block.block_sync)
84200a08:	60 f0 ad 88 	Null = M[r4 + 692];
84200a0c:	06 60       	if EQ jump (m) Lc_aec_reference_timer_task_73;

84200a0e <Lc_aec_reference_timer_task_72>:
        {
            source_kicks = op_extra_data->source_kicks;
84200a0e:	61 f0 9b 88 	rMAC = M[r4 + 620];
84200a12:	49 de       	M[FP + 36] = rMAC;
            op_extra_data->sync_block.block_sync = 0;
84200a14:	60 f0 ad 8e 	M[r4 + 692] = Null;

84200a18 <Lc_aec_reference_timer_task_73>:
        }

        /* Check for Kick (inputs).   Use Input 1 available space */
        if(op_extra_data->input_stream[AEC_REF_INPUT_TERMINAL1])
84200a18:	32 e8       	r0 = M[r4 + Null];
84200a1a:	0d 60       	if EQ jump (m) Lc_aec_reference_timer_task_76;

84200a1c <Lc_aec_reference_timer_task_74>:
        {
            int available_space = cbuffer_calc_amount_space_in_words(op_extra_data->input_stream[AEC_REF_INPUT_TERMINAL1]);
84200a1c:	ff fd c9 f1 	call (m) 0x39d88;
84200a20:	2d eb 

            if(available_space >= op_extra_data->spkr_kick_size)
84200a22:	61 f0 82 88 	rMAC = M[r4 + 520];
84200a26:	50 04       	Null = r0 - rMAC;
84200a28:	06 64       	if NC jump (m) Lc_aec_reference_timer_task_76;

84200a2a <Lc_aec_reference_timer_task_75>:
            {
                sink_kicks = op_extra_data->sink_kicks;
84200a2a:	61 f0 9c 88 	rMAC = M[r4 + 624];
84200a2e:	41 de       	M[FP + 32] = rMAC;
            }
        }


        if(sink_kicks || source_kicks)
84200a30:	08 04       	Null = rMAC - Null;
84200a32:	03 62       	if NE jump (m) Lc_aec_reference_timer_task_77;

84200a34 <Lc_aec_reference_timer_task_76>:
84200a34:	49 d8       	rMAC = M[FP + 36];
84200a36:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_78;

84200a38 <Lc_aec_reference_timer_task_77>:
        {
            opmgr_kick_from_operator(op_data,source_kicks,sink_kicks);
84200a38:	5a 08       	r0 = r9 + Null;
84200a3a:	44 d8       	r2 = M[FP + 32];
84200a3c:	4b d8       	r1 = M[FP + 36];
84200a3e:	ff fd 16 f0 	call (m) 0x3756;
84200a42:	39 e8 

84200a44 <Lc_aec_reference_timer_task_78>:
        }
    }

    /* Next Timer Event */
    next_fire_time = time_add(get_last_fire_time(), op_extra_data->kick_period);
84200a44:	ff fd 2d f0 	call (m) 0x64b0;
84200a48:	2d e3 
84200a4a:	61 f0 67 88 	rMAC = M[r4 + 412];
84200a4e:	8a 00       	r0 = rMAC + r0;
    op_extra_data->kick_id = timer_schedule_event_at(next_fire_time,
                                                     aec_reference_timer_task, (void*)op_data);
84200a50:	42 f0 03 f0 	r1 = Null + 69207877;
84200a54:	45 4b 
INLINE_SECTION static inline tTimerId timer_schedule_event_at(
       TIME event_time,
       tTimerEventFunction TimerEventFunction,
       void *data_pointer)
{
    return create_add_strict_event(event_time, TimerEventFunction, data_pointer);
84200a56:	5c 08       	r2 = r9 + Null;
84200a58:	ff fd 2b f0 	call (m) 0x610a;
84200a5c:	33 e5 
}
84200a5e:	62 f0 5e 8e 	M[r4 + 376] = r0;

    base_op_profiler_stop(op_data);
84200a62:	5a 08       	r0 = r9 + Null;
84200a64:	ef fd fd ff 	call (m) 0x52c;
84200a68:	29 e6 
84200a6a:	08 6e       	jump (m) Lc_aec_reference_timer_task_80;

84200a6c <Lc_aec_reference_timer_task_79>:
                 */
                unsigned amount_processed;
                unsigned after_amount = cbuffer_calc_amount_data_in_words(met_buf);
#ifdef TODO_AEC_REFERENCE_TTP
                /* for the moment don't tolerate cbops doing anything wrong */
                PL_ASSERT(after_amount <= before_amount);
84200a6c:	03 f0 a0 60 	r1 = Null + 4256;
84200a70:	02 f0 13 60 	r0 = Null + 4115;
84200a74:	ff fd b2 f0 	call (m) 0x16ff0;
84200a78:	3d eb 

84200a7a <Lc_aec_reference_timer_task_80>:
    next_fire_time = time_add(get_last_fire_time(), op_extra_data->kick_period);
    op_extra_data->kick_id = timer_schedule_event_at(next_fire_time,
                                                     aec_reference_timer_task, (void*)op_data);

    base_op_profiler_stop(op_data);
}
84200a7a:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200a7c:	d8 4c       	rts;

84200a7e <$_aec_reference_opmsg_obpm_set_control>:


/* **************************** Operator message handlers ******************************** */

bool aec_reference_opmsg_obpm_set_control(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200a7e:	c8 1c       	pushm <FP(=SP), rLink>;
84200a80:	1a 00       	r0 = r1 + Null;
84200a82:	23 00       	r1 = r2 + Null;
84200a84:	2c 00       	r2 = r3 + Null;
    patch_fn_shared(aec_reference);

    /* In the case of this capability, nothing is done for control message. Just follow protocol and ignore any content. */
    return cps_control_setup(message_data, resp_length, resp_data,NULL);
84200a86:	05 00       	r3 = Null + Null;
84200a88:	ff fd 00 f0 	call (m) 0xab2;
84200a8c:	2b e1 

84200a8e <Lc_aec_reference_opmsg_obpm_set_control_2>:
}
84200a8e:	c8 48       	popm <FP, rLink>;
84200a90:	d8 4c       	rts;

84200a92 <$_aec_reference_opmsg_obpm_get_params>:

bool aec_reference_opmsg_obpm_get_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200a92:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200a94:	1f 00       	r5 = r1 + Null;
84200a96:	26 00       	r4 = r2 + Null;
84200a98:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84200a9a:	ef fd fd ff 	call (m) 0x4e6;
84200a9e:	2d e2 
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    return cpsGetParameterMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
84200aa0:	02 f0 7c 45 	r0 = r0 + 380;
84200aa4:	45 08       	r3 = r6 + Null;
84200aa6:	34 00       	r2 = r4 + Null;
84200aa8:	3b 00       	r1 = r5 + Null;
84200aaa:	ef fd fe ff 	call (m) 0x792;
84200aae:	29 e7 

84200ab0 <Lc_aec_reference_opmsg_obpm_get_params_2>:
}
84200ab0:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200ab2:	d8 4c       	rts;

84200ab4 <$_aec_reference_opmsg_obpm_get_defaults>:

bool aec_reference_opmsg_obpm_get_defaults(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200ab4:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200ab6:	1f 00       	r5 = r1 + Null;
84200ab8:	26 00       	r4 = r2 + Null;
84200aba:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84200abc:	ef fd fd ff 	call (m) 0x4e6;
84200ac0:	2b e1 
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    return cpsGetDefaultsMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
84200ac2:	02 f0 7c 45 	r0 = r0 + 380;
84200ac6:	45 08       	r3 = r6 + Null;
84200ac8:	34 00       	r2 = r4 + Null;
84200aca:	3b 00       	r1 = r5 + Null;
84200acc:	ef fd fe ff 	call (m) 0x840;
84200ad0:	35 eb 

84200ad2 <Lc_aec_reference_opmsg_obpm_get_defaults_2>:
}
84200ad2:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200ad4:	d8 4c       	rts;

84200ad6 <$_aec_reference_opmsg_obpm_set_params>:

bool aec_reference_opmsg_obpm_set_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200ad6:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84200ad8:	19 09       	r7 = r1 + Null;
84200ada:	27 00       	r5 = r2 + Null;
84200adc:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84200ade:	ef fd fd ff 	call (m) 0x4e6;
84200ae2:	29 e0 
84200ae4:	16 00       	r4 = r0 + Null;

    bool retval;

    patch_fn_shared(aec_reference);

    retval = cpsSetParameterMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
84200ae6:	62 f0 7c 21 	r0 = r4 + 380;
84200aea:	45 08       	r3 = r6 + Null;
84200aec:	3c 00       	r2 = r5 + Null;
84200aee:	4b 08       	r1 = r7 + Null;
84200af0:	ef fd ff ff 	call (m) 0x914;
84200af4:	25 e1 

    /* Set the Reinit flag after setting the parameters */
    op_extra_data->ReInitFlag = TRUE;
84200af6:	41 20       	rMAC = Null + 1;
84200af8:	61 f0 5d 8e 	M[r4 + 372] = rMAC;

84200afc <Lc_aec_reference_opmsg_obpm_set_params_2>:

    return retval;
84200afc:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200afe:	d8 4c       	rts;

84200b00 <$_aec_reference_opmsg_obpm_get_status>:
}

bool aec_reference_opmsg_obpm_get_status(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200b00:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
84200b02:	19 09       	r7 = r1 + Null;
84200b04:	26 00       	r4 = r2 + Null;
84200b06:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84200b08:	ef fd fc ff 	call (m) 0x4e6;
84200b0c:	3f ee 
84200b0e:	17 00       	r5 = r0 + Null;
    unsigned last_acc_spkr = 0;
#endif

    patch_fn_shared(aec_reference);

    if(!common_obpm_status_helper(message_data,resp_length,resp_data,sizeof(AEC_REFERENCE_STATISTICS) ,&resp))
84200b10:	81 11       	rMAC = FP + 24;
84200b12:	09 1c       	pushm <rMAC>;
84200b14:	05 f0 50 40 	r3 = Null + 80;
84200b18:	44 08       	r2 = r6 + Null;
84200b1a:	33 00       	r1 = r4 + Null;
84200b1c:	4a 08       	r0 = r7 + Null;
84200b1e:	ff fd 00 f0 	call (m) 0xb64;
84200b22:	27 e2 
84200b24:	7f 4c       	SP = SP + -4;
84200b26:	10 04       	Null = r0 - Null;
84200b28:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_obpm_get_status_3;

84200b2a <Lc_aec_reference_opmsg_obpm_get_status_2>:
    {
        return FALSE;
84200b2a:	02 00       	r0 = Null + Null;
84200b2c:	ac 6e       	jump (m) Lc_aec_reference_opmsg_obpm_get_status_15;

84200b2e <Lc_aec_reference_opmsg_obpm_get_status_3>:
    }

    if(resp)
84200b2e:	34 d8       	r2 = M[FP + 24];
84200b30:	a9 60       	if EQ jump (m) Lc_aec_reference_opmsg_obpm_get_status_14;

84200b32 <Lc_aec_reference_opmsg_obpm_get_status_4>:
    {
        unsigned config_flag = 0;
84200b32:	06 00       	r4 = Null + Null;
        unsigned volume=op_extra_data->shared_volume_ptr->current_volume_level;
84200b34:	71 f0 59 88 	rMAC = M[r5 + 356];
84200b38:	18 f0 02 88 	r6 = M[rMAC + 8];

        if(op_extra_data->using_sidetone==USE_SIDETONE_FLAG)
84200b3c:	71 f0 9a 88 	rMAC = M[r5 + 616];
84200b40:	c8 24       	Null = rMAC - 3;
84200b42:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_obpm_get_status_6;

84200b44 <Lc_aec_reference_opmsg_obpm_get_status_5>:
        {
            config_flag = flag_uses_SIDETONE;
84200b44:	46 f0 00 40 	r4 = Null + 32768;

84200b48 <Lc_aec_reference_opmsg_obpm_get_status_6>:
        }
        if(op_extra_data->channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_REF)
84200b48:	71 f0 83 88 	rMAC = M[r5 + 524];
84200b4c:	11 f2 00 00 	rMAC = rMAC AND 0x4000;
84200b50:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_obpm_get_status_8;

84200b52 <Lc_aec_reference_opmsg_obpm_get_status_7>:
        {
            config_flag += flag_uses_AEC_REFERENCE;
84200b52:	86 f0 00 44 	r4 = r4 + 65536;

84200b56 <Lc_aec_reference_opmsg_obpm_get_status_8>:
        }

        resp = cpsPack2Words(op_extra_data->Cur_mode, op_extra_data->Ovr_Control, resp);
84200b56:	73 f0 5c 88 	r1 = M[r5 + 368];
84200b5a:	72 f0 5b 88 	r0 = M[r5 + 364];
84200b5e:	ff fd c8 f1 	call (m) 0x39caa;
84200b62:	2d ea 
84200b64:	32 de       	M[FP + 24] = r0;
        resp = cpsPack2Words(config_flag, volume, resp);
84200b66:	34 d8       	r2 = M[FP + 24];
84200b68:	43 08       	r1 = r6 + Null;
84200b6a:	32 00       	r0 = r4 + Null;
84200b6c:	ff fd c8 f1 	call (m) 0x39caa;
84200b70:	3f e9 
84200b72:	32 de       	M[FP + 24] = r0;
        resp = cpsPack2Words(op_extra_data->channel_status, op_extra_data->mic_rate, resp);
84200b74:	34 d8       	r2 = M[FP + 24];
84200b76:	73 f0 72 88 	r1 = M[r5 + 456];
84200b7a:	72 f0 83 88 	r0 = M[r5 + 524];
84200b7e:	ff fd c8 f1 	call (m) 0x39caa;
84200b82:	2d e9 
84200b84:	32 de       	M[FP + 24] = r0;
        resp = cpsPack2Words(op_extra_data->output_rate, op_extra_data->input_rate, resp);
84200b86:	34 d8       	r2 = M[FP + 24];
84200b88:	73 f0 70 88 	r1 = M[r5 + 448];
84200b8c:	72 f0 71 88 	r0 = M[r5 + 452];
84200b90:	ff fd c8 f1 	call (m) 0x39caa;
84200b94:	3b e8 
84200b96:	32 de       	M[FP + 24] = r0;
        resp = cpsPack1Word(op_extra_data->spkr_rate, resp);
84200b98:	33 d8       	r1 = M[FP + 24];
84200b9a:	72 f0 7b 88 	r0 = M[r5 + 492];
84200b9e:	ff fd c8 f1 	call (m) 0x39cda;
84200ba2:	3d e9 
84200ba4:	32 de       	M[FP + 24] = r0;

        /* Rate Matching statistics */
        /* TODO: Make these on demand instead of always ON */

#if defined(IO_DEBUG)
        if (op_extra_data->st_disgard_op != NULL)
84200ba6:	72 f0 d2 88 	r0 = M[r5 + 840];
84200baa:	06 60       	if EQ jump (m) Lc_aec_reference_opmsg_obpm_get_status_10;

84200bac <Lc_aec_reference_opmsg_obpm_get_status_9>:
        {
            op_extra_data->ref_st_drop = get_sink_overflow_disgard_drops(op_extra_data->st_disgard_op);
84200bac:	ff fd 1b f4 	call 0x84310;
84200bb0:	24 eb 
84200bb2:	72 f0 d5 8e 	M[r5 + 852] = r0;

84200bb6 <Lc_aec_reference_opmsg_obpm_get_status_10>:
        }

        op_extra_data->ref_spkr_refdrop = op_extra_data->sync_block.speaker_drops + op_extra_data->sync_block.speaker_inserts;
84200bb6:	71 f0 b4 88 	rMAC = M[r5 + 720];
84200bba:	72 f0 b3 88 	r0 = M[r5 + 716];
84200bbe:	51 00       	rMAC = r0 + rMAC;
84200bc0:	71 f0 d3 8e 	M[r5 + 844] = rMAC;
        op_extra_data->ref_micref_delay = op_extra_data->sync_block.speaker_delay;
84200bc4:	71 f0 b5 88 	rMAC = M[r5 + 724];
84200bc8:	71 f0 d4 8e 	M[r5 + 848] = rMAC;

        if (op_extra_data->insert_op != NULL)
84200bcc:	72 f0 d1 88 	r0 = M[r5 + 836];
84200bd0:	1c 60       	if EQ jump (m) Lc_aec_reference_opmsg_obpm_get_status_13;

84200bd2 <Lc_aec_reference_opmsg_obpm_get_status_11>:
        {
            num_inserts_total  = get_aec_ref_cbops_inserts_total(op_extra_data->insert_op);
84200bd2:	14 f0 3b e9 	call (m) $_get_aec_ref_cbops_inserts_total;
84200bd6:	16 00       	r4 = r0 + Null;
            num_inserts_insert = get_aec_ref_cbops_insert_op_insert_total(op_extra_data->insert_op);
84200bd8:	72 f0 d1 88 	r0 = M[r5 + 836];
84200bdc:	14 f0 3b e9 	call (m) $_get_aec_ref_cbops_insert_op_insert_total;
84200be0:	10 09       	r6 = r0 + Null;
            num_inserts_wrap   = get_aec_ref_cbops_wrap_op_insert_total(op_extra_data->insert_op);
84200be2:	72 f0 d1 88 	r0 = M[r5 + 836];
84200be6:	14 f0 37 e9 	call (m) $_get_aec_ref_cbops_wrap_op_insert_total;

            if (num_inserts_total != op_extra_data->ref_last_inserts_total)
84200bea:	71 f0 d7 88 	rMAC = M[r5 + 860];
84200bee:	70 04       	Null = r4 - rMAC;
84200bf0:	0c 60       	if EQ jump (m) Lc_aec_reference_opmsg_obpm_get_status_13;

84200bf2 <Lc_aec_reference_opmsg_obpm_get_status_12>:
            {
                op_extra_data->ref_last_inserts_total = num_inserts_total;
84200bf2:	76 f0 d7 8e 	M[r5 + 860] = r4;
                op_extra_data->ref_last_inserts_insert = num_inserts_insert;
84200bf6:	78 f0 d8 8e 	M[r5 + 864] = r6;
                op_extra_data->ref_last_inserts_wrap = num_inserts_wrap;
84200bfa:	72 f0 d9 8e 	M[r5 + 868] = r0;
                op_extra_data->ref_inserts++;
84200bfe:	71 f0 d6 88 	rMAC = M[r5 + 856];
84200c02:	49 20       	rMAC = rMAC + 1;
84200c04:	71 f0 d6 8e 	M[r5 + 856] = rMAC;

84200c08 <Lc_aec_reference_opmsg_obpm_get_status_13>:
            }
        }

        /* get last acc for mic and speaker,
         * Note: it's fine if rate_monitor_op not existing, it will return 0 */
        last_acc_mic = get_rate_monitor_last_acc(op_extra_data->mic_rate_monitor_op);
84200c08:	72 f0 76 88 	r0 = M[r5 + 472];
84200c0c:	ff fd 1b f4 	call 0x842bc;
84200c10:	30 e5 
84200c12:	10 09       	r6 = r0 + Null;
        last_acc_spkr = get_rate_monitor_last_acc(op_extra_data->spkr_rate_monitor_op);
84200c14:	72 f0 80 88 	r0 = M[r5 + 512];
84200c18:	ff fd 1b f4 	call 0x842bc;
84200c1c:	24 e5 
84200c1e:	16 00       	r4 = r0 + Null;

        resp = cpsPack2Words(op_extra_data->mic_rate_enactment, op_extra_data->spkr_rate_enactment, resp);
84200c20:	34 d8       	r2 = M[FP + 24];
84200c22:	73 f0 7e 88 	r1 = M[r5 + 504];
84200c26:	72 f0 cd 81 	r0 = MBS[r5 + 461];
84200c2a:	ff fd c8 f1 	call (m) 0x39caa;
84200c2e:	21 e4 
84200c30:	32 de       	M[FP + 24] = r0;
        resp = cpsPack2Words(last_acc_mic, last_acc_spkr, resp);
84200c32:	34 d8       	r2 = M[FP + 24];
84200c34:	33 00       	r1 = r4 + Null;
84200c36:	42 08       	r0 = r6 + Null;
84200c38:	ff fd c8 f1 	call (m) 0x39caa;
84200c3c:	33 e3 
84200c3e:	32 de       	M[FP + 24] = r0;
        resp = cpsPack2Words(op_extra_data->mic_rate_adjustment, op_extra_data->spkr_rate_adjustment, resp);
84200c40:	34 d8       	r2 = M[FP + 24];
84200c42:	73 f0 7d 88 	r1 = M[r5 + 500];
84200c46:	72 f0 74 88 	r0 = M[r5 + 464];
84200c4a:	ff fd c8 f1 	call (m) 0x39caa;
84200c4e:	21 e3 
84200c50:	32 de       	M[FP + 24] = r0;
        resp = cpsPack2Words(op_extra_data->sync_block.rm_adjustment, op_extra_data->ref_last_inserts_total, resp);
84200c52:	34 d8       	r2 = M[FP + 24];
84200c54:	73 f0 d7 88 	r1 = M[r5 + 860];
84200c58:	72 f0 b2 88 	r0 = M[r5 + 712];
84200c5c:	ff fd c8 f1 	call (m) 0x39caa;
84200c60:	2f e2 
84200c62:	32 de       	M[FP + 24] = r0;
        resp = cpsPack2Words(op_extra_data->ref_spkr_refdrop, op_extra_data->ref_st_drop, resp);
84200c64:	34 d8       	r2 = M[FP + 24];
84200c66:	73 f0 d5 88 	r1 = M[r5 + 852];
84200c6a:	72 f0 d3 88 	r0 = M[r5 + 844];
84200c6e:	ff fd c8 f1 	call (m) 0x39caa;
84200c72:	3d e1 
84200c74:	32 de       	M[FP + 24] = r0;
        cpsPack1Word(op_extra_data->ref_micref_delay, resp);
84200c76:	33 d8       	r1 = M[FP + 24];
84200c78:	72 f0 d4 88 	r0 = M[r5 + 848];
84200c7c:	ff fd c8 f1 	call (m) 0x39cda;
84200c80:	3f e2 

84200c82 <Lc_aec_reference_opmsg_obpm_get_status_14>:
#endif

    }

    return TRUE;
84200c82:	42 20       	r0 = Null + 1;

84200c84 <Lc_aec_reference_opmsg_obpm_get_status_15>:
}
84200c84:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
84200c86:	d8 4c       	rts;

84200c88 <$_aec_reference_opmsg_ep_get_config>:
    return;
}
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

bool aec_reference_opmsg_ep_get_config(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200c88:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200c8a:	18 09       	r6 = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84200c8c:	ef fd fc ff 	call (m) 0x4e6;
84200c90:	3b e2 
84200c92:	16 00       	r4 = r0 + Null;

bool aec_reference_opmsg_ep_get_config(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    OPMSG_GET_CONFIG *msg = message_data;
    OPMSG_GET_CONFIG_RESULT *result = msg->result;
84200c94:	87 f0 04 88 	r5 = M[r6 + 16];
    unsigned term_idx = msg->header.cmd_header.client_id;
84200c98:	81 f0 00 e8 	rMAC = M[r6 + Null];

    /* msg->value - Pointer which will be populated with the asked configuration value
       msg->cmd_header.client_id - Terminal ID (includes TERMINAL_SINK_MASK for sinks)
       msg->key - Parameter Key to return value for */

    switch(msg->key)
84200c9c:	82 f0 03 88 	r0 = M[r6 + 12];
84200ca0:	d0 24       	Null = r0 - 3;
84200ca2:	62 64       	if NC jump (m) Lc_aec_reference_opmsg_ep_get_config_28;

84200ca4 <Lc_aec_reference_opmsg_ep_get_config_2>:
84200ca4:	d0 26       	Null = r0 - 11;
84200ca6:	08 f0 c1 e1 	if HI jump (m) Lc_aec_reference_opmsg_ep_get_config_28;

84200caa <Lc_aec_reference_opmsg_ep_get_config_3>:
84200caa:	ea 7c       	r0 = r0 + -3;
84200cac:	52 54       	r0 = r0 LSHIFT 2;
84200cae:	e0 f0 22 f0 	r0 = M[r0 + 7340280];
84200cb2:	3e 88 
84200cb4:	da 4c       	jump r0;

84200cb6 <Lc_aec_reference_opmsg_ep_get_config_4>:
    {
        case OPMSG_OP_TERMINAL_DETAILS:
            /* Return a uint32 - Is Terminal emulating a real endpoint. Called at operator endpoint creation.
             */
            if(term_idx & TERMINAL_SINK_MASK)
84200cb6:	40 f0 12 f0 	r0 = rMAC AND 0x800000;
84200cba:	00 00 
84200cbc:	0e 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_get_config_8;

84200cbe <Lc_aec_reference_opmsg_ep_get_config_5>:
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
}
inline static bool IsMicrophoneTerminal(unsigned term_idx)
{
    term_idx &= ~TERMINAL_SINK_MASK;
84200cbe:	bf ff 11 ff 	rMAC = rMAC AND 0xff7fffff;
84200cc2:	ff 1f 

    if(term_idx < AEC_REF_MIC_TERMINAL1)
84200cc4:	88 24       	Null = rMAC - 2;
84200cc6:	02 f0 a5 e1 	if C jump (m) Lc_aec_reference_opmsg_ep_get_config_29;

84200cca <Lc_aec_reference_opmsg_ep_get_config_6>:
    {
        return FALSE;
84200cca:	02 00       	r0 = Null + Null;

84200ccc <Lc_aec_reference_opmsg_ep_get_config_7>:
            {
                result->value = (uint32)(IsMicrophoneTerminal(term_idx)?
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_NONE:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_REAL);
84200ccc:	01 00       	rMAC = Null + Null;
84200cce:	10 04       	Null = r0 - Null;
84200cd0:	20 f0 41 ce 	if EQ rMAC = Null + 1;
84200cd4:	39 ee       	M[r5 + Null] = rMAC;
84200cd6:	21 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200cd8 <Lc_aec_reference_opmsg_ep_get_config_8>:
inline static bool IsSpeakerTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_SPKR_TERMINAL1)
          || (term_idx==AEC_REF_SPKR_TERMINAL2)
          || ( (term_idx>=AEC_REF_SPKR_TERMINAL3)
              && (term_idx<=AEC_REF_SPKR_TERMINAL8) ) );
84200cd8:	48 24       	Null = rMAC - 1;
84200cda:	08 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_get_config_12;

84200cdc <Lc_aec_reference_opmsg_ep_get_config_9>:
84200cdc:	88 24       	Null = rMAC - 2;
84200cde:	06 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_get_config_12;

84200ce0 <Lc_aec_reference_opmsg_ep_get_config_10>:
84200ce0:	c8 25       	Null = rMAC - 7;
84200ce2:	4e 64       	if NC jump (m) Lc_aec_reference_opmsg_ep_get_config_32;

84200ce4 <Lc_aec_reference_opmsg_ep_get_config_11>:
84200ce4:	08 27       	Null = rMAC - 12;
84200ce6:	08 f0 99 e1 	if HI jump (m) Lc_aec_reference_opmsg_ep_get_config_32;

84200cea <Lc_aec_reference_opmsg_ep_get_config_12>:
84200cea:	41 20       	rMAC = Null + 1;
84200cec:	4a 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_33;

84200cee <Lc_aec_reference_opmsg_ep_get_config_13>:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_NONE:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_REAL);
            }
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_ABILITY: /* uint32 */
            if(term_idx == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200cee:	00 f2 10 f0 	Null = rMAC - 8388608;
84200cf2:	00 24 
84200cf4:	05 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_15;

84200cf6 <Lc_aec_reference_opmsg_ep_get_config_14>:
            {
                result->value = (uint32)op_extra_data->spkr_rate_ability;
84200cf6:	61 f0 7c 88 	rMAC = M[r4 + 496];
84200cfa:	39 ee       	M[r5 + Null] = rMAC;
84200cfc:	09 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_18;

84200cfe <Lc_aec_reference_opmsg_ep_get_config_15>:
                     */
                    result->value = RATEMATCHING_SUPPORT_HW;
                }
#endif
            }
            else if (term_idx == AEC_REF_OUTPUT_TERMINAL1)
84200cfe:	c8 24       	Null = rMAC - 3;
84200d00:	0e 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_21;

84200d02 <Lc_aec_reference_opmsg_ep_get_config_16>:
            {

                if(op_extra_data->mic_sync_enable)
84200d02:	60 f0 cd 88 	Null = M[r4 + 820];
84200d06:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_21;

84200d08 <Lc_aec_reference_opmsg_ep_get_config_17>:
                    result->value = (uint32)RATEMATCHING_SUPPORT_AUTO;
                }
                else
                {

                    result->value = (uint32) op_extra_data->mic_rate_ability;
84200d08:	61 f0 cc 81 	rMAC = MBS[r4 + 460];
84200d0c:	39 ee       	M[r5 + Null] = rMAC;

84200d0e <Lc_aec_reference_opmsg_ep_get_config_18>:
        case OPMSG_OP_TERMINAL_RATEMATCH_ABILITY: /* uint32 */
            if(term_idx == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
            {
                result->value = (uint32)op_extra_data->spkr_rate_ability;
#ifdef ENABLE_FORCE_ENACTING_BY_AEC_REFERENCE
                if(RATEMATCHING_SUPPORT_SW == result->value)
84200d0e:	39 e8       	rMAC = M[r5 + Null];
84200d10:	48 24       	Null = rMAC - 1;
84200d12:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200d14 <Lc_aec_reference_opmsg_ep_get_config_19>:
                {
                    /* Advertise HW despite planning to do it in SW
                     * this will make sure that enacting will be granted
                     * to this end.
                     */
                    result->value = RATEMATCHING_SUPPORT_HW;
84200d14:	81 20       	rMAC = Null + 2;
84200d16:	39 ee       	M[r5 + Null] = rMAC;

84200d18 <Lc_aec_reference_opmsg_ep_get_config_20>:
        case OPMSG_OP_TERMINAL_PROC_TIME:         /* uint32 */
        default:
            return FALSE;
    }

    return TRUE;
84200d18:	42 20       	r0 = Null + 1;
84200d1a:	39 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_34;

84200d1c <Lc_aec_reference_opmsg_ep_get_config_21>:
                }

            }
            else
            {
                result->value = (uint32)RATEMATCHING_SUPPORT_AUTO;
84200d1c:	c1 20       	rMAC = Null + 3;
84200d1e:	39 ee       	M[r5 + Null] = rMAC;
84200d20:	fc 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200d22 <Lc_aec_reference_opmsg_ep_get_config_22>:
            break;
        case OPMSG_OP_TERMINAL_KICK_PERIOD:       /* uint32 */
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_RATE:    /* uint32 */

            if(term_idx == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200d22:	00 f2 10 f0 	Null = rMAC - 8388608;
84200d26:	00 24 
84200d28:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_24;

84200d2a <Lc_aec_reference_opmsg_ep_get_config_23>:
            {
                result->value = rate_monitor_op_get_rate(op_extra_data->spkr_rate_monitor_op,0);
84200d2a:	62 f0 80 88 	r0 = M[r4 + 512];
84200d2e:	03 00       	r1 = Null + Null;
84200d30:	ff fd 1a f4 	call 0x84270;
84200d34:	20 ea 
84200d36:	3a ee       	M[r5 + Null] = r0;
                patch_fn_shared(aec_reference);

                op_extra_data->spkr_rate_meas = (unsigned)(result->value);
84200d38:	62 f0 a6 8e 	M[r4 + 664] = r0;
84200d3c:	ee 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200d3e <Lc_aec_reference_opmsg_ep_get_config_24>:

            }
            else if (term_idx == AEC_REF_OUTPUT_TERMINAL1)
84200d3e:	c8 24       	Null = rMAC - 3;
84200d40:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_26;

84200d42 <Lc_aec_reference_opmsg_ep_get_config_25>:
            {
                result->value = rate_monitor_op_get_rate(op_extra_data->mic_rate_monitor_op,0);
84200d42:	62 f0 76 88 	r0 = M[r4 + 472];
84200d46:	03 00       	r1 = Null + Null;
84200d48:	ff fd 1a f4 	call 0x84270;
84200d4c:	28 e9 
84200d4e:	3a ee       	M[r5 + Null] = r0;
                patch_fn_shared(aec_reference);

                op_extra_data->mic_rate_meas = (unsigned)(result->value);
84200d50:	62 f0 a7 8e 	M[r4 + 668] = r0;
84200d54:	e2 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200d56 <Lc_aec_reference_opmsg_ep_get_config_26>:
            }
            else
            {
                /* 1.0 in Qx.22 independent of word width */
                result->value = 1<<STREAM_RATEMATCHING_FIX_POINT_SHIFT;
84200d56:	04 f0 01 f0 	rMAC = Null + 4194304;
84200d5a:	00 40 
84200d5c:	39 ee       	M[r5 + Null] = rMAC;
84200d5e:	dd 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200d60 <Lc_aec_reference_opmsg_ep_get_config_27>:
            }

            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_MEASUREMENT:
            /* TODO */
            result->rm_measurement.sp_deviation = 0;
84200d60:	38 ee       	M[r5 + Null] = Null;
            result->rm_measurement.measurement.valid = FALSE;
84200d62:	38 8b       	MB[r5 + 4] = Null;
            break;
84200d64:	da 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200d66 <Lc_aec_reference_opmsg_ep_get_config_28>:
        case OPMSG_OP_TERMINAL_BLOCK_SIZE:        /* uint32 */
        case OPMSG_OP_TERMINAL_PROC_TIME:         /* uint32 */
        default:
            return FALSE;
84200d66:	02 00       	r0 = Null + Null;
84200d68:	12 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_34;

84200d6a <Lc_aec_reference_opmsg_ep_get_config_29>:

    if(term_idx < AEC_REF_MIC_TERMINAL1)
    {
        return FALSE;
    }
    if(term_idx <= AEC_REF_MIC_TERMINAL4)
84200d6a:	48 25       	Null = rMAC - 5;
84200d6c:	08 f0 89 e0 	if HI jump (m) Lc_aec_reference_opmsg_ep_get_config_31;

84200d70 <Lc_aec_reference_opmsg_ep_get_config_30>:
    {
        return TRUE;
84200d70:	42 20       	r0 = Null + 1;
84200d72:	ad 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_7;

84200d74 <Lc_aec_reference_opmsg_ep_get_config_31>:
    }
    return (term_idx >= AEC_REF_MIC_TERMINAL5);
84200d74:	02 00       	r0 = Null + Null;
84200d76:	08 27       	Null = rMAC - 12;
84200d78:	22 f0 42 ce 	if C r0 = Null + 1;
84200d7c:	a8 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_7;

84200d7e <Lc_aec_reference_opmsg_ep_get_config_32>:
inline static bool IsSpeakerTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_SPKR_TERMINAL1)
          || (term_idx==AEC_REF_SPKR_TERMINAL2)
          || ( (term_idx>=AEC_REF_SPKR_TERMINAL3)
              && (term_idx<=AEC_REF_SPKR_TERMINAL8) ) );
84200d7e:	01 00       	rMAC = Null + Null;

84200d80 <Lc_aec_reference_opmsg_ep_get_config_33>:
            }
            else
            {
                result->value = (uint32)(IsSpeakerTerminal(term_idx)?
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_NONE:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_REAL);
84200d80:	02 00       	r0 = Null + Null;
84200d82:	08 04       	Null = rMAC - Null;
84200d84:	20 f0 42 ce 	if EQ r0 = Null + 1;
84200d88:	3a ee       	M[r5 + Null] = r0;
84200d8a:	c7 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200d8c <Lc_aec_reference_opmsg_ep_get_config_34>:
        default:
            return FALSE;
    }

    return TRUE;
}
84200d8c:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200d8e:	d8 4c       	rts;

84200d90 <$_aec_reference_opmsg_ep_configure>:


bool aec_reference_opmsg_ep_configure(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200d90:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200d92:	18 09       	r6 = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84200d94:	ef fd fb ff 	call (m) 0x4e6;
84200d98:	33 ea 
84200d9a:	16 00       	r4 = r0 + Null;

bool aec_reference_opmsg_ep_configure(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    OPMSG_CONFIGURE  *msg = message_data;
    unsigned terminal_id = msg->header.cmd_header.client_id;
84200d9c:	81 f0 00 e8 	rMAC = M[r6 + Null];
    uint32      value = msg->value;
84200da0:	87 f0 04 88 	r5 = M[r6 + 16];

    /* msg->value - Pointer or Value for Key
       msg->cmd_header.client_id - Terminal ID (includes TERMINAL_SINK_MASK for sinks)
       msg->key - Parameter Key to return value for */

    switch(msg->key)
84200da4:	82 f0 03 88 	r0 = M[r6 + 12];
84200da8:	0c 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_5;

84200daa <Lc_aec_reference_opmsg_ep_configure_2>:
84200daa:	90 26       	Null = r0 - 10;
84200dac:	08 f0 95 e0 	if HI jump (m) Lc_aec_reference_opmsg_ep_configure_5;

84200db0 <Lc_aec_reference_opmsg_ep_configure_3>:
84200db0:	52 24       	r0 = r0 - 1;
84200db2:	52 54       	r0 = r0 LSHIFT 2;
84200db4:	e0 f0 22 f0 	r0 = M[r0 + 7340316];
84200db8:	47 88 
84200dba:	da 4c       	jump r0;

84200dbc <Lc_aec_reference_opmsg_ep_configure_4>:
    {
        case OPMSG_OP_TERMINAL_DATA_FORMAT:
            /* value is data type */
            if( ((AUDIO_DATA_FORMAT)msg->value)!=AUDIO_DATA_FORMAT_FIXP )
84200dbc:	78 24       	Null = r5 - 1;
84200dbe:	e3 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200dc0 <Lc_aec_reference_opmsg_ep_configure_5>:
            {
                return(FALSE);
84200dc0:	02 00       	r0 = Null + Null;
84200dc2:	e2 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_56;

84200dc4 <Lc_aec_reference_opmsg_ep_configure_6>:
            /* TODO - Really need to know type of endpoint: ADC/DAC, I2S, Digital MIC

               CBOPS_DC_REMOVE | CBOPS_SHIFT (set data format --> AUDIO_DATA_FORMAT_FIXP)
               CBOPS_RATEADJUST (EP_RATEMATCH_ENACTING) */

            if (terminal_id == (AEC_REF_MIC_TERMINAL1|TERMINAL_SINK_MASK))
84200dc4:	00 f2 10 f0 	Null = rMAC - 8388610;
84200dc8:	02 24 
84200dca:	04 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_8;

84200dcc <Lc_aec_reference_opmsg_ep_configure_7>:
            {
                op_extra_data->mic_shift = (int)value;
84200dcc:	67 f0 7a 8e 	M[r4 + 488] = r5;
84200dd0:	da 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200dd2 <Lc_aec_reference_opmsg_ep_configure_8>:
            }
            else if (terminal_id == AEC_REF_SPKR_TERMINAL1)
84200dd2:	48 24       	Null = rMAC - 1;
84200dd4:	d8 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200dd6 <Lc_aec_reference_opmsg_ep_configure_9>:
            {
                op_extra_data->spkr_shift = (int)value;
84200dd6:	67 f0 81 8e 	M[r4 + 516] = r5;
84200dda:	d5 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200ddc <Lc_aec_reference_opmsg_ep_configure_10>:
            /* uint32 expected block size per period

               endpoint->state.audio.block_size = (unsigned int)value;
               endpoint->state.audio.kick_period =  (unsigned int)(value * (unsigned long)STREAM_KICK_PERIOD_FROM_USECS(1000000UL) /
               endpoint->state.audio.sample_rate); */
            if(terminal_id == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200ddc:	00 f2 10 f0 	Null = rMAC - 8388608;
84200de0:	00 24 
84200de2:	04 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_12;

84200de4 <Lc_aec_reference_opmsg_ep_configure_11>:
            {
                op_extra_data->spkr_kick_size = (unsigned)value;
84200de4:	67 f0 82 8e 	M[r4 + 520] = r5;
84200de8:	ce 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200dea <Lc_aec_reference_opmsg_ep_configure_12>:
            }
            else if (terminal_id == AEC_REF_OUTPUT_TERMINAL1)
84200dea:	c8 24       	Null = rMAC - 3;
84200dec:	cc 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200dee <Lc_aec_reference_opmsg_ep_configure_13>:

                /* mic-ref block_size latency control only works for larger block sizes, it will fail
                 * if requested block size is small, so we apply a minimum block size, below
                 * that mic-ref latency control logic will be turned off.
                 */
                unsigned min_block_size = frac_mult(op_extra_data->output_rate, FRACTIONAL(0.006));
84200dee:	62 f0 71 88 	r0 = M[r4 + 452];
84200df2:	0c f0 43 f2 	r1 = Null + 12884901;
84200df6:	a5 73 
84200df8:	00 f3 72 c9 	r0 = r0 * r1 (frac);

                /* Validate block size for sync logic.   Output buffers size will be at least 8.7 msec of data */
                if(block_size && (block_size < min_block_size) )
84200dfc:	39 00       	rMAC = r5 + Null;
84200dfe:	05 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_16;

84200e00 <Lc_aec_reference_opmsg_ep_configure_14>:
84200e00:	b8 04       	Null = r5 - r0;
84200e02:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_opmsg_ep_configure_16;

84200e06 <Lc_aec_reference_opmsg_ep_configure_15>:
                {
                    /* Disable sync logic if block_size is to small */
                    block_size = 0;
84200e06:	01 00       	rMAC = Null + Null;

84200e08 <Lc_aec_reference_opmsg_ep_configure_16>:
                }
                op_extra_data->sync_block.block_size = block_size;
84200e08:	61 f0 ac 8e 	M[r4 + 688] = rMAC;
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
                {
                    /* update minimum len metadata tags for mic output */
                    op_extra_data->mic_metadata_min_tag_len =
                        MAX(op_extra_data->mic_metadata_min_tag_len,
                            op_extra_data->sync_block.block_size);
84200e0c:	62 f0 c5 88 	r0 = M[r4 + 788];
84200e10:	50 04       	Null = r0 - rMAC;
84200e12:	02 f0 f3 e2 	if C jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e16 <Lc_aec_reference_opmsg_ep_configure_17>:
84200e16:	61 f0 c5 8e 	M[r4 + 788] = rMAC;
84200e1a:	b5 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e1c <Lc_aec_reference_opmsg_ep_configure_18>:
            }
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_ENACTING:
            /* uint32 TRUE or FALSE.   Operator should perform rate matching if TRUE  */

            if(terminal_id == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200e1c:	00 f2 10 f0 	Null = rMAC - 8388608;
84200e20:	00 24 
84200e22:	2b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_27;

84200e24 <Lc_aec_reference_opmsg_ep_configure_19>:
            {
                opmgr_override_set_ratematch_enacting(op_extra_data->spkr_endpoint,
                                                      (bool) value);
84200e24:	62 f0 a3 88 	r0 = M[r4 + 652];
84200e28:	3b 00       	r1 = r5 + Null;
84200e2a:	ff fd 23 f0 	call (m) 0x554a;
84200e2e:	21 e9 
                if(value==(uint32)FALSE)
84200e30:	38 04       	Null = r5 - Null;
84200e32:	04 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_21;

84200e34 <Lc_aec_reference_opmsg_ep_configure_20>:
                {
                    op_extra_data->spkr_rate_enactment = RATEMATCHING_SUPPORT_NONE;
84200e34:	60 f0 7e 8e 	M[r4 + 504] = Null;
84200e38:	05 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_22;

84200e3a <Lc_aec_reference_opmsg_ep_configure_21>:
                }
                else
                {
                    op_extra_data->spkr_rate_enactment = op_extra_data->spkr_rate_ability;
84200e3a:	61 f0 7c 88 	rMAC = M[r4 + 496];
84200e3e:	61 f0 7e 8e 	M[r4 + 504] = rMAC;

84200e42 <Lc_aec_reference_opmsg_ep_configure_22>:
                }

                if((op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_HW) && (op_extra_data->spkr_rate_monitor_op))
84200e42:	61 f0 7e 88 	rMAC = M[r4 + 504];
84200e46:	88 24       	Null = rMAC - 2;
84200e48:	0c 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_25;

84200e4a <Lc_aec_reference_opmsg_ep_configure_23>:
84200e4a:	62 f0 80 88 	r0 = M[r4 + 512];
84200e4e:	09 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_25;

84200e50 <Lc_aec_reference_opmsg_ep_configure_24>:
                {
                    rate_monitor_op_initialise(op_extra_data->spkr_rate_monitor_op,op_extra_data->spkr_rate,TRUE,3*MS_PER_SEC);
84200e50:	05 f0 b8 53 	r3 = Null + 3000;
84200e54:	44 20       	r2 = Null + 1;
84200e56:	63 f0 7b 88 	r1 = M[r4 + 492];
84200e5a:	ff fd 19 f4 	call 0x84204;
84200e5e:	2a ed 

84200e60 <Lc_aec_reference_opmsg_ep_configure_25>:
                }

                if(op_extra_data->spkr_sw_rateadj_op)
84200e60:	62 f0 9f 88 	r0 = M[r4 + 636];
84200e64:	90 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e66 <Lc_aec_reference_opmsg_ep_configure_26>:
                {
                    cbops_rateadjust_passthrough_mode(op_extra_data->spkr_sw_rateadj_op,(op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
84200e66:	03 00       	r1 = Null + Null;
84200e68:	60 f0 7e 88 	Null = M[r4 + 504];
84200e6c:	20 f0 43 ce 	if EQ r1 = Null + 1;
84200e70:	ff fd c7 f0 	call (m) 0x19d0a;
84200e74:	3b e4 
84200e76:	87 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e78 <Lc_aec_reference_opmsg_ep_configure_27>:

                }
            }
            else if (terminal_id == AEC_REF_OUTPUT_TERMINAL1
                     && !op_extra_data->mic_sync_enable)
84200e78:	c8 24       	Null = rMAC - 3;
84200e7a:	85 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e7c <Lc_aec_reference_opmsg_ep_configure_28>:
84200e7c:	60 f0 cd 88 	Null = M[r4 + 820];
84200e80:	82 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e82 <Lc_aec_reference_opmsg_ep_configure_29>:
            {
                opmgr_override_set_ratematch_enacting(op_extra_data->mic_endpoint,
                                                      (bool) value);
84200e82:	62 f0 a2 88 	r0 = M[r4 + 648];
84200e86:	3b 00       	r1 = r5 + Null;
84200e88:	ff fd 23 f0 	call (m) 0x554a;
84200e8c:	23 e6 
                if(value==(uint32)FALSE)
84200e8e:	38 04       	Null = r5 - Null;
84200e90:	04 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_31;

84200e92 <Lc_aec_reference_opmsg_ep_configure_30>:
                {
                    op_extra_data->mic_rate_enactment = RATEMATCHING_SUPPORT_NONE;
84200e92:	60 f0 cd 8b 	MB[r4 + 461] = Null;
84200e96:	05 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_32;

84200e98 <Lc_aec_reference_opmsg_ep_configure_31>:
                }
                else
                {
                    op_extra_data->mic_rate_enactment = op_extra_data->mic_rate_ability;
84200e98:	61 f0 cc 81 	rMAC = MBS[r4 + 460];
84200e9c:	61 f0 cd 8b 	MB[r4 + 461] = rMAC;

84200ea0 <Lc_aec_reference_opmsg_ep_configure_32>:
                }

                if ((op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW) && (op_extra_data->mic_rate_monitor_op))
84200ea0:	61 f0 cd 81 	rMAC = MBS[r4 + 461];
84200ea4:	88 24       	Null = rMAC - 2;
84200ea6:	0c 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_35;

84200ea8 <Lc_aec_reference_opmsg_ep_configure_33>:
84200ea8:	62 f0 76 88 	r0 = M[r4 + 472];
84200eac:	09 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_35;

84200eae <Lc_aec_reference_opmsg_ep_configure_34>:
                {
                    rate_monitor_op_initialise(op_extra_data->mic_rate_monitor_op,op_extra_data->mic_rate,TRUE,3*MS_PER_SEC);
84200eae:	05 f0 b8 53 	r3 = Null + 3000;
84200eb2:	44 20       	r2 = Null + 1;
84200eb4:	63 f0 72 88 	r1 = M[r4 + 456];
84200eb8:	ff fd 19 f4 	call 0x84204;
84200ebc:	2c ea 

84200ebe <Lc_aec_reference_opmsg_ep_configure_35>:
                }

                if(op_extra_data->mic_sw_rateadj_op)
84200ebe:	62 f0 9d 88 	r0 = M[r4 + 628];
84200ec2:	61 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200ec4 <Lc_aec_reference_opmsg_ep_configure_36>:
                {
                    cbops_rateadjust_passthrough_mode(op_extra_data->mic_sw_rateadj_op,(op_extra_data->mic_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
84200ec4:	03 00       	r1 = Null + Null;
84200ec6:	60 f0 cd 81 	Null = MBS[r4 + 461];
84200eca:	20 f0 43 ce 	if EQ r1 = Null + 1;
84200ece:	ff fd c7 f0 	call (m) 0x19d0a;
84200ed2:	3d e1 
84200ed4:	58 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200ed6 <Lc_aec_reference_opmsg_ep_configure_37>:
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_ADJUSTMENT:
        {
            int svalue = (int)value;
            /*  See BlueCore audio real endpoint function "adjust_audio_rate" for details */
            if(terminal_id == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200ed6:	00 f2 10 f0 	Null = rMAC - 8388608;
84200eda:	00 24 
84200edc:	2a 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_46;

84200ede <Lc_aec_reference_opmsg_ep_configure_38>:
            {
#ifdef AEC_REFERENCE_SPKR_TTP
                if(op_extra_data->spkr_timed_playback_mode)
84200ede:	60 f0 b6 88 	Null = M[r4 + 728];
84200ee2:	51 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200ee4 <Lc_aec_reference_opmsg_ep_configure_39>:
                     * rate adjustment is managed by speaker ttp */
                    break;
                }
#endif /* AEC_REFERENCE_SPKR_TTP */
                /* Send Rate Adjustment to hardware */
                if(op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_HW)
84200ee4:	61 f0 7e 88 	rMAC = M[r4 + 504];
84200ee8:	88 24       	Null = rMAC - 2;
84200eea:	19 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_44;

84200eec <Lc_aec_reference_opmsg_ep_configure_40>:
                {
                    if(op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
84200eec:	71 a8       	rMAC = M[r4 + 68];
84200eee:	4b 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200ef0 <Lc_aec_reference_opmsg_ep_configure_41>:
                    {
                        if((op_extra_data->spkr_rate_monitor_op) && (rate_monitor_op_is_complete(op_extra_data->spkr_rate_monitor_op)))
84200ef0:	62 f0 80 88 	r0 = M[r4 + 512];
84200ef4:	48 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200ef6 <Lc_aec_reference_opmsg_ep_configure_42>:
84200ef6:	ff fd 19 f4 	call 0x842a8;
84200efa:	32 ed 
84200efc:	10 04       	Null = r0 - Null;
84200efe:	43 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200f00 <Lc_aec_reference_opmsg_ep_configure_43>:
                        {
                            op_extra_data->spkr_rate_adjustment = svalue;
84200f00:	3b 00       	r1 = r5 + Null;
84200f02:	63 f0 7d 8e 	M[r4 + 500] = r1;
                            value = op_extra_data->spkr_rate_adjustment;
                            opmgr_override_set_ratematch_adjustment(op_extra_data->spkr_endpoint,
                                                                    (int) value);
84200f06:	62 f0 a3 88 	r0 = M[r4 + 652];
84200f0a:	ff fd 22 f0 	call (m) 0x54b4;
84200f0e:	2b ed 
                            rate_monitor_op_restart(op_extra_data->spkr_rate_monitor_op);
84200f10:	62 f0 80 88 	r0 = M[r4 + 512];
84200f14:	ff fd 19 f4 	call 0x84294;
84200f18:	20 ec 
84200f1a:	35 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200f1c <Lc_aec_reference_opmsg_ep_configure_44>:
                        }
                    }
                }
                else
                {
                    op_extra_data->spkr_rate_adjustment = svalue;
84200f1c:	3b 00       	r1 = r5 + Null;
84200f1e:	63 f0 7d 8e 	M[r4 + 500] = r1;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
                    if(0 != op_extra_data->spkr_ext_rate_adjust_op)
84200f22:	62 f0 a1 88 	r0 = M[r4 + 644];
84200f26:	2f 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200f28 <Lc_aec_reference_opmsg_ep_configure_45>:
                    {

                        /* set the target rate value, this will be ignored if speaker path is doing TTP. */
                        stream_delegate_rate_adjust_set_target_rate(op_extra_data->spkr_ext_rate_adjust_op,
                                                                    op_extra_data->spkr_rate_adjustment);
84200f28:	ff fd 96 f0 	call (m) 0x13d20;
84200f2c:	39 ef 
84200f2e:	2b 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200f30 <Lc_aec_reference_opmsg_ep_configure_46>:
            }
            else if (terminal_id == AEC_REF_OUTPUT_TERMINAL1
                     /* if we are syncing mic to speaker input we shouldn't
                      * receive this message, but ignore it if we received.
                      */
                     && !op_extra_data->mic_sync_enable)
84200f30:	c8 24       	Null = rMAC - 3;
84200f32:	29 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200f34 <Lc_aec_reference_opmsg_ep_configure_47>:
84200f34:	60 f0 cd 88 	Null = M[r4 + 820];
84200f38:	26 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200f3a <Lc_aec_reference_opmsg_ep_configure_48>:
            {
                /* Send Rate Adjustment to hardware */
                if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
84200f3a:	61 f0 cd 81 	rMAC = MBS[r4 + 461];
84200f3e:	88 24       	Null = rMAC - 2;
84200f40:	19 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_53;

84200f42 <Lc_aec_reference_opmsg_ep_configure_49>:
                {
                    if(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1])
84200f42:	b1 88       	rMAC = M[r4 + 8];
84200f44:	20 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200f46 <Lc_aec_reference_opmsg_ep_configure_50>:
                    {
                        if((op_extra_data->mic_rate_monitor_op) && (rate_monitor_op_is_complete(op_extra_data->mic_rate_monitor_op)))
84200f46:	62 f0 76 88 	r0 = M[r4 + 472];
84200f4a:	1d 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200f4c <Lc_aec_reference_opmsg_ep_configure_51>:
84200f4c:	ff fd 19 f4 	call 0x842a8;
84200f50:	3c ea 
84200f52:	10 04       	Null = r0 - Null;
84200f54:	18 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200f56 <Lc_aec_reference_opmsg_ep_configure_52>:
                        {
                            op_extra_data->mic_rate_adjustment = svalue;
84200f56:	3b 00       	r1 = r5 + Null;
84200f58:	63 f0 74 8e 	M[r4 + 464] = r1;
                            value = op_extra_data->mic_rate_adjustment;
                            opmgr_override_set_ratematch_adjustment(op_extra_data->mic_endpoint,
                                                                    (int) value);
84200f5c:	62 f0 a2 88 	r0 = M[r4 + 648];
84200f60:	ff fd 22 f0 	call (m) 0x54b4;
84200f64:	35 ea 
                            rate_monitor_op_restart(op_extra_data->mic_rate_monitor_op);
84200f66:	62 f0 76 88 	r0 = M[r4 + 472];
84200f6a:	ff fd 19 f4 	call 0x84294;
84200f6e:	2a e9 
84200f70:	0a 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200f72 <Lc_aec_reference_opmsg_ep_configure_53>:
                        }
                    }
                }
                else
                {
                    op_extra_data->mic_rate_adjustment = svalue;
84200f72:	3b 00       	r1 = r5 + Null;
84200f74:	63 f0 74 8e 	M[r4 + 464] = r1;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
                    if(0 != op_extra_data->mic_ext_rate_adjust_op)
84200f78:	62 f0 a0 88 	r0 = M[r4 + 640];
84200f7c:	04 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200f7e <Lc_aec_reference_opmsg_ep_configure_54>:
                    {

                        /* set the target rate */
                        stream_delegate_rate_adjust_set_target_rate(op_extra_data->mic_ext_rate_adjust_op,
                                                                    op_extra_data->mic_rate_adjustment);
84200f7e:	ff fd 96 f0 	call (m) 0x13d20;
84200f82:	23 ed 

84200f84 <Lc_aec_reference_opmsg_ep_configure_55>:
            /* break; */
        default:
            return(FALSE);
    }

    return(TRUE);
84200f84:	42 20       	r0 = Null + 1;

84200f86 <Lc_aec_reference_opmsg_ep_configure_56>:
}
84200f86:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200f88:	d8 4c       	rts;

84200f8a <$_aec_reference_opmsg_ep_clock_id>:

   TODO.  Remove OPMSG_COMMON_GET_CLOCK_ID from table and delete this function
*/

bool aec_reference_opmsg_ep_clock_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200f8a:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200f8c:	17 00       	r5 = r0 + Null;
84200f8e:	23 09       	r9 = r2 + Null;
84200f90:	29 09       	r7 = r3 + Null;
    unsigned *resp;
    OP_MSG_REQ *msg = message_data;
    unsigned terminal_id = msg->header.cmd_header.client_id;
84200f92:	3a f0 00 e8 	r8 = M[r1 + Null];
    INT_OP_ID int_id = base_op_get_int_op_id(op_data);
84200f96:	ef fd fa ff 	call (m) 0x4f0;
84200f9a:	3b ea 
84200f9c:	10 09       	r6 = r0 + Null;
     * If the Mic and Spkr share the same clock source then all real terminals
     * share the same rate.
     */

    /* Payload is a single word containing the clock ID */
    resp = xpmalloc(sizeof(unsigned));
84200f9e:	c3 20       	r1 = Null + 3;
84200fa0:	02 21       	r0 = Null + 4;
84200fa2:	ff fd 2c f0 	call (m) 0x67ac;
84200fa6:	2b e0 
84200fa8:	16 00       	r4 = r0 + Null;
    if (!resp)
84200faa:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_clock_id_3;

84200fac <Lc_aec_reference_opmsg_ep_clock_id_2>:
    {
        return FALSE;
84200fac:	02 00       	r0 = Null + Null;
84200fae:	22 6e       	jump (m) Lc_aec_reference_opmsg_ep_clock_id_10;

84200fb0 <Lc_aec_reference_opmsg_ep_clock_id_3>:
    }
    *resp_data = (OP_OPMSG_RSP_PAYLOAD*)resp;
84200fb0:	96 f0 00 ee 	M[r7 + Null] = r4;
    *resp_length = 1;
84200fb4:	41 20       	rMAC = Null + 1;
84200fb6:	b1 f0 00 ee 	M[r9 + Null] = rMAC;
      clock ID will be reported as zero before this operation is called.

      If MIC and SPKR real endpoints are not connected then we report the same clock source.
    */

    if (terminal_id & TERMINAL_SINK_MASK)
84200fba:	40 f0 a1 f0 	rMAC = r8 AND 0x800000;
84200fbe:	00 00 
84200fc0:	16 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200fc2 <Lc_aec_reference_opmsg_ep_clock_id_4>:
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84200fc2:	3a 00       	r0 = r5 + Null;
84200fc4:	ef fd fa ff 	call (m) 0x4e6;
84200fc8:	23 e9 
         * same clock source as the mic then report the same clock source of
         * the op id. If they differ then report op_id and 1 << 7 as the op id
         * is 7 bits long.
         */
        if (!op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1] ||
            !op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
84200fca:	91 88       	rMAC = M[r0 + 8];
84200fcc:	10 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200fce <Lc_aec_reference_opmsg_ep_clock_id_5>:
84200fce:	51 a8       	rMAC = M[r0 + 68];
84200fd0:	0e 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200fd2 <Lc_aec_reference_opmsg_ep_clock_id_6>:
        {
            *resp = int_id;
        }
        else if (opmgr_override_have_same_clock_source(op_extra_data->spkr_endpoint,
                                                       op_extra_data->mic_endpoint))
84200fd2:	23 f0 a2 88 	r1 = M[r0 + 648];
84200fd6:	22 f0 a3 88 	r0 = M[r0 + 652];
84200fda:	ff fd 22 f0 	call (m) 0x54a0;
84200fde:	27 e6 
84200fe0:	10 04       	Null = r0 - Null;
84200fe2:	05 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200fe4 <Lc_aec_reference_opmsg_ep_clock_id_7>:
        {
            *resp = int_id;
        }
        else
        {
            *resp = int_id | (1 << 7);
84200fe4:	40 f8 51 c8 	rMAC = r6 OR 0x80;
84200fe8:	31 ee       	M[r4 + Null] = rMAC;
84200fea:	03 6e       	jump (m) Lc_aec_reference_opmsg_ep_clock_id_9;

84200fec <Lc_aec_reference_opmsg_ep_clock_id_8>:
    {
        /* The sources that this is relevant to is Outputs and Reference. These
         * all have the same clock source. Report default clock source as the
         * op id.
         */
        *resp = int_id;
84200fec:	68 f0 00 ee 	M[r4 + Null] = r6;

84200ff0 <Lc_aec_reference_opmsg_ep_clock_id_9>:
    }

    return TRUE;
84200ff0:	42 20       	r0 = Null + 1;

84200ff2 <Lc_aec_reference_opmsg_ep_clock_id_10>:
}
84200ff2:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200ff4:	d8 4c       	rts;

84200ff6 <$_aec_reference_set_rates>:
 * aec_reference_set_input_output_rates
 * \brief Message handler for SET_SAMPLE_RATES message ID
 * Note: Payload contains input and output rates in 1Hz units.
 */
bool aec_reference_set_rates(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200ff6:	c8 1c       	pushm <FP(=SP), rLink>;
    /* get the input rate from payload */
    unsigned irate  = OPMSG_FIELD_GET(message_data,
                                      OPMSG_AEC_SET_SAMPLE_RATES,
                                      INPUT_RATE);
84200ff8:	d9 88       	rMAC = M[r1 + 12];
84200ffa:	89 c6       	rMAC = rMAC AND 0xffff;

    /* get the output rate from payload */
    unsigned orate  = OPMSG_FIELD_GET(message_data,
                                      OPMSG_AEC_SET_SAMPLE_RATES,
                                      OUTPUT_RATE);
84200ffc:	1b 89       	r1 = M[r1 + 16];
84200ffe:	9c c6       	r2 = r1 AND 0xffff;

    /* Rates needed for creating cbops and for "aec_reference_buffer_details" */
    return aec_reference_update_input_output_rates(op_data, irate, orate);
84201000:	0b 00       	r1 = rMAC + Null;
84201002:	0d f0 25 ee 	call (m) Lc_aec_reference_update_input_output_rates_1;

84201006 <Lc_aec_reference_set_rates_2>:
}
84201006:	c8 48       	popm <FP, rLink>;
84201008:	d8 4c       	rts;

8420100a <$_aec_reference_set_input_output_rates>:
 * aec_reference_set_input_output_rates
 * \brief Message handler for SET_INPUT_OUTPUT_SAMPLE_RATES message ID
 *  Note: Payload contains input and output rates in 25Hz units.
 */
bool aec_reference_set_input_output_rates(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420100a:	c8 1c       	pushm <FP(=SP), rLink>;
    /* get the input rate from payload */
    unsigned irate = 25 * (OPMSG_FIELD_GET(message_data,
                                           OPMSG_AEC_SET_INPUT_OUTPUT_SAMPLE_RATES,
                                           INPUT_RATE));
8420100c:	d9 88       	rMAC = M[r1 + 12];
8420100e:	89 c6       	rMAC = rMAC AND 0xffff;
84201010:	49 46       	rMAC = rMAC * 25 (int);

    /* get the output rate from payload */
    unsigned orate = 25 * (OPMSG_FIELD_GET(message_data,
                                           OPMSG_AEC_SET_INPUT_OUTPUT_SAMPLE_RATES,
                                           OUTPUT_RATE));
84201012:	1b 89       	r1 = M[r1 + 16];
84201014:	9b c6       	r1 = r1 AND 0xffff;
84201016:	5c 46       	r2 = r1 * 25 (int);

    /* Rates needed for creating cbops and for "aec_reference_buffer_details" */
    return aec_reference_update_input_output_rates(op_data, irate, orate);
84201018:	0b 00       	r1 = rMAC + Null;
8420101a:	0d f0 2d ed 	call (m) Lc_aec_reference_update_input_output_rates_1;

8420101e <Lc_aec_reference_set_input_output_rates_2>:
}
8420101e:	c8 48       	popm <FP, rLink>;
84201020:	d8 4c       	rts;

84201022 <$_aec_reference_opmsg_set_ucid>:

    return(TRUE);
}

bool aec_reference_opmsg_set_ucid(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201022:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84201024:	12 09       	r8 = r0 + Null;
84201026:	19 09       	r7 = r1 + Null;
84201028:	27 00       	r5 = r2 + Null;
8420102a:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
8420102c:	ef fd fa ff 	call (m) 0x4e6;
84201030:	3b e5 
84201032:	16 00       	r4 = r0 + Null;
    PS_KEY_TYPE key;
    bool retval;

    patch_fn_shared(aec_reference);

    retval = cpsSetUcidMsgHandler(&op_extra_data->parms_def,message_data,resp_length,resp_data);
84201034:	62 f0 7c 21 	r0 = r4 + 380;
84201038:	45 08       	r3 = r6 + Null;
8420103a:	3c 00       	r2 = r5 + Null;
8420103c:	4b 08       	r1 = r7 + Null;
8420103e:	ef fd fc ff 	call (m) 0x9a6;
84201042:	29 eb 
84201044:	17 00       	r5 = r0 + Null;

    key = MAP_CAPID_UCID_SBID_TO_PSKEYID(op_extra_data->cap_id,op_extra_data->parms_def.ucid,OPMSG_P_STORE_PARAMETER_SUB_ID);
84201046:	61 f0 63 88 	rMAC = M[r4 + 396];
8420104a:	8a c2       	r0 = rMAC AND 0x3f;
8420104c:	12 54       	r0 = r0 LSHIFT 1;
8420104e:	61 f0 5a 88 	rMAC = M[r4 + 360];
84201052:	8b c6       	r1 = rMAC AND 0xffff;
84201054:	9b 55       	r1 = r1 LSHIFT 7;
84201056:	9b 12       	r1 = r1 OR r0;
    ps_entry_read((void*)op_data,key,PERSIST_ANY,ups_params_aec);
84201058:	42 f0 15 f0 	r3 = Null + 69215765;
8420105c:	15 4a 
8420105e:	04 00       	r2 = Null + Null;
84201060:	52 08       	r0 = r8 + Null;
84201062:	ff fd 34 f0 	call (m) 0x7888;
84201066:	27 e1 

    return retval;
84201068:	3a 00       	r0 = r5 + Null;

8420106a <Lc_aec_reference_opmsg_set_ucid_2>:
}
8420106a:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
8420106c:	d8 4c       	rts;

8420106e <$_aec_reference_opmsg_get_ps_id>:

    return TRUE;
}

bool aec_reference_opmsg_get_ps_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420106e:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201070:	1f 00       	r5 = r1 + Null;
84201072:	26 00       	r4 = r2 + Null;
84201074:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84201076:	ef fd fa ff 	call (m) 0x4e6;
8420107a:	31 e3 
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    return cpsGetUcidMsgHandler(&op_extra_data->parms_def,op_extra_data->cap_id,message_data,resp_length,resp_data);
8420107c:	10 1c       	pushm <r6>;
8420107e:	23 f0 5a 88 	r1 = M[r0 + 360];
84201082:	35 00       	r3 = r4 + Null;
84201084:	02 f0 7c 45 	r0 = r0 + 380;
84201088:	3c 00       	r2 = r5 + Null;
8420108a:	ef fd fc ff 	call (m) 0x9c8;
8420108e:	3f e9 
84201090:	7f 4c       	SP = SP + -4;

84201092 <Lc_aec_reference_opmsg_get_ps_id_2>:
}
84201092:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201094:	d8 4c       	rts;

84201096 <$_aec_reference_opmsg_mute_mic_output>:

    return TRUE;
}

bool aec_reference_opmsg_mute_mic_output(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201096:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201098:	1f 00       	r5 = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
8420109a:	ef fd fa ff 	call (m) 0x4e6;
8420109e:	2d e2 
842010a0:	16 00       	r4 = r0 + Null;
    bool mute_enable;

    patch_fn_shared(aec_reference);

    /* read the enable field */
    mute_enable  = (OPMSG_FIELD_GET(message_data, OPMSG_AEC_MUTE_MIC_OUTPUT, ENABLE)) != 0;
842010a2:	f9 88       	rMAC = M[r5 + 12];
842010a4:	07 00       	r5 = Null + Null;
842010a6:	89 c6       	rMAC = rMAC AND 0xffff;
842010a8:	21 f0 47 ce 	if NE r5 = Null + 1;
    L2_DBG_MSG1("ACE REFERENCE muting mic, mute=%d", mute_enable);
842010ac:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842010b0:	88 24       	Null = rMAC - 2;
842010b2:	08 68       	if LT jump (m) Lc_aec_reference_opmsg_mute_mic_output_3;

842010b4 <Lc_aec_reference_opmsg_mute_mic_output_2>:
842010b4:	55 f1 02 f0 	r0 = Null + 357564765;
842010b8:	5d 41 
842010ba:	3b 00       	r1 = r5 + Null;
842010bc:	ef fd fe ff 	call (m) 0xcde;
842010c0:	23 e1 

842010c2 <Lc_aec_reference_opmsg_mute_mic_output_3>:

    if(NULL != op_extra_data->mic_mute_op)
842010c2:	62 f0 78 88 	r0 = M[r4 + 480];
842010c6:	05 60       	if EQ jump (m) Lc_aec_reference_opmsg_mute_mic_output_5;

842010c8 <Lc_aec_reference_opmsg_mute_mic_output_4>:
    {
        /* configure already running mute operator with simple ramping */
        cbops_mute_enable(op_extra_data->mic_mute_op, mute_enable, FALSE);
842010c8:	04 00       	r2 = Null + Null;
842010ca:	3b 00       	r1 = r5 + Null;
842010cc:	11 f0 2b e7 	call (m) $_cbops_mute_enable;

842010d0 <Lc_aec_reference_opmsg_mute_mic_output_5>:
    }

    /* store the last mute config */
    op_extra_data->mic_mute_enable_config = mute_enable;
842010d0:	67 f0 79 8e 	M[r4 + 484] = r5;

    return TRUE;
842010d4:	42 20       	r0 = Null + 1;

842010d6 <Lc_aec_reference_opmsg_mute_mic_output_6>:
}
842010d6:	f2 48       	popm <FP, r4, r5, rLink>;
842010d8:	d8 4c       	rts;

842010da <$_aec_reference_opmsg_set_task_period>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_task_period(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842010da:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842010dc:	17 00       	r5 = r0 + Null;
842010de:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
842010e0:	ef fd fa ff 	call (m) 0x4e6;
842010e4:	27 e0 
842010e6:	10 09       	r6 = r0 + Null;
bool aec_reference_opmsg_set_task_period(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* We cant change this setting while running */
    if (opmgr_op_is_running(op_data))
842010e8:	3a 00       	r0 = r5 + Null;
842010ea:	ff fd 23 f0 	call (m) 0x5700;
842010ee:	37 e0 
842010f0:	10 04       	Null = r0 - Null;
842010f2:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_task_period_3;

842010f4 <Lc_aec_reference_opmsg_set_task_period_2>:
    {
        return FALSE;
842010f4:	02 00       	r0 = Null + Null;
842010f6:	07 6e       	jump (m) Lc_aec_reference_opmsg_set_task_period_4;

842010f8 <Lc_aec_reference_opmsg_set_task_period_3>:
    }

    /* get the task period */
    unsigned task_period = OPMSG_FIELD_GET(message_data, OPMSG_AEC_SET_TASK_PERIOD, TASK_PERIOD);
842010f8:	f1 88       	rMAC = M[r4 + 12];
842010fa:	8b c6       	r1 = rMAC AND 0xffff;

    /* get decimation factor */
    unsigned decim_factor = OPMSG_FIELD_GET(message_data, OPMSG_AEC_SET_TASK_PERIOD, DECIM_FACTOR);
842010fc:	31 89       	rMAC = M[r4 + 16];
842010fe:	8c c6       	r2 = rMAC AND 0xffff;

    return aec_reference_set_task_period(op_extra_data, task_period, decim_factor);
84201100:	42 08       	r0 = r6 + Null;
84201102:	03 4e       	call (m) $_aec_reference_set_task_period;

84201104 <Lc_aec_reference_opmsg_set_task_period_4>:
}
84201104:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201106:	d8 4c       	rts;

84201108 <$_aec_reference_set_task_period>:
 * \param decim_factor decimation factor for sidetone mixing task
 *
 * \return whether the task period update successfully
 */
bool aec_reference_set_task_period(AEC_REFERENCE_OP_DATA *op_extra_data, unsigned task_period, unsigned decim_factor)
{
84201108:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420110a:	17 00       	r5 = r0 + Null;
8420110c:	1e 00       	r4 = r1 + Null;
8420110e:	20 09       	r6 = r2 + Null;

    patch_fn_shared(aec_reference);
    /* check the limits */
    if(task_period > AEC_REFERENCE_MAX_TASK_PERIOD ||
       task_period < AEC_REFERENCE_MIN_TASK_PERIOD)
84201110:	60 f1 88 27 	Null = r4 - 5000;
84201114:	08 f0 8d e0 	if HI jump (m) Lc_aec_reference_set_task_period_3;

84201118 <Lc_aec_reference_set_task_period_2>:
84201118:	60 f0 e8 27 	Null = r4 - 1000;
8420111c:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_set_task_period_4;

84201120 <Lc_aec_reference_set_task_period_3>:
    {
        return FALSE;
84201120:	02 00       	r0 = Null + Null;
84201122:	61 6e       	jump (m) Lc_aec_reference_set_task_period_14;

84201124 <Lc_aec_reference_set_task_period_4>:
    }

    /* see if task period is an integer factor of a second */
    if(0 != (SECOND % task_period))
84201124:	00 f0 a2 f7 	r0 = Null + 1000000;
84201128:	40 42 
8420112a:	ff fd c8 f0 	call (m) 0x1a2ae;
8420112e:	25 ec 
84201130:	10 04       	Null = r0 - Null;
84201132:	f7 63       	if NE jump (m) Lc_aec_reference_set_task_period_3;

84201134 <Lc_aec_reference_set_task_period_5>:
    }

    /* Also we don't expect AEC_REFERENCE task period becoms
     * larger than system kick period
     */
    if(task_period > (unsigned)stream_if_get_system_kick_period())
84201134:	ff fd 38 f0 	call (m) 0x8146;
84201138:	33 e0 
8420113a:	b0 04       	Null = r4 - r0;
8420113c:	f8 ff e5 ef 	if HI jump (m) Lc_aec_reference_set_task_period_3;

84201140 <Lc_aec_reference_set_task_period_6>:

#ifdef AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING
    /* if a decimation factor supplied it should be a factor of
     * task period
     */
    if(decim_factor > 1)
84201140:	80 f0 01 24 	Null = r6 - 1;
84201144:	09 f0 95 e0 	if LS jump (m) Lc_aec_reference_set_task_period_8;

84201148 <Lc_aec_reference_set_task_period_7>:
    {
        if((task_period % decim_factor) != 0)
84201148:	32 00       	r0 = r4 + Null;
8420114a:	43 08       	r1 = r6 + Null;
8420114c:	ff fd c8 f0 	call (m) 0x1a2ae;
84201150:	23 eb 
84201152:	10 04       	Null = r0 - Null;
84201154:	e6 63       	if NE jump (m) Lc_aec_reference_set_task_period_3;

84201156 <Lc__ite_19>:
84201156:	02 6e       	jump (m) Lc_aec_reference_set_task_period_9;

84201158 <Lc_aec_reference_set_task_period_8>:
            return FALSE;
        }
    }
    else
    {
        decim_factor = 1;
84201158:	08 71       	r6 = Null + 1;

8420115a <Lc_aec_reference_set_task_period_9>:
    }
    op_extra_data->task_decim_factor = decim_factor;
8420115a:	78 f0 6a 8e 	M[r5 + 424] = r6;
    op_extra_data->task_decim_counter = 0;
8420115e:	70 f0 6b 8e 	M[r5 + 428] = Null;
    op_extra_data->kick_period = task_period / decim_factor;
84201162:	32 00       	r0 = r4 + Null;
84201164:	43 08       	r1 = r6 + Null;
84201166:	ff fd c8 f0 	call (m) 0x1a290;
8420116a:	2b e9 
8420116c:	72 f0 67 8e 	M[r5 + 412] = r0;
    op_extra_data->kick_period_frac = frac_div(op_extra_data->kick_period, SECOND);
84201170:	00 f0 a1 f7 	rMAC = Null + 1000000;
84201174:	40 42 
84201176:	7f f2 1f d9 	rMACB = r0 ASHIFT -1 (56bit);
8420117a:	00 f1 9f cd 	Div = rMACB / rMAC;
8420117e:	c2 4c       	r0 = DivResult;
84201180:	72 f0 68 8e 	M[r5 + 416] = r0;
    op_extra_data->kick_period = task_period;
    decim_factor = 1;
#endif /* AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING */

    /* All are fine, set the task period*/
    op_extra_data->task_period = task_period;
84201184:	76 f0 64 8e 	M[r5 + 400] = r4;
    op_extra_data->task_frequency = (unsigned)SECOND/task_period;
84201188:	33 00       	r1 = r4 + Null;
8420118a:	0a 00       	r0 = rMAC + Null;
8420118c:	ff fd c8 f0 	call (m) 0x1a290;
84201190:	25 e8 
84201192:	72 f0 65 8e 	M[r5 + 404] = r0;
    op_extra_data->task_period_frac = frac_div(task_period, SECOND);
84201196:	00 f0 a1 f7 	rMAC = Null + 1000000;
8420119a:	40 42 
8420119c:	7f f6 1f d9 	rMACB = r4 ASHIFT -1 (56bit);
842011a0:	00 f1 9f cd 	Div = rMACB / rMAC;
842011a4:	c2 4c       	r0 = DivResult;
842011a6:	72 f0 66 8e 	M[r5 + 408] = r0;
     * stage does an upsample by a factor of 2.1.
     * 48000.0 (fs in : 21/10) --> 100800.0 (fs internal : 7/16) --> 44100.0 (fs out)
     *
     * (2*task period) @100800
     */
    op_extra_data->resampler_temp_buffer_size = frac_mult(100800, 2*op_extra_data->task_period_frac) + 4;
842011aa:	c3 f0 c0 51 	r1 = Null + 100800;
842011ae:	12 54       	r0 = r0 LSHIFT 1;
842011b0:	2f f3 42 c9 	r0 = r1 * r0 (frac);
842011b4:	11 21       	rMAC = r0 + 4;
842011b6:	71 f0 33 8e 	M[r5 + 204] = rMAC;
    op_extra_data->resampler_temp_buffer_size = MAX(op_extra_data->resampler_temp_buffer_size,
                                                        AEC_REF_RESAMPLER_TEMP_MIN_BUF_SIZE);
842011ba:	10 f0 cc 24 	Null = rMAC - 204;
842011be:	02 f0 8d e0 	if C jump (m) Lc_aec_reference_set_task_period_11;

842011c2 <Lc_aec_reference_set_task_period_10>:
842011c2:	01 f0 cc 40 	rMAC = Null + 204;
842011c6:	71 f0 33 8e 	M[r5 + 204] = rMAC;

842011ca <Lc_aec_reference_set_task_period_11>:

    L2_DBG_MSG2("AEC REFERENCE: task period set @%dus, decimation factor=%d", task_period, decim_factor);
842011ca:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842011ce:	88 24       	Null = rMAC - 2;
842011d0:	09 68       	if LT jump (m) Lc_aec_reference_set_task_period_13;

842011d2 <Lc_aec_reference_set_task_period_12>:
842011d2:	55 f1 02 f0 	r0 = Null + 357564589;
842011d6:	ad 40 
842011d8:	44 08       	r2 = r6 + Null;
842011da:	33 00       	r1 = r4 + Null;
842011dc:	ef fd fd ff 	call (m) 0xcf2;
842011e0:	37 e8 

842011e2 <Lc_aec_reference_set_task_period_13>:

    return TRUE;
842011e2:	42 20       	r0 = Null + 1;

842011e4 <Lc_aec_reference_set_task_period_14>:
}
842011e4:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842011e6:	d8 4c       	rts;

842011e8 <$_aec_reference_opmsg_enable_mic_sync>:
 *             backend input and output are from same clock
 * Note: the msaage shall not be sent when any MIC/OUTPUT/REF
 *       terminal is connected.
 */
bool aec_reference_opmsg_enable_mic_sync(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842011e8:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842011ea:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
842011ec:	ef fd f9 ff 	call (m) 0x4e6;
842011f0:	3b e7 
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    patch_fn_shared(aec_reference);

    if((NULL != op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1]) ||
       (NULL != op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL]) ||
       (NULL != op_extra_data->input_stream[AEC_REF_OUTPUT_TERMINAL1]))
842011f2:	91 88       	rMAC = M[r0 + 8];
842011f4:	05 62       	if NE jump (m) Lc_aec_reference_opmsg_enable_mic_sync_4;

842011f6 <Lc_aec_reference_opmsg_enable_mic_sync_2>:
842011f6:	11 a8       	rMAC = M[r0 + 64];
842011f8:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_enable_mic_sync_4;

842011fa <Lc_aec_reference_opmsg_enable_mic_sync_3>:
842011fa:	d1 88       	rMAC = M[r0 + 12];
842011fc:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_enable_mic_sync_5;

842011fe <Lc_aec_reference_opmsg_enable_mic_sync_4>:
    {
        /* This message can be handled only if MIC and REF are disconnected */
        return FALSE;
842011fe:	02 00       	r0 = Null + Null;
84201200:	13 6e       	jump (m) Lc_aec_reference_opmsg_enable_mic_sync_8;

84201202 <Lc_aec_reference_opmsg_enable_mic_sync_5>:
    }

    /* read the enable field */
    op_extra_data->mic_sync_enable = (OPMSG_FIELD_GET(message_data, OPMSG_AEC_SAME_INPUT_OUTPUT_CLOCK_SOURCE, SAME_CLK_SRC)) != 0;
84201202:	f1 88       	rMAC = M[r4 + 12];
84201204:	03 00       	r1 = Null + Null;
84201206:	89 c6       	rMAC = rMAC AND 0xffff;
84201208:	21 f0 43 ce 	if NE r1 = Null + 1;
8420120c:	23 f0 cd 8e 	M[r0 + 820] = r1;
    L2_DBG_MSG1("ACE REFERENCE input-output use same clock: ", op_extra_data->mic_sync_enable);
84201210:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84201214:	88 24       	Null = rMAC - 2;
84201216:	07 68       	if LT jump (m) Lc_aec_reference_opmsg_enable_mic_sync_7;

84201218 <Lc_aec_reference_opmsg_enable_mic_sync_6>:
84201218:	55 f1 02 f0 	r0 = Null + 357564545;
8420121c:	81 40 
8420121e:	ef fd fd ff 	call (m) 0xcde;
84201222:	21 e6 

84201224 <Lc_aec_reference_opmsg_enable_mic_sync_7>:

    return TRUE;
84201224:	42 20       	r0 = Null + 1;

84201226 <Lc_aec_reference_opmsg_enable_mic_sync_8>:
}
84201226:	f1 48       	popm <FP, r4, rLink>;
84201228:	d8 4c       	rts;

8420122a <$_aec_reference_opmsg_set_buffer_size>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_buffer_size(OPERATOR_DATA *op_data, void *message_data,
                                         unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420122a:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
8420122c:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
8420122e:	ef fd f9 ff 	call (m) 0x4e6;
84201232:	39 e5 
84201234:	10 09       	r6 = r0 + Null;
                                         unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{

    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    /* get the required buffer size */
    unsigned buffer_size = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE, BUFFER_SIZE);
84201236:	f1 88       	rMAC = M[r4 + 12];
84201238:	8f c6       	r5 = rMAC AND 0xffff;
    /* get the sink terminals that need configuration */
    unsigned sinks = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE,
                                     SINKS);
8420123a:	31 89       	rMAC = M[r4 + 16];
    /* get the source terminals that need configuration */
    unsigned sources = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE,
                                       SOURCES);
8420123c:	19 f0 01 00 	r7 = rMAC AND 0x1;
84201240:	71 89       	rMAC = M[r4 + 20];

    /* Output buffer size is allowd to change if none of outputs are connected,
     * Note: We allow buffer size change while the operator is running, only the
     * relevant path must be not running.
     */
    if(sources != 0)
84201242:	49 c1       	rMAC = rMAC AND 0x8;
84201244:	16 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_10;

84201246 <Lc_aec_reference_opmsg_set_buffer_size_2>:
    {
        unsigned idx;

        /* No output must be connected */
        for(idx = 0; idx<MAX_NUMBER_MICS; idx++)
84201246:	02 00       	r0 = Null + Null;
84201248:	04 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_4;

8420124a <Lc_aec_reference_opmsg_set_buffer_size_3>:
    }
}

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
8420124a:	10 25       	Null = r0 - 4;
8420124c:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_opmsg_set_buffer_size_5;

84201250 <Lc_aec_reference_opmsg_set_buffer_size_4>:
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84201250:	d3 20       	r1 = r0 + 3;
84201252:	02 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_6;

84201254 <Lc_aec_reference_opmsg_set_buffer_size_5>:
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84201254:	53 22       	r1 = r0 + 9;

84201256 <Lc_aec_reference_opmsg_set_buffer_size_6>:
        {
            if(NULL != op_extra_data->output_stream[OutputTerminalByIndex(idx)])
84201256:	84 f0 40 20 	r2 = r6 + 64;
8420125a:	5b 54       	r1 = r1 LSHIFT 2;
8420125c:	e3 e8       	r1 = M[r2 + r1];
8420125e:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_8;

84201260 <Lc_aec_reference_opmsg_set_buffer_size_7>:
            {
                return FALSE;
84201260:	02 00       	r0 = Null + Null;
84201262:	39 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_24;

84201264 <Lc_aec_reference_opmsg_set_buffer_size_8>:
    if(sources != 0)
    {
        unsigned idx;

        /* No output must be connected */
        for(idx = 0; idx<MAX_NUMBER_MICS; idx++)
84201264:	52 20       	r0 = r0 + 1;
84201266:	10 26       	Null = r0 - 8;
84201268:	f1 65       	if NC jump (m) Lc_aec_reference_opmsg_set_buffer_size_3;

8420126a <Lc_aec_reference_opmsg_set_buffer_size_9>:
            {
                return FALSE;
            }
        }
        /* Also REFERENCE must also be disconnected */
        if(NULL != op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL])
8420126a:	82 f0 10 88 	r0 = M[r6 + 64];
8420126e:	f9 63       	if NE jump (m) Lc_aec_reference_opmsg_set_buffer_size_7;

84201270 <Lc_aec_reference_opmsg_set_buffer_size_10>:

    /* Input buffer size is allowd to change if none of inputs are connected,
     * Note: We allow buffer size change while the operator is running, only the
     * relevant path must be not running.
     */
    if(sinks != 0)
84201270:	0f f9 00 c2 	Null = r7 - Null;
84201274:	10 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_17;

84201276 <Lc_aec_reference_opmsg_set_buffer_size_11>:
    {
        unsigned idx;

        /* No input must be connected */
        for(idx = 0; idx < MAX_NUMBER_SPEAKERS; idx++)
84201276:	02 00       	r0 = Null + Null;
84201278:	04 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_13;

8420127a <Lc_aec_reference_opmsg_set_buffer_size_12>:
        {
            if(NULL != op_extra_data->input_stream[SpeakerInputTerminalByIndex(idx)])
8420127a:	90 24       	Null = r0 - 2;
8420127c:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_opmsg_set_buffer_size_14;

84201280 <Lc_aec_reference_opmsg_set_buffer_size_13>:
84201280:	13 00       	r1 = r0 + Null;
84201282:	02 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_15;

84201284 <Lc_aec_reference_opmsg_set_buffer_size_14>:
84201284:	13 21       	r1 = r0 + 4;

84201286 <Lc_aec_reference_opmsg_set_buffer_size_15>:
84201286:	5b 54       	r1 = r1 LSHIFT 2;
84201288:	83 f0 03 e8 	r1 = M[r6 + r1];
8420128c:	ea 63       	if NE jump (m) Lc_aec_reference_opmsg_set_buffer_size_7;

8420128e <Lc_aec_reference_opmsg_set_buffer_size_16>:
    if(sinks != 0)
    {
        unsigned idx;

        /* No input must be connected */
        for(idx = 0; idx < MAX_NUMBER_SPEAKERS; idx++)
8420128e:	52 20       	r0 = r0 + 1;
84201290:	10 26       	Null = r0 - 8;
84201292:	f4 65       	if NC jump (m) Lc_aec_reference_opmsg_set_buffer_size_12;

84201294 <Lc_aec_reference_opmsg_set_buffer_size_17>:
                return FALSE;
            }
        }
    }

    if(sources != 0)
84201294:	08 04       	Null = rMAC - Null;
84201296:	0e 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_20;

84201298 <Lc_aec_reference_opmsg_set_buffer_size_18>:
    {
        /* set the output buffer size */
        op_extra_data->output_buffer_size = buffer_size;
84201298:	87 f0 ce 8e 	M[r6 + 824] = r5;
        L2_DBG_MSG1("AEC_REFERENCE: minimum output buffer size set to %d words ", buffer_size);
8420129c:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842012a0:	88 24       	Null = rMAC - 2;
842012a2:	08 68       	if LT jump (m) Lc_aec_reference_opmsg_set_buffer_size_20;

842012a4 <Lc_aec_reference_opmsg_set_buffer_size_19>:
842012a4:	55 f1 02 f0 	r0 = Null + 357564648;
842012a8:	e8 40 
842012aa:	3b 00       	r1 = r5 + Null;
842012ac:	ef fd fd ff 	call (m) 0xcde;
842012b0:	33 e1 

842012b2 <Lc_aec_reference_opmsg_set_buffer_size_20>:
    }

    if(sinks != 0)
842012b2:	0f f9 00 c2 	Null = r7 - Null;
842012b6:	0e 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_23;

842012b8 <Lc_aec_reference_opmsg_set_buffer_size_21>:
    {
        op_extra_data->input_buffer_size = buffer_size;
842012b8:	87 f0 cf 8e 	M[r6 + 828] = r5;
        L2_DBG_MSG1("AEC_REFERENCE: minimum input buffer size set to %d words ", buffer_size);
842012bc:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842012c0:	88 24       	Null = rMAC - 2;
842012c2:	08 68       	if LT jump (m) Lc_aec_reference_opmsg_set_buffer_size_23;

842012c4 <Lc_aec_reference_opmsg_set_buffer_size_22>:
842012c4:	55 f1 02 f0 	r0 = Null + 357564707;
842012c8:	23 41 
842012ca:	3b 00       	r1 = r5 + Null;
842012cc:	ef fd fd ff 	call (m) 0xcde;
842012d0:	33 e0 

842012d2 <Lc_aec_reference_opmsg_set_buffer_size_23>:
    }

    return TRUE;
842012d2:	42 20       	r0 = Null + 1;

842012d4 <Lc_aec_reference_opmsg_set_buffer_size_24>:
}
842012d4:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842012d6:	d8 4c       	rts;

842012d8 <$_aec_reference_update_sidetone_status>:
    if((op_extra_data->params.OFFSET_CONFIG & AEC_REFERENCE_CONFIG_SIDETONE_DISABLE) == 0)
    {
        /* a sidetone path will be formed whenever
         * we have both speaker and mic paths
         */
        op_extra_data->using_sidetone = SIDETONE_ENABLE_FLAG;
842012d8:	21 f0 34 88 	rMAC = M[r0 + 208];
842012dc:	03 00       	r1 = Null + Null;
842012de:	49 c1       	rMAC = rMAC AND 0x8;
842012e0:	a0 f0 43 ce 	if EQ r1 = Null + 2;
842012e4:	23 f0 9a 8e 	M[r0 + 616] = r1;
        /* User doesn't want sidetone at all */
        op_extra_data->using_sidetone = 0;
    }

    /* see if we need sidetone */
    if((op_extra_data->num_mic_channels > 0) && (op_extra_data->num_spkr_channels > 0))
842012e8:	20 f0 85 88 	Null = M[r0 + 532];
842012ec:	0a 60       	if EQ jump (m) Lc_aec_reference_update_sidetone_status_4;

842012ee <Lc_aec_reference_update_sidetone_status_2>:
842012ee:	20 f0 84 88 	Null = M[r0 + 528];
842012f2:	07 60       	if EQ jump (m) Lc_aec_reference_update_sidetone_status_4;

842012f4 <Lc_aec_reference_update_sidetone_status_3>:
    {
        op_extra_data->using_sidetone |= SIDETONE_MIC_SPKR_FLAG;
842012f4:	21 f0 9a 88 	rMAC = M[r0 + 616];
842012f8:	09 c8       	rMAC = rMAC OR 0x1;
842012fa:	21 f0 9a 8e 	M[r0 + 616] = rMAC;
842012fe:	06 6e       	jump (m) Lc_aec_reference_update_sidetone_status_5;

84201300 <Lc_aec_reference_update_sidetone_status_4>:
    }
    else
    {
        op_extra_data->using_sidetone &= SIDETONE_ENABLE_FLAG;
84201300:	21 f0 9a 88 	rMAC = M[r0 + 616];
84201304:	49 c0       	rMAC = rMAC AND 0x2;
84201306:	21 f0 9a 8e 	M[r0 + 616] = rMAC;

8420130a <Lc_aec_reference_update_sidetone_status_5>:
8420130a:	d8 4c       	rts;

8420130c <$_aec_reference_spkr_check_external_rate_adjust_op>:
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 *
 */
void aec_reference_spkr_check_external_rate_adjust_op(AEC_REFERENCE_OP_DATA *op_extra_data)
{
8420130c:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
8420130e:	16 00       	r4 = r0 + Null;
    EXT_OP_ID op_id = 0;
84201310:	18 de       	M[FP + 12] = Null;

    patch_fn_shared(aec_reference);
    if (opmgr_override_get_rate_adjust_op(op_extra_data->spkr_endpoint, &op_id) && op_id != 0)
84201312:	c3 10       	r1 = FP + 12;
84201314:	62 f0 a3 88 	r0 = M[r4 + 652];
84201318:	ff fd 20 f0 	call (m) 0x547c;
8420131c:	25 eb 
8420131e:	10 04       	Null = r0 - Null;
84201320:	18 60       	if EQ jump (m) Lc_aec_reference_spkr_check_external_rate_adjust_op_5;

84201322 <Lc_aec_reference_spkr_check_external_rate_adjust_op_2>:
84201322:	1a d8       	r0 = M[FP + 12];
84201324:	16 60       	if EQ jump (m) Lc_aec_reference_spkr_check_external_rate_adjust_op_5;

84201326 <Lc_aec_reference_spkr_check_external_rate_adjust_op_3>:
    {
        /* Speaker graph will use an external RATE_ADJUST operator for
         * performing rate adjustment.
         */
        op_extra_data->spkr_ext_rate_adjust_op = op_id;
84201326:	62 f0 a1 8e 	M[r4 + 644] = r0;

        /* if we have standalone rate adjust, we will use it, even
         * if spkr is able to use HW warping */
        op_extra_data->spkr_rate_ability = RATEMATCHING_SUPPORT_SW;
8420132a:	41 20       	rMAC = Null + 1;
8420132c:	61 f0 7c 8e 	M[r4 + 496] = rMAC;

        /* Speaker path will use this, so not in pass-through mode */
        stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->spkr_ext_rate_adjust_op, FALSE);
84201330:	03 00       	r1 = Null + Null;
84201332:	ff fd 95 f0 	call (m) 0x13d48;
84201336:	37 e0 

        L2_DBG_MSG1("AEC_REFERENCE: Speaker path will use standalone rate adjust: opid=0x%x", op_id);
84201338:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420133c:	88 24       	Null = rMAC - 2;
8420133e:	0b 68       	if LT jump (m) Lc_aec_reference_spkr_check_external_rate_adjust_op_6;

84201340 <Lc_aec_reference_spkr_check_external_rate_adjust_op_4>:
84201340:	1b d8       	r1 = M[FP + 12];
84201342:	55 f1 02 f0 	r0 = Null + 357564832;
84201346:	a0 41 
84201348:	ef fd fc ff 	call (m) 0xcde;
8420134c:	37 ec 
8420134e:	03 6e       	jump (m) Lc_aec_reference_spkr_check_external_rate_adjust_op_6;

84201350 <Lc_aec_reference_spkr_check_external_rate_adjust_op_5>:

        return;
    }

    /* No external operator found or needed */
    op_extra_data->spkr_ext_rate_adjust_op = 0;
84201350:	60 f0 a1 8e 	M[r4 + 644] = Null;

84201354 <Lc_aec_reference_spkr_check_external_rate_adjust_op_6>:

    return;
}
84201354:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
84201356:	d8 4c       	rts;

84201358 <$_aec_reference_mic_check_external_rate_adjust_op>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 *
 * \return TRUE if there is a standalone rate adjust operator linked to the microphne path
 */
void aec_reference_mic_check_external_rate_adjust_op(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201358:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
8420135a:	16 00       	r4 = r0 + Null;
    EXT_OP_ID op_id = 0;
8420135c:	18 de       	M[FP + 12] = Null;

    patch_fn_shared(aec_reference);
    if (opmgr_override_get_rate_adjust_op(op_extra_data->mic_endpoint, &op_id) && op_id != 0)
8420135e:	c3 10       	r1 = FP + 12;
84201360:	62 f0 a2 88 	r0 = M[r4 + 648];
84201364:	ff fd 20 f0 	call (m) 0x547c;
84201368:	39 e8 
8420136a:	10 04       	Null = r0 - Null;
8420136c:	23 60       	if EQ jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_7;

8420136e <Lc_aec_reference_mic_check_external_rate_adjust_op_2>:
8420136e:	1a d8       	r0 = M[FP + 12];
84201370:	21 60       	if EQ jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_7;

84201372 <Lc_aec_reference_mic_check_external_rate_adjust_op_3>:
    {
        /* If we have been told to synchronise mic to speaker input then
         * we shouldn't have been told to use standalone rate adjust.
         */
        PL_ASSERT(!op_extra_data->mic_sync_enable);
84201372:	60 f0 cd 88 	Null = M[r4 + 820];
84201376:	09 60       	if EQ jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_5;

84201378 <Lc_aec_reference_mic_check_external_rate_adjust_op_4>:
84201378:	03 f0 20 61 	r1 = Null + 4384;
8420137c:	02 f0 13 60 	r0 = Null + 4115;
84201380:	ff fd ae f0 	call (m) 0x16ff0;
84201384:	31 e3 
84201386:	18 6e       	jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_8;

84201388 <Lc_aec_reference_mic_check_external_rate_adjust_op_5>:

        /* Microphone graph will use an external RATE_ADJUST operator for
         * performing rate adjustment.
         */
        op_extra_data->mic_ext_rate_adjust_op = op_id;
84201388:	62 f0 a0 8e 	M[r4 + 640] = r0;

        /* if we have standalone rate adjust, we will use it, even
         * if mic is able to use HW warping */
        op_extra_data->mic_rate_ability = RATEMATCHING_SUPPORT_SW;
8420138c:	41 20       	rMAC = Null + 1;
8420138e:	61 f0 cc 8b 	MB[r4 + 460] = rMAC;

        /* Microphone path will use this, so not in pass-through mode */
        stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->mic_ext_rate_adjust_op, FALSE);
84201392:	03 00       	r1 = Null + Null;
84201394:	ff fd 94 f0 	call (m) 0x13d48;
84201398:	35 ed 

        L2_DBG_MSG1("AEC_REFERENCE: Microphone path will use standalone rate adjust: opid=0x%x", op_id);
8420139a:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420139e:	88 24       	Null = rMAC - 2;
842013a0:	0b 68       	if LT jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_8;

842013a2 <Lc_aec_reference_mic_check_external_rate_adjust_op_6>:
842013a2:	1b d8       	r1 = M[FP + 12];
842013a4:	55 f1 02 f0 	r0 = Null + 357564903;
842013a8:	e7 41 
842013aa:	ef fd fc ff 	call (m) 0xcde;
842013ae:	35 e9 
842013b0:	03 6e       	jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_8;

842013b2 <Lc_aec_reference_mic_check_external_rate_adjust_op_7>:

        return;
    }

    /* No external operator found or needed */
    op_extra_data->mic_ext_rate_adjust_op = 0;
842013b2:	60 f0 a0 8e 	M[r4 + 640] = Null;

842013b6 <Lc_aec_reference_mic_check_external_rate_adjust_op_8>:

    return;
}
842013b6:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
842013b8:	d8 4c       	rts;

842013ba <$_aec_reference_opmsg_set_ttp_latency>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_ttp_latency(OPERATOR_DATA *op_data, void *message_data,
                                     unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842013ba:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842013bc:	17 00       	r5 = r0 + Null;
842013be:	18 09       	r6 = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
842013c0:	ef fd f8 ff 	call (m) 0x4e6;
842013c4:	27 e9 
842013c6:	16 00       	r4 = r0 + Null;
                                     unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* We cant change this setting while running */
    if (opmgr_op_is_running(op_data))
842013c8:	3a 00       	r0 = r5 + Null;
842013ca:	ff fd 21 f0 	call (m) 0x5700;
842013ce:	37 e9 
842013d0:	10 04       	Null = r0 - Null;
842013d2:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_ttp_latency_3;

842013d4 <Lc_aec_reference_opmsg_set_ttp_latency_2>:
    {
        return FALSE;
842013d4:	02 00       	r0 = Null + Null;
842013d6:	15 6e       	jump (m) Lc_aec_reference_opmsg_set_ttp_latency_4;

842013d8 <Lc_aec_reference_opmsg_set_ttp_latency_3>:
    }

    /* get the latency from payload */
    op_extra_data->mic_target_latency = ttp_get_msg_latency(message_data);
842013d8:	42 08       	r0 = r6 + Null;
842013da:	ff fd c0 f0 	call (m) 0x194d2;
842013de:	39 e7 
842013e0:	13 00       	r1 = r0 + Null;
842013e2:	63 f0 c7 8e 	M[r4 + 796] = r1;

    /* configure latency */
    ttp_configure_latency(op_extra_data->mic_time_to_play, op_extra_data->mic_target_latency);
842013e6:	62 f0 c8 88 	r0 = M[r4 + 800];
842013ea:	ff fd c0 f0 	call (m) 0x195a8;
842013ee:	3f ed 

    /* receiving this message (with latenct != 0) will enable metadata generation */
    op_extra_data->mic_metadata_enable = op_extra_data->mic_target_latency != 0;
842013f0:	01 00       	rMAC = Null + Null;
842013f2:	60 f0 c7 88 	Null = M[r4 + 796];
842013f6:	21 f0 41 ce 	if NE rMAC = Null + 1;
842013fa:	61 f0 c6 8e 	M[r4 + 792] = rMAC;

    return TRUE;
842013fe:	42 20       	r0 = Null + 1;

84201400 <Lc_aec_reference_opmsg_set_ttp_latency_4>:
}
84201400:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201402:	d8 4c       	rts;

84201404 <$_aec_reference_opmsg_set_ttp_params>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_ttp_params(OPERATOR_DATA *op_data, void *message_data,
                                    unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201404:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
84201406:	17 00       	r5 = r0 + Null;
84201408:	18 09       	r6 = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
8420140a:	ef fd f8 ff 	call (m) 0x4e6;
8420140e:	3d e6 
84201410:	16 00       	r4 = r0 + Null;
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    ttp_params params;

    /* We cant change this setting while running */
    if (opmgr_op_is_running(op_data))
84201412:	3a 00       	r0 = r5 + Null;
84201414:	ff fd 21 f0 	call (m) 0x5700;
84201418:	2d e7 
8420141a:	10 04       	Null = r0 - Null;
8420141c:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_ttp_params_3;

8420141e <Lc_aec_reference_opmsg_set_ttp_params_2>:
    {
        return FALSE;
8420141e:	02 00       	r0 = Null + Null;
84201420:	0d 6e       	jump (m) Lc_aec_reference_opmsg_set_ttp_params_4;

84201422 <Lc_aec_reference_opmsg_set_ttp_params_3>:
    }

    /* configure ttp params */
    ttp_get_msg_params(&params, message_data);
84201422:	42 11       	r0 = FP + 20;
84201424:	43 08       	r1 = r6 + Null;
84201426:	ff fd c0 f0 	call (m) 0x19552;
8420142a:	2d e9 
    ttp_configure_params(op_extra_data->mic_time_to_play, &params);
8420142c:	43 11       	r1 = FP + 20;
8420142e:	62 f0 c8 88 	r0 = M[r4 + 800];
84201432:	ff fd c0 f0 	call (m) 0x195f0;
84201436:	3f ed 

    return TRUE;
84201438:	42 20       	r0 = Null + 1;

8420143a <Lc_aec_reference_opmsg_set_ttp_params_4>:
}
8420143a:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
8420143c:	d8 4c       	rts;

8420143e <$_aec_reference_opmsg_set_latency_limits>:
 * aec_reference_opmsg_set_latency_limits
 * \brief message handler to set ttp latency limits for mic output channels
 */
bool aec_reference_opmsg_set_latency_limits(OPERATOR_DATA *op_data, void *message_data,
                                        unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420143e:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
84201440:	1f 00       	r5 = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84201442:	ef fd f8 ff 	call (m) 0x4e6;
84201446:	25 e5 
84201448:	16 00       	r4 = r0 + Null;
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    TIME_INTERVAL min_latency, max_latency;

    /* get the limits from the message payload and configure the time to play limits */
    ttp_get_msg_latency_limits(message_data, &min_latency, &max_latency);
8420144a:	44 11       	r2 = FP + 20;
8420144c:	03 11       	r1 = FP + 16;
8420144e:	3a 00       	r0 = r5 + Null;
84201450:	ff fd c0 f0 	call (m) 0x19508;
84201454:	39 e5 
    ttp_configure_latency_limits(op_extra_data->mic_time_to_play, min_latency, max_latency);
84201456:	2c d8       	r2 = M[FP + 20];
84201458:	23 d8       	r1 = M[FP + 16];
8420145a:	62 f0 c8 88 	r0 = M[r4 + 800];
8420145e:	ff fd c0 f0 	call (m) 0x195c8;
84201462:	2b eb 

    return TRUE;
84201464:	42 20       	r0 = Null + 1;

84201466 <Lc_aec_reference_opmsg_set_latency_limits_2>:
}
84201466:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
84201468:	d8 4c       	rts;

8420146a <$_aec_reference_mic_generate_metadata_with_ttp>:
 * \brief generates metadata for microphone output channels
 * \param op_extra_data Pointer to AEC_REFERENCE operator specific data
 * \param samples number of samples in the to-be-copied chunk
 */
void aec_reference_mic_generate_metadata_with_ttp(AEC_REFERENCE_OP_DATA *op_extra_data, unsigned samples)
{
8420146a:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
8420146c:	10 09       	r6 = r0 + Null;
8420146e:	8b f0 c3 88 	r9 = M[r6 + 780];
84201472:	1f 00       	r5 = r1 + Null;
    unsigned b4idx, afteridx;
    tCbuffer *met_buf = op_extra_data->mic_metadata_buffer;

    patch_fn_shared(aec_reference);
    /* no update needed if no new samples arrived */
    if(samples == 0)
84201474:	6b 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_12;

84201476 <Lc_aec_reference_mic_generate_metadata_with_ttp_2>:
    {
        return;
    }

    /* if previous tag was incomplete, we need first to complete the tag */
    if(op_extra_data->mic_metadata_tag_left_words > 0)
84201476:	81 f0 c4 88 	rMAC = M[r6 + 784];
8420147a:	15 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_6;

8420147c <Lc_aec_reference_mic_generate_metadata_with_ttp_3>:
    {
        /* last written tag was incomplete, we keep adding
         * Null tag until full length of incomplete tag is
         * covered.
         */
        unsigned null_tag_len = op_extra_data->mic_metadata_tag_left_words;
8420147c:	0e 00       	r4 = rMAC + Null;
        if(null_tag_len > samples)
8420147e:	c8 05       	Null = rMAC - r5;
84201480:	09 f0 87 e0 	if LS jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_5;

84201484 <Lc_aec_reference_mic_generate_metadata_with_ttp_4>:
        {
            null_tag_len = samples;
84201484:	3e 00       	r4 = r5 + Null;

84201486 <Lc_aec_reference_mic_generate_metadata_with_ttp_5>:
        }

        /* append Null tag, with length = null_tag_len */
        b4idx = 0;
        afteridx = null_tag_len*OCTETS_PER_SAMPLE;
84201486:	75 54       	r3 = r4 LSHIFT 2;
        buff_metadata_append(met_buf, NULL, b4idx, afteridx);
84201488:	04 00       	r2 = Null + Null;
8420148a:	03 00       	r1 = Null + Null;
8420148c:	5a 08       	r0 = r9 + Null;
8420148e:	ff fd 99 f0 	call (m) 0x147b8;
84201492:	2b e9 

        /* update amount left */
        op_extra_data->mic_metadata_tag_left_words -= null_tag_len;
84201494:	81 f0 c4 88 	rMAC = M[r6 + 784];
84201498:	89 05       	rMAC = rMAC - r4;
8420149a:	81 f0 c4 8e 	M[r6 + 784] = rMAC;
        samples -= null_tag_len;
8420149e:	bf 05       	r5 = r5 - r4;
        if(samples == 0)
842014a0:	38 04       	Null = r5 - Null;
842014a2:	54 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_12;

842014a4 <Lc_aec_reference_mic_generate_metadata_with_ttp_6>:
        }
    }

    /* create a new tag to append */
    b4idx = 0;
    afteridx = samples*OCTETS_PER_SAMPLE;
842014a4:	7a 54       	r0 = r5 LSHIFT 2;
842014a6:	42 de       	M[FP + 32] = r0;
    mtag = buff_metadata_new_tag();
842014a8:	ff fd 98 f0 	call (m) 0x1454e;
842014ac:	27 e5 
842014ae:	16 00       	r4 = r0 + Null;
    if (mtag != NULL)
842014b0:	46 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_11;

842014b2 <Lc_aec_reference_mic_generate_metadata_with_ttp_7>:
    {
        /* calculating time of arrival for first sample of the tag,
         * we do that by looking how many samples are in the mic buffer,
         * this could be short by up to 1 sample as our reading isn't aligned.
         */
        TIME current_time = time_get_time();
842014b2:	ff fd 26 f0 	call (m) 0x6100;
842014b6:	2f e2 
842014b8:	12 09       	r8 = r0 + Null;

        /* amount of data in the mic buffer */
        unsigned amount_in_buffer =
            cbuffer_calc_amount_data_in_words(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1]);
842014ba:	82 f0 02 88 	r0 = M[r6 + 8];
842014be:	ff fd c4 f1 	call (m) 0x39dd4;
842014c2:	37 e8 

        /* convert samples to time,
         * Note: some inaccuracies because of rate adjustment, but jitter will be filtered by ttp filter */
        INTERVAL time_passed = (INTERVAL) (((uint48)(amount_in_buffer)*SECOND)/op_extra_data->mic_rate) +
            (INTERVAL) (((uint48)(samples)*SECOND)/op_extra_data->output_rate);
842014c4:	00 f0 42 ff 	rMAC = r0 * 0.00023283064365386962890625 (UU);
842014c8:	40 f2 11 cc 
842014cc:	84 f0 72 88 	r2 = M[r6 + 456];
842014d0:	05 00       	r3 = Null + Null;
842014d2:	09 50       	rMAC = rMAC LSHIFT -1 (56bit);
842014d4:	00 f1 d3 c8 	r1 = rMAC LSHIFT 0;
842014d8:	ca 57       	r0 = rMAC LSHIFT 32;
842014da:	ff fd c6 f0 	call (m) 0x1a208;
842014de:	2f e9 
842014e0:	11 09       	r7 = r0 + Null;
842014e2:	00 f0 42 ff 	rMAC = r5 * 0.00023283064365386962890625 (UU);
842014e6:	40 f7 11 cc 
842014ea:	84 f0 71 88 	r2 = M[r6 + 452];
842014ee:	05 00       	r3 = Null + Null;
842014f0:	09 50       	rMAC = rMAC LSHIFT -1 (56bit);
842014f2:	00 f1 d3 c8 	r1 = rMAC LSHIFT 0;
842014f6:	ca 57       	r0 = rMAC LSHIFT 32;
842014f8:	ff fd c6 f0 	call (m) 0x1a208;
842014fc:	31 e8 
842014fe:	11 00       	rMAC = r0 + Null;
84201500:	49 0c       	rMAC = r7 + rMAC;

        TIME time_of_arrival = time_sub(current_time, time_passed);
84201502:	1f fa 03 c2 	r1 = r8 - rMAC;

        /* see if we have minimum amount for tag */
        if(samples >= op_extra_data->mic_metadata_min_tag_len)
84201506:	82 f0 c5 88 	r0 = M[r6 + 788];
8420150a:	b8 04       	Null = r5 - r0;
8420150c:	04 64       	if NC jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_9;

8420150e <Lc_aec_reference_mic_generate_metadata_with_ttp_8>:
        {
            /* we have enough new samples to append a complete tag */
            mtag->length = samples*OCTETS_PER_SAMPLE;
8420150e:	7a 54       	r0 = r5 LSHIFT 2;
84201510:	f2 8e       	M[r4 + 12] = r0;
84201512:	08 6e       	jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_10;

84201514 <Lc_aec_reference_mic_generate_metadata_with_ttp_9>:
             * new complete tag, we append a new tag with
             * minimum length, this tag is incomplete and
             * will be completed in next calls when we receive
             * new samples by appending Null tags.
             */
            mtag->length = op_extra_data->mic_metadata_min_tag_len*OCTETS_PER_SAMPLE;
84201514:	52 54       	r0 = r0 LSHIFT 2;
84201516:	f2 8e       	M[r4 + 12] = r0;
            op_extra_data->mic_metadata_tag_left_words = op_extra_data->mic_metadata_min_tag_len - samples;
84201518:	81 f0 c5 88 	rMAC = M[r6 + 788];
8420151c:	c9 05       	rMAC = rMAC - r5;
8420151e:	81 f0 c4 8e 	M[r6 + 784] = rMAC;

84201522 <Lc_aec_reference_mic_generate_metadata_with_ttp_10>:
        }

        ttp_status status;
        ttp_update_ttp(op_extra_data->mic_time_to_play, time_of_arrival,
                       mtag->length/OCTETS_PER_SAMPLE, &status);
84201522:	45 12       	r3 = FP + 36;
84201524:	f2 88       	r0 = M[r4 + 12];
84201526:	54 50       	r2 = r0 LSHIFT -2;
84201528:	82 f0 c8 88 	r0 = M[r6 + 800];
8420152c:	ff fd c0 f0 	call (m) 0x1962e;
84201530:	23 e8 
        /* Populate the metadata tag from the TTP status */
        ttp_utils_populate_tag(mtag, &status);
84201532:	43 12       	r1 = FP + 36;
84201534:	32 00       	r0 = r4 + Null;
84201536:	ef fd fb ff 	call (m) 0xbe6;
8420153a:	31 e5 

8420153c <Lc_aec_reference_mic_generate_metadata_with_ttp_11>:
    }
    /* append generated metadata to the output buffer */
    buff_metadata_append(met_buf, mtag, b4idx, afteridx);
8420153c:	04 00       	r2 = Null + Null;
8420153e:	33 00       	r1 = r4 + Null;
84201540:	5a 08       	r0 = r9 + Null;
84201542:	45 d8       	r3 = M[FP + 32];
84201544:	ff fd 99 f0 	call (m) 0x147b8;
84201548:	35 e3 

8420154a <Lc_aec_reference_mic_generate_metadata_with_ttp_12>:
}
8420154a:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420154c:	d8 4c       	rts;

8420154e <$_aec_reference_set_mic_gains>:
    return TRUE;
}


void aec_reference_set_mic_gains(OPERATOR_DATA *op_data)
{
8420154e:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84201550:	12 09       	r8 = r0 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84201552:	ef fd f7 ff 	call (m) 0x4e6;
84201556:	35 ec 
84201558:	11 09       	r7 = r0 + Null;


void aec_reference_set_mic_gains(OPERATOR_DATA *op_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned i, *lpadcgains = (unsigned*)&op_extra_data->params.OFFSET_ADC_GAIN1;
8420155a:	97 f0 d4 20 	r5 = r7 + 212;

    patch_fn_shared(aec_reference);

    for(i=0;i<MAX_NUMBER_MICS;i++)
8420155e:	06 00       	r4 = Null + Null;
84201560:	16 6e       	jump (m) Lc_aec_reference_set_mic_gains_6;

84201562 <Lc_aec_reference_set_mic_gains_2>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201562:	31 22       	rMAC = r4 + 8;

84201564 <Lc_aec_reference_set_mic_gains_3>:
        if(op_extra_data->input_stream[MicrophoneTerminalByIndex(i)])
        {
            uint32 config_value = (uint32)(lpadcgains[i]);
            opmgr_override_set_ep_gain(opmgr_override_get_endpoint(op_data,
                                       MicrophoneTerminalByIndex(i) | TERMINAL_SINK_MASK),
                                       config_value);
84201564:	08 f0 00 f0 	r1 = rMAC OR 0x800000;
84201568:	00 f1 53 c8 
8420156c:	52 08       	r0 = r8 + Null;
8420156e:	ff fd 1f f0 	call (m) 0x546c;
84201572:	3f e7 
84201574:	43 08       	r1 = r6 + Null;
84201576:	ff fd 1f f0 	call (m) 0x551e;
8420157a:	29 ed 

8420157c <Lc_aec_reference_set_mic_gains_4>:
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned i, *lpadcgains = (unsigned*)&op_extra_data->params.OFFSET_ADC_GAIN1;

    patch_fn_shared(aec_reference);

    for(i=0;i<MAX_NUMBER_MICS;i++)
8420157c:	76 20       	r4 = r4 + 1;
8420157e:	3f 21       	r5 = r5 + 4;
84201580:	30 26       	Null = r4 - 8;
84201582:	02 f0 a7 e0 	if C jump (m) Lc_aec_reference_set_mic_gains_11;

84201586 <Lc_aec_reference_set_mic_gains_5>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
84201586:	30 25       	Null = r4 - 4;
84201588:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_set_mic_gains_7;

8420158c <Lc_aec_reference_set_mic_gains_6>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
8420158c:	b2 20       	r0 = r4 + 2;
8420158e:	02 6e       	jump (m) Lc_aec_reference_set_mic_gains_8;

84201590 <Lc_aec_reference_set_mic_gains_7>:
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201590:	32 22       	r0 = r4 + 8;

84201592 <Lc_aec_reference_set_mic_gains_8>:
    {
        if(op_extra_data->input_stream[MicrophoneTerminalByIndex(i)])
84201592:	52 54       	r0 = r0 LSHIFT 2;
84201594:	91 f0 02 e8 	rMAC = M[r7 + r0];
84201598:	f2 61       	if EQ jump (m) Lc_aec_reference_set_mic_gains_4;

8420159a <Lc_aec_reference_set_mic_gains_9>:
        {
            uint32 config_value = (uint32)(lpadcgains[i]);
8420159a:	78 f0 00 e8 	r6 = M[r5 + Null];
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
8420159e:	30 25       	Null = r4 - 4;
842015a0:	f2 ff c3 ef 	if C jump (m) Lc_aec_reference_set_mic_gains_2;

842015a4 <Lc_aec_reference_set_mic_gains_10>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
842015a4:	b1 20       	rMAC = r4 + 2;
842015a6:	df 6f       	jump (m) Lc_aec_reference_set_mic_gains_3;

842015a8 <Lc_aec_reference_set_mic_gains_11>:
            opmgr_override_set_ep_gain(opmgr_override_get_endpoint(op_data,
                                       MicrophoneTerminalByIndex(i) | TERMINAL_SINK_MASK),
                                       config_value);
        }
    }
}
842015a8:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842015aa:	d8 4c       	rts;

842015ac <$_aec_reference_cleanup>:
 * Note: This function is the same as aec_reference_cleanup_graphs
 *       except that it will reset the entire channel status so any new attempt
 *       to build the graphs will rebuild everything from scratch.
 */
void aec_reference_cleanup(OPERATOR_DATA *op_data)
{
842015ac:	f1 1c       	pushm <FP(=SP), r4, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
842015ae:	ef fd f7 ff 	call (m) 0x4e6;
842015b2:	39 e9 
842015b4:	16 00       	r4 = r0 + Null;
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    /* cleanup all the graphs */
    aec_reference_cleanup_graphs(op_extra_data);
842015b6:	06 f0 29 ef 	call (m) $_aec_reference_cleanup_graphs;

    /* reset channel status, so any new trying
     * of building graphs will rebuild every thing
     * from scratch
     */
    op_extra_data->channel_status = 0;
842015ba:	60 f0 83 8e 	M[r4 + 524] = Null;

842015be <Lc_aec_reference_cleanup_2>:
}
842015be:	f1 48       	popm <FP, r4, rLink>;
842015c0:	d8 4c       	rts;

842015c2 <$_build_mic_graph>:
 *        whenever there is a change in microphone channel status.
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool build_mic_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
842015c2:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
842015c4:	10 09       	r6 = r0 + Null;
    cbops_graph *mic_graph;
    cbops_op *op_ptr;
    unsigned i, num_mics = op_extra_data->num_mic_channels,j,num_io;
842015c6:	8a f0 85 88 	r8 = M[r6 + 532];
    unsigned* idxs;
    unsigned  out_idx,intern_idx;
    bool sidetone_enabled = (op_extra_data->using_sidetone&SIDETONE_ENABLE_FLAG) != 0;
842015ca:	81 f0 9a 88 	rMAC = M[r6 + 616];
842015ce:	02 00       	r0 = Null + Null;
842015d0:	49 c0       	rMAC = rMAC AND 0x2;
842015d2:	21 f0 42 ce 	if NE r0 = Null + 1;
842015d6:	42 de       	M[FP + 32] = r0;
842015d8:	13 00       	r1 = r0 + Null;
       aec_reference_mic_spkr_include_sidetone.

    **********************************************************************/

    /* see if we need a MIC path */
    if(!build_mic_graph_is_required(op_extra_data, sidetone_enabled))
842015da:	42 08       	r0 = r6 + Null;
842015dc:	0a f0 3f e3 	call (m) Lc_build_mic_graph_is_required_1;
842015e0:	10 04       	Null = r0 - Null;
842015e2:	7f 60       	if EQ jump (m) Lc_build_mic_graph_19;

842015e4 <Lc_build_mic_graph_2>:
       MIC Internal
       SIDETONE OUT
    */

    out_idx    = num_mics;
    intern_idx = out_idx;
842015e4:	51 09       	r7 = r8 + Null;
    num_io     = 2*num_mics;
842015e6:	00 fa d6 d8 	r4 = r8 LSHIFT 1;

    /* if sidetone enabled reserve indexes for mic sidetone process,
     * the process will insert later if required.
     */
    if(sidetone_enabled)
842015ea:	41 d8       	rMAC = M[FP + 32];
842015ec:	7c 60       	if EQ jump (m) Lc_build_mic_graph_20;

842015ee <Lc_build_mic_graph_3>:
    {
        /* Need internal buffer between input and output */
        intern_idx = num_io;
842015ee:	31 09       	r7 = r4 + Null;
        num_io    += num_mics;
842015f0:	56 0c       	r4 = r8 + r4;

        /* sidetone path input */
        op_extra_data->mic_st_input_idx = intern_idx;
842015f2:	89 f0 96 8e 	M[r6 + 600] = r7;

        /* sidetone output */
        op_extra_data->mic_st_idx = num_io;
842015f6:	86 f0 94 8e 	M[r6 + 592] = r4;

        /* one extra io for sidetone, could be unused*/
        num_io++;
842015fa:	76 20       	r4 = r4 + 1;
842015fc:	88 6e       	jump (m) Lc_build_mic_graph_25;

842015fe <Lc_build_mic_graph_4>:
                goto aFailed;
            }
            rate_monitor_op_initialise(op_ptr,op_extra_data->mic_rate,TRUE,3*MS_PER_SEC);
        }
    }
    else if (!opmgr_override_is_locally_clocked(op_extra_data->mic_endpoint))
842015fe:	82 f0 a2 88 	r0 = M[r6 + 648];
84201602:	ff fd 1f f0 	call (m) 0x5496;
84201606:	35 e4 
84201608:	10 04       	Null = r0 - Null;
8420160a:	18 62       	if NE jump (m) Lc_build_mic_graph_8;

8420160c <Lc_build_mic_graph_5>:
    {
        /* With SW rate adjustment we need rate monitor if mic isn't locally clocked */
        op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, 0);
8420160c:	82 f0 65 88 	r0 = M[r6 + 404];
84201610:	03 00       	r1 = Null + Null;
84201612:	ff fd b4 f1 	call (m) 0x37e4c;
84201616:	3b e1 
84201618:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
8420161a:	9b 60       	if EQ jump (m) Lc_build_mic_graph_30;

8420161c <Lc_build_mic_graph_6>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->mic_rate, FALSE,
                                   100*MILLISECOND/MILLISECOND);
8420161c:	05 f0 64 40 	r3 = Null + 100;
84201620:	83 f0 72 88 	r1 = M[r6 + 456];
84201624:	04 00       	r2 = Null + Null;
84201626:	ff fd 15 f4 	call 0x84204;
8420162a:	3e ee 

8420162c <Lc_build_mic_graph_7>:
    }
    if(NULL != op_ptr)
    {
        /* insert rate monitor op into the graph */
        op_extra_data->mic_rate_monitor_op = op_ptr;
8420162c:	86 f0 76 8e 	M[r6 + 472] = r4;
        cbops_append_operator_to_graph(mic_graph,op_ptr);
84201630:	33 00       	r1 = r4 + Null;
84201632:	5a 08       	r0 = r9 + Null;
84201634:	ff fd c4 f0 	call (m) 0x19f16;
84201638:	23 e7 

8420163a <Lc_build_mic_graph_8>:
    /* Handle input */
    if (op_extra_data->mic_rate_ability == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
        && (0 == op_extra_data->mic_ext_rate_adjust_op)
#endif
        )
8420163a:	81 f0 cc 81 	rMAC = MBS[r6 + 460];
8420163e:	48 24       	Null = rMAC - 1;
84201640:	78 62       	if NE jump (m) Lc_build_mic_graph_28;

84201642 <Lc_build_mic_graph_9>:
84201642:	80 f0 a0 88 	Null = M[r6 + 640];
84201646:	75 62       	if NE jump (m) Lc_build_mic_graph_28;

84201648 <Lc_build_mic_graph_10>:
    {
        /* Apply Software Rate Adjustment */
        op_ptr = create_sw_rate_adj_op(num_mics, idxs, &idxs[intern_idx],
                                       CBOPS_RATEADJUST_COEFFS,
                                       &op_extra_data->mic_rate_adjustment, op_extra_data->mic_shift);
84201648:	81 f0 7a 88 	rMAC = M[r6 + 488];
8420164c:	09 1c       	pushm <rMAC>;
8420164e:	01 f0 d0 ff 	push r6 + 464;
84201652:	18 cf 
84201654:	85 2a       	r3 = Null + 26;
84201656:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
8420165a:	4c d8       	r2 = M[FP + 36];
8420165c:	23 00       	r1 = r2 + Null;
8420165e:	14 01       	r2 = r0 + r2;
84201660:	52 08       	r0 = r8 + Null;
84201662:	ff fd c3 f0 	call (m) 0x19c66;
84201666:	25 e0 
84201668:	7e 4c       	SP = SP + -8;
8420166a:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
8420166c:	72 60       	if EQ jump (m) Lc_build_mic_graph_30;

8420166e <Lc_build_mic_graph_11>:
        {
            goto aFailed;
        }

        op_extra_data->mic_sw_rateadj_op=op_ptr;
8420166e:	86 f0 9d 8e 	M[r6 + 628] = r4;
        cbops_rateadjust_passthrough_mode(op_ptr,(op_extra_data->mic_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
84201672:	03 00       	r1 = Null + Null;
84201674:	80 f0 cd 81 	Null = MBS[r6 + 461];
84201678:	20 f0 43 ce 	if EQ r1 = Null + 1;
8420167c:	ff fd c3 f0 	call (m) 0x19d0a;
84201680:	2f e4 

84201682 <Lc_build_mic_graph_12>:

        cbops_append_operator_to_graph(mic_graph,op_ptr);
84201682:	33 00       	r1 = r4 + Null;
84201684:	5a 08       	r0 = r9 + Null;
84201686:	ff fd c4 f0 	call (m) 0x19f16;
8420168a:	31 e4 

        /* Early DC remove on mic path. Before Sidetone split so the signal split
           to the speaker doesn't have DC */
        op_ptr = create_dc_remove_op(num_mics, &idxs[intern_idx], &idxs[intern_idx]);
8420168c:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
84201690:	4b d8       	r1 = M[FP + 36];
84201692:	d3 00       	r1 = r0 + r1;
84201694:	1c 00       	r2 = r1 + Null;
84201696:	52 08       	r0 = r8 + Null;
84201698:	ff fd 69 f1 	call (m) 0x2e980;
8420169c:	29 e7 
8420169e:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
842016a0:	58 60       	if EQ jump (m) Lc_build_mic_graph_30;

842016a2 <Lc_build_mic_graph_13>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
842016a2:	33 00       	r1 = r4 + Null;
842016a4:	5a 08       	r0 = r9 + Null;
842016a6:	ff fd c4 f0 	call (m) 0x19f16;
842016aa:	31 e3 

842016ac <Lc_build_mic_graph_14>:
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
    }

	if(sidetone_enabled)
842016ac:	41 d8       	rMAC = M[FP + 32];
842016ae:	03 60       	if EQ jump (m) Lc_build_mic_graph_16;

842016b0 <Lc_build_mic_graph_15>:
	{
        /* mic sidetone path will be inserted after last operator in inputsubgraph.*/
        op_extra_data->mic_st_point = op_ptr;
842016b0:	86 f0 98 8e 	M[r6 + 608] = r4;

842016b4 <Lc_build_mic_graph_16>:
	}

    /* check if output subgraph is needed */
    if(!op_extra_data->mic_graph_no_output)
842016b4:	80 f0 db 88 	Null = M[r6 + 876];
842016b8:	0c 62       	if NE jump (m) Lc_build_mic_graph_18;

842016ba <Lc_build_mic_graph_17>:
        /* append mic output subgraph */
        if(!build_mic_graph_add_output_subgraph(op_extra_data,
                                                idxs,
                                                intern_idx,
                                                out_idx,
                                                sidetone_enabled))
842016ba:	41 d8       	rMAC = M[FP + 32];
842016bc:	09 1c       	pushm <rMAC>;
842016be:	55 08       	r3 = r8 + Null;
842016c0:	4c 08       	r2 = r7 + Null;
842016c2:	42 08       	r0 = r6 + Null;
842016c4:	4b d8       	r1 = M[FP + 36];
842016c6:	09 f0 29 ee 	call (m) Lc_build_mic_graph_add_output_subgraph_1;
842016ca:	7f 4c       	SP = SP + -4;
842016cc:	10 04       	Null = r0 - Null;
842016ce:	41 60       	if EQ jump (m) Lc_build_mic_graph_30;

842016d0 <Lc_build_mic_graph_18>:
        {
            goto aFailed;
        }
    }

    pfree(idxs);
842016d0:	4a d8       	r0 = M[FP + 36];
842016d2:	ff fd 29 f0 	call (m) 0x68d8;
842016d6:	27 e0 

    /* Each mic input has a corresponding output,
     * so it's safe to purge all channels now
     */
    aec_ref_purge_mics(mic_graph,num_mics);
842016d8:	53 08       	r1 = r8 + Null;
842016da:	5a 08       	r0 = r9 + Null;
842016dc:	10 f0 37 e7 	call (m) $_aec_ref_purge_mics;

842016e0 <Lc_build_mic_graph_19>:

    /* see if we need a MIC path */
    if(!build_mic_graph_is_required(op_extra_data, sidetone_enabled))
    {
        /* No need to build mic graph */
        return TRUE;
842016e0:	42 20       	r0 = Null + 1;
842016e2:	91 6e       	jump (m) Lc_build_mic_graph_50;

842016e4 <Lc_build_mic_graph_20>:

        /* one extra io for sidetone, could be unused*/
        num_io++;
    }
    else if ((op_extra_data->mic_rate_ability == RATEMATCHING_SUPPORT_SW) &&
             (op_extra_data->mic_rate != op_extra_data->output_rate))
842016e4:	81 f0 cc 81 	rMAC = MBS[r6 + 460];
842016e8:	48 24       	Null = rMAC - 1;
842016ea:	0a 62       	if NE jump (m) Lc_build_mic_graph_23;

842016ec <Lc_build_mic_graph_21>:
842016ec:	81 f0 72 88 	rMAC = M[r6 + 456];
842016f0:	82 f0 71 88 	r0 = M[r6 + 452];
842016f4:	88 04       	Null = rMAC - r0;
842016f6:	0b 60       	if EQ jump (m) Lc_build_mic_graph_25;

842016f8 <Lc_build_mic_graph_22>:
    {
        /* Need internal buffer between input and output */
        intern_idx = num_io;
842016f8:	31 09       	r7 = r4 + Null;
        num_io    += num_mics;
842016fa:	56 0c       	r4 = r8 + r4;
842016fc:	08 6e       	jump (m) Lc_build_mic_graph_25;

842016fe <Lc_build_mic_graph_23>:
    }
    else if (op_extra_data->mic_rate!=op_extra_data->output_rate)
842016fe:	81 f0 72 88 	rMAC = M[r6 + 456];
84201702:	82 f0 71 88 	r0 = M[r6 + 452];
84201706:	88 04       	Null = rMAC - r0;
84201708:	02 60       	if EQ jump (m) Lc_build_mic_graph_25;

8420170a <Lc_build_mic_graph_24>:
    {
        /* No ratematching or sidetone.  Just resampling  */
        intern_idx = 0;
8420170a:	01 09       	r7 = Null + Null;

8420170c <Lc_build_mic_graph_25>:
    }

    idxs = create_default_indexes(num_io);
8420170c:	32 00       	r0 = r4 + Null;
8420170e:	ff fd c4 f0 	call (m) 0x19fe6;
84201712:	39 e6 
84201714:	4a de       	M[FP + 36] = r0;
    if(idxs == NULL)
84201716:	11 00       	rMAC = r0 + Null;
84201718:	20 60       	if EQ jump (m) Lc_build_mic_graph_31;

8420171a <Lc_build_mic_graph_26>:
    {
        return(FALSE);
    }

    /* Allocate mic graph */
    mic_graph = cbops_alloc_graph(num_io);
8420171a:	32 00       	r0 = r4 + Null;
8420171c:	ff fd c3 f0 	call (m) 0x19de0;
84201720:	25 e6 
84201722:	13 09       	r9 = r0 + Null;
    if(!mic_graph)
84201724:	16 60       	if EQ jump (m) Lc_build_mic_graph_30;

84201726 <Lc_build_mic_graph_27>:
    {
        goto aFailed;
    }
    op_extra_data->mic_graph = mic_graph;
84201726:	8b f0 75 8e 	M[r6 + 468] = r9;

    /* Setup MIC input Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
8420172a:	07 00       	r5 = Null + Null;
8420172c:	06 00       	r4 = Null + Null;
8420172e:	1a 6e       	jump (m) Lc_build_mic_graph_33;

84201730 <Lc_build_mic_graph_28>:
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);

    }
    else if(intern_idx != 0)
84201730:	0f f9 00 c2 	Null = r7 - Null;
84201734:	bc 61       	if EQ jump (m) Lc_build_mic_graph_14;

84201736 <Lc_build_mic_graph_29>:
    {
        /* Otherwise, just copy data to next section */
        op_ptr = create_shift_op(num_mics, idxs, &idxs[intern_idx], op_extra_data->mic_shift);
84201736:	85 f0 7a 88 	r3 = M[r6 + 488];
8420173a:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
8420173e:	4c d8       	r2 = M[FP + 36];
84201740:	23 00       	r1 = r2 + Null;
84201742:	14 01       	r2 = r0 + r2;
84201744:	52 08       	r0 = r8 + Null;
84201746:	ff fd 68 f1 	call (m) 0x2e942;
8420174a:	3d ef 
8420174c:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
8420174e:	9a 63       	if NE jump (m) Lc_build_mic_graph_12;

84201750 <Lc_build_mic_graph_30>:

    return(TRUE);
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building mic graph, Failed!");

    pfree(idxs);
84201750:	4a d8       	r0 = M[FP + 36];
84201752:	ff fd 28 f0 	call (m) 0x68d8;
84201756:	27 ec 

84201758 <Lc_build_mic_graph_31>:
    }

    idxs = create_default_indexes(num_io);
    if(idxs == NULL)
    {
        return(FALSE);
84201758:	02 00       	r0 = Null + Null;
8420175a:	55 6e       	jump (m) Lc_build_mic_graph_50;

8420175c <Lc_build_mic_graph_32>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
8420175c:	30 25       	Null = r4 - 4;
8420175e:	02 f0 89 e0 	if C jump (m) Lc_build_mic_graph_34;

84201762 <Lc_build_mic_graph_33>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
84201762:	b2 20       	r0 = r4 + 2;
84201764:	02 6e       	jump (m) Lc_build_mic_graph_35;

84201766 <Lc_build_mic_graph_34>:
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201766:	32 22       	r0 = r4 + 8;

84201768 <Lc_build_mic_graph_35>:

    /* Setup MIC input Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
    {
        /* MIC inputs may not be consecutive */
        tCbuffer *buffer_ptr_src = op_extra_data->input_stream[MicrophoneTerminalByIndex(j)];
84201768:	52 54       	r0 = r0 LSHIFT 2;

        if(buffer_ptr_src != NULL)
8420176a:	85 f0 02 e8 	r3 = M[r6 + r0];
8420176e:	0c 60       	if EQ jump (m) Lc_build_mic_graph_39;

84201770 <Lc_build_mic_graph_36>:
        {
            if(i < num_mics)
84201770:	af f7 00 c2 	Null = r5 - r8;
84201774:	02 f0 91 e0 	if C jump (m) Lc_build_mic_graph_38;

84201778 <Lc_build_mic_graph_37>:
            {
                /* Inputs */
                cbops_set_input_io_buffer(mic_graph, i, 0, buffer_ptr_src);
84201778:	04 00       	r2 = Null + Null;
8420177a:	3b 00       	r1 = r5 + Null;
8420177c:	5a 08       	r0 = r9 + Null;
8420177e:	ff fd c3 f0 	call (m) 0x19e7c;
84201782:	3f e7 

84201784 <Lc_build_mic_graph_38>:
            }
            i++;
84201784:	7f 20       	r5 = r5 + 1;

84201786 <Lc_build_mic_graph_39>:
        goto aFailed;
    }
    op_extra_data->mic_graph = mic_graph;

    /* Setup MIC input Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
84201786:	76 20       	r4 = r4 + 1;
84201788:	30 26       	Null = r4 - 8;
8420178a:	e9 65       	if NC jump (m) Lc_build_mic_graph_32;

8420178c <Lc_build_mic_graph_40>:
            }
            i++;
        }
    }
    /* expect to have exactly num_mics mics connected */
    PL_ASSERT(i==num_mics);
8420178c:	af f7 00 c2 	Null = r5 - r8;
84201790:	09 60       	if EQ jump (m) Lc_build_mic_graph_42;

84201792 <Lc_build_mic_graph_41>:
84201792:	03 f0 6f 43 	r1 = Null + 879;
84201796:	02 f0 13 60 	r0 = Null + 4115;
8420179a:	ff fd ac f0 	call (m) 0x16ff0;
8420179e:	37 e2 
842017a0:	32 6e       	jump (m) Lc_build_mic_graph_50;

842017a2 <Lc_build_mic_graph_42>:

    if(intern_idx > out_idx)
842017a2:	af f9 00 c2 	Null = r7 - r8;
842017a6:	09 f0 a9 e0 	if LS jump (m) Lc_build_mic_graph_46;

842017aa <Lc_build_mic_graph_43>:
    {
        for(i=0;i<num_mics;i++)
842017aa:	06 00       	r4 = Null + Null;
842017ac:	87 f0 84 20 	r5 = r6 + 132;

842017b0 <Lc_build_mic_graph_44>:
842017b0:	af f6 00 c2 	Null = r4 - r8;
842017b4:	02 f0 9b e0 	if C jump (m) Lc_build_mic_graph_46;

842017b8 <Lc_build_mic_graph_45>:
        {
            cbops_set_internal_io_buffer(mic_graph,intern_idx+i,intern_idx,op_extra_data->scratch_bufs[i]);
842017b8:	3d e8       	r3 = M[r5 + Null];
842017ba:	9f f6 03 c0 	r1 = r4 + r7;
842017be:	4c 08       	r2 = r7 + Null;
842017c0:	5a 08       	r0 = r9 + Null;
842017c2:	ff fd c3 f0 	call (m) 0x19ee4;
842017c6:	23 e9 
    /* expect to have exactly num_mics mics connected */
    PL_ASSERT(i==num_mics);

    if(intern_idx > out_idx)
    {
        for(i=0;i<num_mics;i++)
842017c8:	76 20       	r4 = r4 + 1;
842017ca:	3f 21       	r5 = r5 + 4;
842017cc:	f2 6f       	jump (m) Lc_build_mic_graph_44;

842017ce <Lc_build_mic_graph_46>:
        {
            cbops_set_internal_io_buffer(mic_graph,intern_idx+i,intern_idx,op_extra_data->scratch_bufs[i]);
        }
    }

    op_extra_data->mic_rate_adjustment = 0;
842017ce:	80 f0 74 8e 	M[r6 + 464] = Null;

    /* create rate monitor op if required */
    op_ptr = NULL;
842017d2:	06 00       	r4 = Null + Null;
    if (op_extra_data->mic_rate_ability == RATEMATCHING_SUPPORT_HW)
842017d4:	81 f0 cc 81 	rMAC = MBS[r6 + 460];
842017d8:	88 24       	Null = rMAC - 2;
842017da:	12 63       	if NE jump (m) Lc_build_mic_graph_4;

842017dc <Lc_build_mic_graph_47>:
    {
        /* With HW rate adjustmen we always need rate monitor,
         * except when we are syncing MIC to REF.
         */
        if(!op_extra_data->mic_sync_enable)
842017dc:	80 f0 cd 88 	Null = M[r6 + 820];
842017e0:	2d 63       	if NE jump (m) Lc_build_mic_graph_8;

842017e2 <Lc_build_mic_graph_48>:
        {
            op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, 0);
842017e2:	82 f0 65 88 	r0 = M[r6 + 404];
842017e6:	03 00       	r1 = Null + Null;
842017e8:	ff fd b3 f1 	call (m) 0x37e4c;
842017ec:	25 e3 
842017ee:	16 00       	r4 = r0 + Null;
            if(!op_ptr)
842017f0:	b0 61       	if EQ jump (m) Lc_build_mic_graph_30;

842017f2 <Lc_build_mic_graph_49>:
            {
                goto aFailed;
            }
            rate_monitor_op_initialise(op_ptr,op_extra_data->mic_rate,TRUE,3*MS_PER_SEC);
842017f2:	05 f0 b8 53 	r3 = Null + 3000;
842017f6:	44 20       	r2 = Null + 1;
842017f8:	83 f0 72 88 	r1 = M[r6 + 456];
842017fc:	ff fd 15 f4 	call 0x84204;
84201800:	28 e0 
84201802:	15 6f       	jump (m) Lc_build_mic_graph_7;

84201804 <Lc_build_mic_graph_50>:
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building mic graph, Failed!");

    pfree(idxs);
    return(FALSE);
}
84201804:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201806:	d8 4c       	rts;

84201808 <$_build_spkr_graph>:
 *       depending on the connections and microphone state, however they
 *       aren't included by this function, instead they are added to the
 *       speaker graph later.
 */
bool build_spkr_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201808:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
8420180a:	42 de       	M[FP + 32] = r0;
8420180c:	11 00       	rMAC = r0 + Null;
    cbops_op    *overrid_op_ptr;
    unsigned    num_io;
    tCbuffer    *buffer_ptr;
    unsigned    *idxs;
    unsigned    out_indx,intern_ins_idx,intern_rs_idx,intern_rm_idx;
    unsigned    spkr_channel_status = GetSpkrChannelStatus(op_extra_data);
8420180e:	12 f0 83 88 	r0 = M[rMAC + 524];
84201812:	21 f1 f0 1f 	rMAC = r0 AND 0x3ff0;
         "Sidetone Mix" is added/removed to/from the graph by aec_reference_mic_spkr_include_sidetone function.
         "Reference sub-path" is added/removed to/from the graph by aec_reference_spkr_include_ref_path function.

    **********************************************************************/
    /* Is there a Speaker path */
    if(!(op_extra_data->channel_status&CHAN_STATE_SPKR_MASK))
84201816:	22 f0 f0 0f 	r0 = r0 AND 0xff0;
8420181a:	46 60       	if EQ jump (m) Lc_build_spkr_graph_10;

8420181c <Lc_build_spkr_graph_2>:
    {
        return(TRUE);
    }

    /* Determine IO configuration */
    num_spkrs  = op_extra_data->num_spkr_channels;
8420181c:	42 d8       	r0 = M[FP + 32];
8420181e:	2a f0 84 88 	r8 = M[r0 + 528];
84201822:	ea f0 09 8e 	M[FP + 36] = r8;
    num_inputs = op_extra_data->num_spkr_channels;
    if(!(spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA))
84201826:	ca c5       	r0 = rMAC AND 0x1000;
84201828:	43 62       	if NE jump (m) Lc_build_spkr_graph_12;

8420182a <Lc_build_spkr_graph_3>:
    {
        if(spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_MIX)
8420182a:	11 f1 00 00 	rMAC = rMAC AND 0x2000;
8420182e:	3f 60       	if EQ jump (m) Lc_build_spkr_graph_11;

84201830 <Lc_build_spkr_graph_4>:
        {
            /* Multiple inputs, mono output */
            num_spkrs=1;
84201830:	41 20       	rMAC = Null + 1;
84201832:	49 de       	M[FP + 36] = rMAC;
84201834:	3d 6e       	jump (m) Lc_build_spkr_graph_12;

84201836 <Lc_build_spkr_graph_5>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->spkr_rate, TRUE, 3*MS_PER_SEC);
    }
    else if (!opmgr_override_is_locally_clocked(op_extra_data->spkr_endpoint))
84201836:	41 d8       	rMAC = M[FP + 32];
84201838:	12 f0 a3 88 	r0 = M[rMAC + 652];
8420183c:	ff fd 1e f0 	call (m) 0x5496;
84201840:	3b e2 
84201842:	10 04       	Null = r0 - Null;
84201844:	2a 62       	if NE jump (m) Lc_build_spkr_graph_9;

84201846 <Lc_build_spkr_graph_6>:
    {
        /* With SW rate adjustment we need rate monitor if speaker isn't locally clocked */
        op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, 0);
84201846:	41 d8       	rMAC = M[FP + 32];
84201848:	12 f0 65 88 	r0 = M[rMAC + 404];
8420184c:	03 00       	r1 = Null + Null;
8420184e:	ff fd b2 f1 	call (m) 0x37e4c;
84201852:	3f ef 
84201854:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
84201856:	95 60       	if EQ jump (m) Lc_build_spkr_graph_27;

84201858 <Lc_build_spkr_graph_7>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->spkr_rate, FALSE,
                                    100*MILLISECOND/MILLISECOND);
84201858:	05 f0 64 40 	r3 = Null + 100;
8420185c:	41 d8       	rMAC = M[FP + 32];
8420185e:	13 f0 7b 88 	r1 = M[rMAC + 492];
84201862:	04 00       	r2 = Null + Null;
84201864:	ff fd 14 f4 	call 0x84204;
84201868:	20 ed 

8420186a <Lc_build_spkr_graph_8>:
    {
#ifdef AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT
    /* Initialise new amount calculation for speaker buffer */
    cbuffer_calc_new_amount(op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1],
                            &op_extra_data->spkr_last_address,
                            TRUE /* This is an output buffer */);
8420186a:	44 20       	r2 = Null + 1;
8420186c:	41 d8       	rMAC = M[FP + 32];
8420186e:	13 f0 28 23 	r1 = rMAC + 808;
84201872:	4a a8       	r0 = M[rMAC + 68];
84201874:	ff fd c5 f1 	call (m) 0x3a35a;
84201878:	27 e7 

    /* tell rate monitor cbops op to directly use calculated new amount */
    set_rate_monitor_new_amount_ptr(op_ptr, &op_extra_data->spkr_new_amount);
8420187a:	41 d8       	rMAC = M[FP + 32];
8420187c:	13 f0 2c 23 	r1 = rMAC + 812;
84201880:	32 00       	r0 = r4 + Null;
84201882:	ff fd 15 f4 	call 0x842d0;
84201886:	2e e2 
#endif
        /* insert rate monitor op into the graph */
        op_extra_data->spkr_rate_monitor_op = op_ptr;
84201888:	41 d8       	rMAC = M[FP + 32];
8420188a:	16 f0 80 8e 	M[rMAC + 512] = r4;
        cbops_append_operator_to_graph(spkr_graph, op_ptr);
8420188e:	33 00       	r1 = r4 + Null;
84201890:	5a 08       	r0 = r9 + Null;
84201892:	ff fd c3 f0 	call (m) 0x19f16;
84201896:	25 e4 

84201898 <Lc_build_spkr_graph_9>:
    }

#ifdef AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT
    /* Reset flag showing speaker started to consume data */
    op_extra_data->spkr_flow_started = FALSE;
84201898:	41 d8       	rMAC = M[FP + 32];
8420189a:	10 f0 cc 8e 	M[rMAC + 816] = Null;
#endif

    pfree(idxs);
8420189e:	52 d8       	r0 = M[FP + 40];
842018a0:	ff fd 28 f0 	call (m) 0x68d8;
842018a4:	39 e1 

842018a6 <Lc_build_spkr_graph_10>:

    **********************************************************************/
    /* Is there a Speaker path */
    if(!(op_extra_data->channel_status&CHAN_STATE_SPKR_MASK))
    {
        return(TRUE);
842018a6:	42 20       	r0 = Null + 1;
842018a8:	0f f0 93 e8 	jump (m) Lc_build_spkr_graph_79;

842018ac <Lc_build_spkr_graph_11>:
            num_spkrs=1;
        }
        else
        {
            /* Mono input, multiple outputs */
            num_inputs=1;
842018ac:	0a 71       	r8 = Null + 1;

842018ae <Lc_build_spkr_graph_12>:
        }
    }

    /* outputs follow inputs */
    /* Internal buffers for output of insert follow outputs */
    out_indx       = num_inputs;
842018ae:	ea f0 0b 8e 	M[FP + 44] = r8;

    /* Count the buffers needed */
    num_io         = num_inputs+num_spkrs;
842018b2:	49 d8       	rMAC = M[FP + 36];
842018b4:	51 0c       	rMAC = r8 + rMAC;
842018b6:	0a 00       	r0 = rMAC + Null;

    /* reserve one index for sidetone input buffer */
    op_extra_data->spkr_st_in_idx = num_io;
842018b8:	41 d8       	rMAC = M[FP + 32];
842018ba:	12 f0 8c 8e 	M[rMAC + 560] = r0;
842018be:	11 00       	rMAC = r0 + Null;
    num_io++;
842018c0:	49 20       	rMAC = rMAC + 1;
842018c2:	09 09       	r7 = rMAC + Null;

    /* Assume no resampler or rate matching */
    intern_rs_idx = 0;
842018c4:	60 de       	M[FP + 48] = Null;
    intern_rm_idx = 0;
842018c6:	68 de       	M[FP + 52] = Null;
    intern_ins_idx = num_io;

    /* speaker inputs are copied to interm buffers immediately,
	   reserve indexes for num_inputs buffers.
	 */
    num_io += num_inputs;
842018c8:	51 0c       	rMAC = r8 + rMAC;
842018ca:	71 de       	M[FP + 56] = rMAC;
     * scratch buffer for both inputs and outputs.
     */
    usable_scratch_idx = 0;

    /* Check if resampler is required */
    if(op_extra_data->input_rate!=op_extra_data->spkr_rate)
842018cc:	41 d8       	rMAC = M[FP + 32];
842018ce:	0a 00       	r0 = rMAC + Null;
842018d0:	11 f0 70 88 	rMAC = M[rMAC + 448];
842018d4:	22 f0 7b 88 	r0 = M[r0 + 492];
842018d8:	88 04       	Null = rMAC - r0;
842018da:	39 60       	if EQ jump (m) Lc_build_spkr_graph_22;

842018dc <Lc_build_spkr_graph_13>:
    {
        intern_rs_idx = out_indx;
842018dc:	ea f0 0c 8e 	M[FP + 48] = r8;

        if(op_extra_data->spkr_rate_ability==RATEMATCHING_SUPPORT_SW)
842018e0:	41 d8       	rMAC = M[FP + 32];
842018e2:	11 f0 7c 88 	rMAC = M[rMAC + 496];
842018e6:	48 24       	Null = rMAC - 1;
842018e8:	1a 62       	if NE jump (m) Lc_build_spkr_graph_19;

842018ea <Lc_build_spkr_graph_14>:
        {
            /* Need buffers following resampler */
            intern_rs_idx    = num_io;
842018ea:	71 d8       	rMAC = M[FP + 56];
842018ec:	61 de       	M[FP + 48] = rMAC;
            if(num_spkrs>num_inputs)
842018ee:	49 d8       	rMAC = M[FP + 36];
842018f0:	af f1 00 c2 	Null = rMAC - r8;
842018f4:	09 f0 d1 e0 	if LS jump (m) Lc_build_spkr_graph_21;

842018f8 <Lc_build_spkr_graph_15>:
            {
                /* Resampler is Mono.  Feeds shift */
                num_io++;
842018f8:	71 d8       	rMAC = M[FP + 56];
842018fa:	49 20       	rMAC = rMAC + 1;
842018fc:	71 de       	M[FP + 56] = rMAC;

842018fe <Lc_build_spkr_graph_16>:
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
       /* not required if having access to external rate adjust op */
       && (0 == op_extra_data->spkr_ext_rate_adjust_op)
#endif
       )
842018fe:	41 d8       	rMAC = M[FP + 32];
84201900:	10 f0 a1 88 	Null = M[rMAC + 644];
84201904:	0c 62       	if NE jump (m) Lc_build_spkr_graph_19;

84201906 <Lc_build_spkr_graph_17>:
    {
        intern_rm_idx = out_indx;
84201906:	ea f0 0d 8e 	M[FP + 52] = r8;
        /* Split needs buffer following rate matching (Mono)*/
        if(num_spkrs>num_inputs)
8420190a:	49 d8       	rMAC = M[FP + 36];
8420190c:	af f1 00 c2 	Null = rMAC - r8;
84201910:	09 f0 8d e0 	if LS jump (m) Lc_build_spkr_graph_19;

84201914 <Lc_build_spkr_graph_18>:
        {
            intern_rm_idx = num_io;
84201914:	71 d8       	rMAC = M[FP + 56];
84201916:	69 de       	M[FP + 52] = rMAC;
            num_io++;
84201918:	49 20       	rMAC = rMAC + 1;
8420191a:	71 de       	M[FP + 56] = rMAC;

8420191c <Lc_build_spkr_graph_19>:
    /* reserve 2 indexes for reference sub-path,
     * one is for reference output buffer, the
     * other one for scratch buffer for possible
     * resampler in the sub-path.
     */
    op_extra_data->spkr_ref_idx  = num_io;
8420191c:	72 d8       	r0 = M[FP + 56];
8420191e:	41 d8       	rMAC = M[FP + 32];
84201920:	12 f0 8b 8e 	M[rMAC + 556] = r0;
84201924:	11 00       	rMAC = r0 + Null;
    num_io +=2;
84201926:	89 20       	rMAC = rMAC + 2;
84201928:	71 de       	M[FP + 56] = rMAC;

    /* Allocate buffer index array for easy setup */
    if(num_inputs<num_spkrs)
8420192a:	49 d8       	rMAC = M[FP + 36];
8420192c:	1f fa 00 c2 	Null = r8 - rMAC;
84201930:	02 f0 a9 e0 	if C jump (m) Lc_build_spkr_graph_23;

84201934 <Lc_build_spkr_graph_20>:
    {
        idxs = create_default_indexes(num_io+num_spkrs);
84201934:	72 d8       	r0 = M[FP + 56];
84201936:	49 d8       	rMAC = M[FP + 36];
84201938:	8a 00       	r0 = rMAC + r0;
8420193a:	ff fd c3 f0 	call (m) 0x19fe6;
8420193e:	2d e5 
84201940:	52 de       	M[FP + 40] = r0;
84201942:	10 6e       	jump (m) Lc_build_spkr_graph_24;

84201944 <Lc_build_spkr_graph_21>:
                num_io++;
            }
            else
            {
                /* Resampler is multi channel */
                num_io += num_inputs;
84201944:	71 d8       	rMAC = M[FP + 56];
84201946:	51 0c       	rMAC = r8 + rMAC;
84201948:	71 de       	M[FP + 56] = rMAC;
8420194a:	da 6f       	jump (m) Lc_build_spkr_graph_16;

8420194c <Lc_build_spkr_graph_22>:
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
       /* not required if having access to external rate adjust op */
       && (0 == op_extra_data->spkr_ext_rate_adjust_op)
#endif
       )
8420194c:	41 d8       	rMAC = M[FP + 32];
8420194e:	11 f0 7c 88 	rMAC = M[rMAC + 496];
84201952:	48 24       	Null = rMAC - 1;
84201954:	d5 61       	if EQ jump (m) Lc_build_spkr_graph_16;

84201956 <Lc__ite_20>:
84201956:	e3 6f       	jump (m) Lc_build_spkr_graph_19;

84201958 <Lc_build_spkr_graph_23>:
    {
        idxs = create_default_indexes(num_io+num_spkrs);
    }
    else
    {
        idxs = create_default_indexes(num_io);
84201958:	72 d8       	r0 = M[FP + 56];
8420195a:	ff fd c3 f0 	call (m) 0x19fe6;
8420195e:	2d e4 
84201960:	52 de       	M[FP + 40] = r0;

84201962 <Lc_build_spkr_graph_24>:
    }
    if(idxs == NULL)
84201962:	51 d8       	rMAC = M[FP + 40];
84201964:	12 60       	if EQ jump (m) Lc_build_spkr_graph_28;

84201966 <Lc_build_spkr_graph_25>:
    {
        return(FALSE);
    }

    /* Allocate num_io buffers in spkr graph */
    spkr_graph = cbops_alloc_graph(num_io);
84201966:	72 d8       	r0 = M[FP + 56];
84201968:	ff fd c2 f0 	call (m) 0x19de0;
8420196c:	39 e3 
8420196e:	13 09       	r9 = r0 + Null;
    if(!spkr_graph)
84201970:	08 60       	if EQ jump (m) Lc_build_spkr_graph_27;

84201972 <Lc_build_spkr_graph_26>:
    {
        goto aFailed;
    }
    op_extra_data->spkr_graph = spkr_graph;
84201972:	41 d8       	rMAC = M[FP + 32];
84201974:	1b f0 7f 8e 	M[rMAC + 508] = r9;
       Internal (after ref resample)    : scratch[num_inputs]
       REF OUT
    */

    /* Input, Output, and insert_op buffers */
    for(j=0,i=0,k=0;j<MAX_NUMBER_SPEAKERS;j++)
84201978:	07 00       	r5 = Null + Null;
8420197a:	00 09       	r6 = Null + Null;
8420197c:	06 00       	r4 = Null + Null;
8420197e:	0b 6e       	jump (m) Lc_build_spkr_graph_30;

84201980 <Lc_build_spkr_graph_27>:

    DEBUG_GRAPHS("AEC REFERENCE: Building speaker graph, Done!" );
    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building speaker graph, Failed!" );
    pfree(idxs);
84201980:	52 d8       	r0 = M[FP + 40];
84201982:	ff fd 27 f0 	call (m) 0x68d8;
84201986:	37 ea 

84201988 <Lc_build_spkr_graph_28>:
    {
        idxs = create_default_indexes(num_io);
    }
    if(idxs == NULL)
    {
        return(FALSE);
84201988:	02 00       	r0 = Null + Null;
8420198a:	0f f0 b1 e6 	jump (m) Lc_build_spkr_graph_79;

8420198e <Lc_build_spkr_graph_29>:

    /* Input, Output, and insert_op buffers */
    for(j=0,i=0,k=0;j<MAX_NUMBER_SPEAKERS;j++)
    {
        /* Inputs may not be contiguous */
        buffer_ptr =  op_extra_data->input_stream[SpeakerInputTerminalByIndex(j)];
8420198e:	b0 24       	Null = r4 - 2;
84201990:	02 f0 89 e0 	if C jump (m) Lc_build_spkr_graph_31;

84201994 <Lc_build_spkr_graph_30>:
84201994:	32 00       	r0 = r4 + Null;
84201996:	02 6e       	jump (m) Lc_build_spkr_graph_32;

84201998 <Lc_build_spkr_graph_31>:
84201998:	32 21       	r0 = r4 + 4;

8420199a <Lc_build_spkr_graph_32>:
8420199a:	52 54       	r0 = r0 LSHIFT 2;
8420199c:	41 d8       	rMAC = M[FP + 32];
        if(buffer_ptr)
8420199e:	8d e8       	r3 = M[rMAC + r0];
842019a0:	08 60       	if EQ jump (m) Lc_build_spkr_graph_34;

842019a2 <Lc_build_spkr_graph_33>:
        {
            /* Inputs */
            cbops_set_input_io_buffer(spkr_graph,i,0,buffer_ptr);
842019a2:	04 00       	r2 = Null + Null;
842019a4:	3b 00       	r1 = r5 + Null;
842019a6:	5a 08       	r0 = r9 + Null;
842019a8:	ff fd c2 f0 	call (m) 0x19e7c;
842019ac:	35 e6 
            i++;
842019ae:	7f 20       	r5 = r5 + 1;

842019b0 <Lc_build_spkr_graph_34>:
        }
        /* Outputs may not be contiguous */
        buffer_ptr =  op_extra_data->output_stream[SpeakerTerminalByIndex(j)];
842019b0:	b0 24       	Null = r4 - 2;
842019b2:	02 f0 89 e0 	if C jump (m) Lc_build_spkr_graph_36;

842019b6 <Lc_build_spkr_graph_35>:
842019b6:	72 20       	r0 = r4 + 1;
842019b8:	02 6e       	jump (m) Lc_build_spkr_graph_37;

842019ba <Lc_build_spkr_graph_36>:
842019ba:	72 21       	r0 = r4 + 5;

842019bc <Lc_build_spkr_graph_37>:
842019bc:	41 d8       	rMAC = M[FP + 32];
842019be:	52 54       	r0 = r0 LSHIFT 2;
842019c0:	01 f0 40 44 	rMAC = rMAC + 64;
        if(buffer_ptr)
842019c4:	8d e8       	r3 = M[rMAC + r0];
842019c6:	09 60       	if EQ jump (m) Lc_build_spkr_graph_39;

842019c8 <Lc_build_spkr_graph_38>:
        {
            cbops_set_output_io_buffer(spkr_graph,out_indx + k,out_indx,buffer_ptr);
842019c8:	8f fa 03 c0 	r1 = r8 + r6;
842019cc:	54 08       	r2 = r8 + Null;
842019ce:	5a 08       	r0 = r9 + Null;
842019d0:	ff fd c2 f0 	call (m) 0x19eb0;
842019d4:	21 e7 
            k++;
842019d6:	08 75       	r6 = r6 + 1;

842019d8 <Lc_build_spkr_graph_39>:
       Internal (after ref resample)    : scratch[num_inputs]
       REF OUT
    */

    /* Input, Output, and insert_op buffers */
    for(j=0,i=0,k=0;j<MAX_NUMBER_SPEAKERS;j++)
842019d8:	76 20       	r4 = r4 + 1;
842019da:	30 26       	Null = r4 - 8;
842019dc:	d9 65       	if NC jump (m) Lc_build_spkr_graph_29;

842019de <Lc_build_spkr_graph_40>:
        }
    }


    /* Buffers for transfer from inputs to interm buffers */
    for(i=0; i < num_inputs ; i++)
842019de:	06 00       	r4 = Null + Null;
842019e0:	41 d8       	rMAC = M[FP + 32];
842019e2:	17 f0 84 20 	r5 = rMAC + 132;

842019e6 <Lc_build_spkr_graph_41>:
842019e6:	af f6 00 c2 	Null = r4 - r8;
842019ea:	02 f0 9b e0 	if C jump (m) Lc_build_spkr_graph_43;

842019ee <Lc_build_spkr_graph_42>:
    {
         cbops_set_internal_io_buffer(spkr_graph,
                                      intern_ins_idx + i,
                                      intern_ins_idx,
                                      op_extra_data->scratch_bufs[usable_scratch_idx + i]);
842019ee:	3d e8       	r3 = M[r5 + Null];
842019f0:	9f f6 03 c0 	r1 = r4 + r7;
842019f4:	4c 08       	r2 = r7 + Null;
842019f6:	5a 08       	r0 = r9 + Null;
842019f8:	ff fd c2 f0 	call (m) 0x19ee4;
842019fc:	2d e7 
        }
    }


    /* Buffers for transfer from inputs to interm buffers */
    for(i=0; i < num_inputs ; i++)
842019fe:	76 20       	r4 = r4 + 1;
84201a00:	3f 21       	r5 = r5 + 4;
84201a02:	f2 6f       	jump (m) Lc_build_spkr_graph_41;

84201a04 <Lc_build_spkr_graph_43>:
                                      intern_ins_idx + i,
                                      intern_ins_idx,
                                      op_extra_data->scratch_bufs[usable_scratch_idx + i]);
    }
    /* update usable_scratch_idx for next use */
    usable_scratch_idx = usable_scratch_idx==0? num_inputs:0;
84201a04:	ea f0 0f 8e 	M[FP + 60] = r8;
    /* Building override operator, this operator will transfer speaker
     * inputs to inerim buufers as well as any silence insertion required.
     * This way AEC_REFERERNCE will not write into its input buffer.
     */
    /* Thresholds for Insertion, keep a copy in main structure */
    op_extra_data->spkr_in_threshold  = frac_mult(op_extra_data->input_rate,op_extra_data->task_period_frac) + 1;
84201a08:	41 d8       	rMAC = M[FP + 32];
84201a0a:	12 f0 70 88 	r0 = M[rMAC + 448];
84201a0e:	13 f0 66 88 	r1 = M[rMAC + 408];
84201a12:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84201a16:	51 20       	rMAC = r0 + 1;
84201a18:	42 d8       	r0 = M[FP + 32];
84201a1a:	21 f0 a8 8e 	M[r0 + 672] = rMAC;
84201a1e:	11 00       	rMAC = r0 + Null;
    op_extra_data->spkr_out_threshold = frac_mult(op_extra_data->spkr_rate,op_extra_data->task_period_frac) + 1;
84201a20:	12 f0 7b 88 	r0 = M[rMAC + 492];
84201a24:	13 f0 66 88 	r1 = M[rMAC + 408];
84201a28:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84201a2c:	51 20       	rMAC = r0 + 1;
84201a2e:	42 d8       	r0 = M[FP + 32];
84201a30:	21 f0 a9 8e 	M[r0 + 676] = rMAC;
84201a34:	11 00       	rMAC = r0 + Null;
     * task period there will be ~(spkr_out_threshold + max_jitter) in the output buffer,
     * this is to cover a full task period plus possible scheduling uncertainties.
     * 1ms max_jitter might be enough, 0.5ms added in case sidetone mixing will run
     * in decimated task period.
     */
    unsigned max_jitter = frac_mult(op_extra_data->spkr_rate, FRACTIONAL(0.0015));
84201a36:	12 f0 7b 88 	r0 = M[rMAC + 492];
84201a3a:	03 f0 93 f0 	r1 = Null + 3221225;
84201a3e:	e9 4a 
84201a40:	00 f3 72 c9 	r0 = r0 * r1 (frac);

    overrid_op_ptr = create_aec_ref_spkr_op(num_inputs,idxs,&idxs[intern_ins_idx],
                                            op_extra_data->spkr_in_threshold,
                                            num_spkrs,&idxs[out_indx],
                                            op_extra_data->spkr_out_threshold,
                                            max_jitter);
84201a44:	01 f9 d3 c8 	r1 = r7 LSHIFT 2;
84201a48:	e8 f0 0a 88 	r6 = M[FP + 40];
84201a4c:	18 0d       	r6 = r1 + r6;
84201a4e:	11 1c       	pushm <r0>;
84201a50:	11 f0 a9 88 	rMAC = M[rMAC + 676];
84201a54:	09 1c       	pushm <rMAC>;
84201a56:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
84201a5a:	51 d8       	rMAC = M[FP + 40];
84201a5c:	0b 00       	r1 = rMAC + Null;
84201a5e:	51 00       	rMAC = r0 + rMAC;
84201a60:	09 1c       	pushm <rMAC>;
84201a62:	49 d8       	rMAC = M[FP + 36];
84201a64:	09 1c       	pushm <rMAC>;
84201a66:	41 d8       	rMAC = M[FP + 32];
84201a68:	44 08       	r2 = r6 + Null;
84201a6a:	15 f0 a8 88 	r3 = M[rMAC + 672];
84201a6e:	52 08       	r0 = r8 + Null;
84201a70:	08 f0 3d ef 	call (m) $_create_aec_ref_spkr_op;
84201a74:	7c 4c       	SP = SP + -16;
#if defined(IO_DEBUG)
    op_extra_data->insert_op = overrid_op_ptr;
84201a76:	41 d8       	rMAC = M[FP + 32];
#endif
    if(!overrid_op_ptr)
84201a78:	12 f0 d1 8e 	M[rMAC + 836] = r0;
84201a7c:	82 61       	if EQ jump (m) Lc_build_spkr_graph_27;

84201a7e <Lc_build_spkr_graph_44>:
    {
        goto aFailed;
    }

    cbops_set_override_operator(spkr_graph,overrid_op_ptr);
84201a7e:	13 00       	r1 = r0 + Null;
84201a80:	5a 08       	r0 = r9 + Null;
84201a82:	ff fd c2 f0 	call (m) 0x19f3e;
84201a86:	3d e5 

    /* DC remove before reference tap */
    op_ptr = create_dc_remove_op(num_inputs, &idxs[intern_ins_idx], &idxs[intern_ins_idx]);
84201a88:	44 08       	r2 = r6 + Null;
84201a8a:	43 08       	r1 = r6 + Null;
84201a8c:	52 08       	r0 = r8 + Null;
84201a8e:	ff fd 67 f1 	call (m) 0x2e980;
84201a92:	33 e7 
84201a94:	17 00       	r5 = r0 + Null;
    if(!op_ptr)
84201a96:	75 61       	if EQ jump (m) Lc_build_spkr_graph_27;

84201a98 <Lc_build_spkr_graph_45>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(spkr_graph,op_ptr);
84201a98:	3b 00       	r1 = r5 + Null;
84201a9a:	5a 08       	r0 = r9 + Null;
84201a9c:	ff fd c2 f0 	call (m) 0x19f16;
84201aa0:	3b e3 


    /* Add Mixer to section #1 if needed*/
    if(num_inputs > num_spkrs)
84201aa2:	49 d8       	rMAC = M[FP + 36];
84201aa4:	1f fa 00 c2 	Null = r8 - rMAC;
84201aa8:	09 f0 bb e0 	if LS jump (m) Lc_build_spkr_graph_51;

84201aac <Lc_build_spkr_graph_46>:
    {
        for(i=1;i<num_inputs;i++)
84201aac:	46 20       	r4 = Null + 1;

84201aae <Lc_build_spkr_graph_47>:
84201aae:	af f6 00 c2 	Null = r4 - r8;
84201ab2:	02 f0 af e0 	if C jump (m) Lc_build_spkr_graph_50;

84201ab6 <Lc_build_spkr_graph_48>:
        {
            /* NOTE: left scratch input reused for output (inplace) */
            /*  - Add Mix Operator - stereo to mono (left = (left+right)/2 */
            op_ptr = create_mixer_op(intern_ins_idx, intern_ins_idx+i, intern_ins_idx, 0, FRACTIONAL(0.5));
84201ab6:	ff f3 ff ff 	push Null + 1073741823;
84201aba:	5f ef 
84201abc:	9f f6 03 c0 	r1 = r4 + r7;
84201ac0:	05 00       	r3 = Null + Null;
84201ac2:	4c 08       	r2 = r7 + Null;
84201ac4:	4a 08       	r0 = r7 + Null;
84201ac6:	ff fd b1 f1 	call (m) 0x37d86;
84201aca:	21 e6 
84201acc:	7f 4c       	SP = SP + -4;
84201ace:	17 00       	r5 = r0 + Null;
            if(!op_ptr)
84201ad0:	58 61       	if EQ jump (m) Lc_build_spkr_graph_27;

84201ad2 <Lc_build_spkr_graph_49>:
            {
                goto aFailed;
            }
            cbops_append_operator_to_graph(spkr_graph,op_ptr);
84201ad2:	3b 00       	r1 = r5 + Null;
84201ad4:	5a 08       	r0 = r9 + Null;
84201ad6:	ff fd c2 f0 	call (m) 0x19f16;
84201ada:	21 e2 


    /* Add Mixer to section #1 if needed*/
    if(num_inputs > num_spkrs)
    {
        for(i=1;i<num_inputs;i++)
84201adc:	76 20       	r4 = r4 + 1;
84201ade:	e8 6f       	jump (m) Lc_build_spkr_graph_47;

84201ae0 <Lc_build_spkr_graph_50>:
                goto aFailed;
            }
            cbops_append_operator_to_graph(spkr_graph,op_ptr);
        }
        /* Input is now mono */
        num_inputs = 1;
84201ae0:	0a 71       	r8 = Null + 1;

84201ae2 <Lc_build_spkr_graph_51>:
    /* This is the point where we take input for the
     * reference sub-path, store information about
     * where in the graph the reference sub-path
     * should be inserted to.
     */
    op_extra_data->spkr_ref_input_idx = intern_ins_idx;
84201ae2:	41 d8       	rMAC = M[FP + 32];
84201ae4:	19 f0 88 8e 	M[rMAC + 544] = r7;
    op_extra_data->spkr_ref_point_op = op_ptr;
84201ae8:	17 f0 8f 8e 	M[rMAC + 572] = r5;
    op_extra_data->spkr_ref_scratch_idx = usable_scratch_idx;
84201aec:	7a d8       	r0 = M[FP + 60];
84201aee:	12 f0 89 8e 	M[rMAC + 548] = r0;

    /* Add sample rate conversion per channel [num_inputs] (input_rate --> spkr_rate) */
    if(intern_rs_idx!=0)
84201af2:	61 d8       	rMAC = M[FP + 48];
84201af4:	4c 60       	if EQ jump (m) Lc_build_spkr_graph_61;

84201af6 <Lc_build_spkr_graph_52>:
    {
        int shift_amount = op_extra_data->spkr_shift;
84201af6:	41 d8       	rMAC = M[FP + 32];
84201af8:	11 f0 81 88 	rMAC = M[rMAC + 516];

        if(intern_rs_idx!=out_indx)
84201afc:	63 d8       	r1 = M[FP + 48];
84201afe:	5a d8       	r0 = M[FP + 44];
84201b00:	98 04       	Null = r1 - r0;
84201b02:	1e 60       	if EQ jump (m) Lc_build_spkr_graph_59;

84201b04 <Lc_build_spkr_graph_53>:
        {
            /* Buffers for output of resampler. */
            for(i=0; i < num_inputs ; i++)
84201b04:	06 00       	r4 = Null + Null;
84201b06:	7a d8       	r0 = M[FP + 60];
84201b08:	41 d8       	rMAC = M[FP + 32];
84201b0a:	52 54       	r0 = r0 LSHIFT 2;
84201b0c:	51 00       	rMAC = r0 + rMAC;
84201b0e:	17 f0 84 20 	r5 = rMAC + 132;

84201b12 <Lc_build_spkr_graph_54>:
84201b12:	af f6 00 c2 	Null = r4 - r8;
84201b16:	02 f0 9b e0 	if C jump (m) Lc_build_spkr_graph_56;

84201b1a <Lc_build_spkr_graph_55>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rs_idx+i,intern_rs_idx,
                                             op_extra_data->scratch_bufs[usable_scratch_idx+i]);
84201b1a:	3d e8       	r3 = M[r5 + Null];
84201b1c:	61 d8       	rMAC = M[FP + 48];
84201b1e:	0c 00       	r2 = rMAC + Null;
84201b20:	73 00       	r1 = r4 + rMAC;
84201b22:	5a 08       	r0 = r9 + Null;
84201b24:	ff fd c1 f0 	call (m) 0x19ee4;
84201b28:	21 ee 
        int shift_amount = op_extra_data->spkr_shift;

        if(intern_rs_idx!=out_indx)
        {
            /* Buffers for output of resampler. */
            for(i=0; i < num_inputs ; i++)
84201b2a:	76 20       	r4 = r4 + 1;
84201b2c:	3f 21       	r5 = r5 + 4;
84201b2e:	f2 6f       	jump (m) Lc_build_spkr_graph_54;

84201b30 <Lc_build_spkr_graph_56>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rs_idx+i,intern_rs_idx,
                                             op_extra_data->scratch_bufs[usable_scratch_idx+i]);
            }
            shift_amount=0;
84201b30:	01 00       	rMAC = Null + Null;
            /* update usable_scratch_idx for next use */
            usable_scratch_idx = usable_scratch_idx==0?num_inputs:0;
84201b32:	7a d8       	r0 = M[FP + 60];
84201b34:	04 62       	if NE jump (m) Lc_build_spkr_graph_58;

84201b36 <Lc_build_spkr_graph_57>:
84201b36:	ea f0 0f 8e 	M[FP + 60] = r8;
84201b3a:	02 6e       	jump (m) Lc_build_spkr_graph_59;

84201b3c <Lc_build_spkr_graph_58>:
84201b3c:	78 de       	M[FP + 60] = Null;

84201b3e <Lc_build_spkr_graph_59>:
        }

        op_ptr = create_iir_resamplerv2_op(num_inputs, &idxs[intern_ins_idx], &idxs[intern_rs_idx],
                                           op_extra_data->input_rate, op_extra_data->spkr_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, shift_amount, 0, 0);
84201b3e:	00 f0 30 cf 	push Null;
84201b42:	00 f0 30 cf 	push Null;
84201b46:	09 1c       	pushm <rMAC>;
84201b48:	41 d8       	rMAC = M[FP + 32];
84201b4a:	11 f0 32 88 	rMAC = M[rMAC + 200];
84201b4e:	09 1c       	pushm <rMAC>;
84201b50:	41 d8       	rMAC = M[FP + 32];
84201b52:	11 f0 33 88 	rMAC = M[rMAC + 204];
84201b56:	09 1c       	pushm <rMAC>;
84201b58:	41 d8       	rMAC = M[FP + 32];
84201b5a:	11 f0 7b 88 	rMAC = M[rMAC + 492];
84201b5e:	09 1c       	pushm <rMAC>;
84201b60:	41 d8       	rMAC = M[FP + 32];
84201b62:	62 d8       	r0 = M[FP + 48];
84201b64:	54 d8       	r2 = M[FP + 40];
84201b66:	43 08       	r1 = r6 + Null;
84201b68:	15 f0 70 88 	r3 = M[rMAC + 448];
84201b6c:	52 54       	r0 = r0 LSHIFT 2;
84201b6e:	14 01       	r2 = r0 + r2;
84201b70:	52 08       	r0 = r8 + Null;
84201b72:	ff fd c2 f0 	call (m) 0x1a090;
84201b76:	3f e8 
84201b78:	7a 4c       	SP = SP + -24;
84201b7a:	17 00       	r5 = r0 + Null;
        if(!op_ptr)
84201b7c:	02 61       	if EQ jump (m) Lc_build_spkr_graph_27;

84201b7e <Lc_build_spkr_graph_60>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(spkr_graph,op_ptr);
84201b7e:	3b 00       	r1 = r5 + Null;
84201b80:	5a 08       	r0 = r9 + Null;
84201b82:	ff fd c1 f0 	call (m) 0x19f16;
84201b86:	35 ec 

        /* Move next input to output of resampler */
        intern_ins_idx = intern_rs_idx;
84201b88:	e9 f0 0c 88 	r7 = M[FP + 48];

84201b8c <Lc_build_spkr_graph_61>:
    /* This is the point where we insert possible sidetone
     * mix operator, store both the operator and the input
     * buffer index for the operator. Sidetone mixing
     * will always be done in-place.
     */
    op_extra_data->spkr_st_point_op = op_ptr;
84201b8c:	41 d8       	rMAC = M[FP + 32];
84201b8e:	17 f0 90 8e 	M[rMAC + 576] = r5;
    op_extra_data->spkr_stmix_in_idx = intern_ins_idx;
84201b92:	19 f0 8a 8e 	M[rMAC + 552] = r7;

    /* Optional section for SW rate matching */
    if(intern_rm_idx != 0)
84201b96:	69 d8       	rMAC = M[FP + 52];
84201b98:	47 60       	if EQ jump (m) Lc_build_spkr_graph_69;

84201b9a <Lc_build_spkr_graph_62>:
    {
        int shift_amount =  op_extra_data->spkr_shift;
84201b9a:	41 d8       	rMAC = M[FP + 32];
84201b9c:	11 f0 81 88 	rMAC = M[rMAC + 516];

        if(intern_rm_idx!=out_indx)
84201ba0:	6b d8       	r1 = M[FP + 52];
84201ba2:	5a d8       	r0 = M[FP + 44];
84201ba4:	98 04       	Null = r1 - r0;
84201ba6:	18 60       	if EQ jump (m) Lc_build_spkr_graph_67;

84201ba8 <Lc_build_spkr_graph_63>:
        {
            /* Buffers for output of ratematch if it exists */
            for(i=0; i < num_inputs; i++)
84201ba8:	06 00       	r4 = Null + Null;
84201baa:	7a d8       	r0 = M[FP + 60];
84201bac:	41 d8       	rMAC = M[FP + 32];
84201bae:	52 54       	r0 = r0 LSHIFT 2;
84201bb0:	51 00       	rMAC = r0 + rMAC;
84201bb2:	17 f0 84 20 	r5 = rMAC + 132;

84201bb6 <Lc_build_spkr_graph_64>:
84201bb6:	af f6 00 c2 	Null = r4 - r8;
84201bba:	02 f0 9b e0 	if C jump (m) Lc_build_spkr_graph_66;

84201bbe <Lc_build_spkr_graph_65>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rm_idx+i,intern_rm_idx,
                                             op_extra_data->scratch_bufs[usable_scratch_idx+i]);
84201bbe:	3d e8       	r3 = M[r5 + Null];
84201bc0:	69 d8       	rMAC = M[FP + 52];
84201bc2:	0c 00       	r2 = rMAC + Null;
84201bc4:	73 00       	r1 = r4 + rMAC;
84201bc6:	5a 08       	r0 = r9 + Null;
84201bc8:	ff fd c1 f0 	call (m) 0x19ee4;
84201bcc:	3d e8 
        int shift_amount =  op_extra_data->spkr_shift;

        if(intern_rm_idx!=out_indx)
        {
            /* Buffers for output of ratematch if it exists */
            for(i=0; i < num_inputs; i++)
84201bce:	76 20       	r4 = r4 + 1;
84201bd0:	3f 21       	r5 = r5 + 4;
84201bd2:	f2 6f       	jump (m) Lc_build_spkr_graph_64;

84201bd4 <Lc_build_spkr_graph_66>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rm_idx+i,intern_rm_idx,
                                             op_extra_data->scratch_bufs[usable_scratch_idx+i]);
            }
            shift_amount=0;
84201bd4:	01 00       	rMAC = Null + Null;

84201bd6 <Lc_build_spkr_graph_67>:
        }

        /*  SW rate adjustment per channel [num_inputs] */
        op_ptr = create_sw_rate_adj_op(num_inputs, &idxs[intern_ins_idx], &idxs[intern_rm_idx],
                                       CBOPS_RATEADJUST_COEFFS,
                                       &op_extra_data->spkr_rate_adjustment,shift_amount);
84201bd6:	09 1c       	pushm <rMAC>;
84201bd8:	41 d8       	rMAC = M[FP + 32];
84201bda:	85 2a       	r3 = Null + 26;
84201bdc:	01 f0 f4 ff 	push rMAC + 500;
84201be0:	11 cf 
84201be2:	6a d8       	r0 = M[FP + 52];
84201be4:	54 d8       	r2 = M[FP + 40];
84201be6:	52 54       	r0 = r0 LSHIFT 2;
84201be8:	23 00       	r1 = r2 + Null;
84201bea:	14 01       	r2 = r0 + r2;
84201bec:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
84201bf0:	d3 00       	r1 = r0 + r1;
84201bf2:	52 08       	r0 = r8 + Null;
84201bf4:	ff fd c0 f0 	call (m) 0x19c66;
84201bf8:	33 e3 
84201bfa:	7e 4c       	SP = SP + -8;
84201bfc:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
84201bfe:	f0 ff 83 eb 	if EQ jump (m) Lc_build_spkr_graph_27;

84201c02 <Lc_build_spkr_graph_68>:
        {
            goto aFailed;
        }

        op_extra_data->spkr_sw_rateadj_op=op_ptr;
84201c02:	41 d8       	rMAC = M[FP + 32];
84201c04:	16 f0 9f 8e 	M[rMAC + 636] = r4;
        cbops_rateadjust_passthrough_mode(op_ptr,(op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
84201c08:	03 00       	r1 = Null + Null;
84201c0a:	10 f0 7e 88 	Null = M[rMAC + 504];
84201c0e:	20 f0 43 ce 	if EQ r1 = Null + 1;
84201c12:	ff fd c0 f0 	call (m) 0x19d0a;
84201c16:	39 e7 

        cbops_append_operator_to_graph(spkr_graph,op_ptr);
84201c18:	33 00       	r1 = r4 + Null;
84201c1a:	5a 08       	r0 = r9 + Null;
84201c1c:	ff fd c1 f0 	call (m) 0x19f16;
84201c20:	3b e7 

        /* Move next input to output of ratematch */
        intern_ins_idx = intern_rm_idx;
84201c22:	e9 f0 0d 88 	r7 = M[FP + 52];

84201c26 <Lc_build_spkr_graph_69>:
    }


    /* Did previous operator terminate route? */
    if(intern_ins_idx!=out_indx)
84201c26:	59 d8       	rMAC = M[FP + 44];
84201c28:	1f f9 00 c2 	Null = r7 - rMAC;
84201c2c:	2a 60       	if EQ jump (m) Lc_build_spkr_graph_76;

84201c2e <Lc_build_spkr_graph_70>:
    {
        /* Check for Mono to multi-channel */
        if(num_inputs<num_spkrs)
84201c2e:	49 d8       	rMAC = M[FP + 36];
84201c30:	1f fa 00 c2 	Null = r8 - rMAC;
84201c34:	02 f0 9f e0 	if C jump (m) Lc_build_spkr_graph_74;

84201c38 <Lc_build_spkr_graph_71>:
        {
            for(i=0; i < num_spkrs; i++)
84201c38:	01 00       	rMAC = Null + Null;
84201c3a:	72 d8       	r0 = M[FP + 56];
84201c3c:	51 d8       	rMAC = M[FP + 40];
84201c3e:	52 54       	r0 = r0 LSHIFT 2;
84201c40:	51 00       	rMAC = r0 + rMAC;
84201c42:	4a d8       	r0 = M[FP + 36];
84201c44:	14 09       	r10 = r0 + Null;
84201c46:	04 4c       	do (m) Lc__loop0;

84201c48 <Lc_build_spkr_graph_72>:
            {
                idxs[num_io+i] = intern_ins_idx;
84201c48:	19 f0 00 ee 	M[rMAC + Null] = r7;
84201c4c:	09 21       	rMAC = rMAC + 4;

84201c4e <Lc__loop0>:
    if(intern_ins_idx!=out_indx)
    {
        /* Check for Mono to multi-channel */
        if(num_inputs<num_spkrs)
        {
            for(i=0; i < num_spkrs; i++)
84201c4e:	e9 f0 0e 88 	r7 = M[FP + 56];

84201c52 <Lc_build_spkr_graph_74>:
                idxs[num_io+i] = intern_ins_idx;
            }
            intern_ins_idx = num_io;
        }

        op_ptr = create_shift_op(num_spkrs, &idxs[intern_ins_idx], &idxs[out_indx], op_extra_data->spkr_shift);
84201c52:	41 d8       	rMAC = M[FP + 32];
84201c54:	5a d8       	r0 = M[FP + 44];
84201c56:	54 d8       	r2 = M[FP + 40];
84201c58:	15 f0 81 88 	r3 = M[rMAC + 516];
84201c5c:	52 54       	r0 = r0 LSHIFT 2;
84201c5e:	23 00       	r1 = r2 + Null;
84201c60:	14 01       	r2 = r0 + r2;
84201c62:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
84201c66:	d3 00       	r1 = r0 + r1;
84201c68:	4a d8       	r0 = M[FP + 36];
84201c6a:	ff fd 66 f1 	call (m) 0x2e942;
84201c6e:	39 e6 
        if(!op_ptr)
84201c70:	10 04       	Null = r0 - Null;
84201c72:	f0 ff 8f ea 	if EQ jump (m) Lc_build_spkr_graph_27;

84201c76 <Lc_build_spkr_graph_75>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(spkr_graph,op_ptr);
84201c76:	13 00       	r1 = r0 + Null;
84201c78:	5a 08       	r0 = r9 + Null;
84201c7a:	ff fd c1 f0 	call (m) 0x19f16;
84201c7e:	3d e4 

84201c80 <Lc_build_spkr_graph_76>:
    }

    op_extra_data->spkr_rate_adjustment=0;
84201c80:	41 d8       	rMAC = M[FP + 32];
84201c82:	10 f0 7d 8e 	M[rMAC + 500] = Null;

    /* create rate monitor op if required */
    op_ptr = NULL;
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_HW)
84201c86:	11 f0 7c 88 	rMAC = M[rMAC + 496];
84201c8a:	88 24       	Null = rMAC - 2;
84201c8c:	f1 ff ab e7 	if NE jump (m) Lc_build_spkr_graph_5;

84201c90 <Lc_build_spkr_graph_77>:
    {
        /* With HW rate adjustmen we always need rate monitor */
        op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, out_indx);
84201c90:	41 d8       	rMAC = M[FP + 32];
84201c92:	12 f0 65 88 	r0 = M[rMAC + 404];
84201c96:	5b d8       	r1 = M[FP + 44];
84201c98:	ff fd b0 f1 	call (m) 0x37e4c;
84201c9c:	35 ed 
84201c9e:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
84201ca0:	f0 ff e1 e9 	if EQ jump (m) Lc_build_spkr_graph_27;

84201ca4 <Lc_build_spkr_graph_78>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->spkr_rate, TRUE, 3*MS_PER_SEC);
84201ca4:	05 f0 b8 53 	r3 = Null + 3000;
84201ca8:	44 20       	r2 = Null + 1;
84201caa:	41 d8       	rMAC = M[FP + 32];
84201cac:	13 f0 7b 88 	r1 = M[rMAC + 492];
84201cb0:	ff fd 12 f4 	call 0x84204;
84201cb4:	34 ea 
84201cb6:	ff ff b5 e7 	jump (m) Lc_build_spkr_graph_8;

84201cba <Lc_build_spkr_graph_79>:
    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building speaker graph, Failed!" );
    pfree(idxs);
    return FALSE;
}
84201cba:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201cbc:	d8 4c       	rts;

84201cbe <$_validate_channels_and_build>:
 *        paths and rebuild the cbops graphs for each path when needed.
 *
 * \param op_data Pointer to the AEC reference operator data.
 */
bool validate_channels_and_build(OPERATOR_DATA *op_data)
{
84201cbe:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84201cc0:	12 09       	r8 = r0 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84201cc2:	ef fd f4 ff 	call (m) 0x4e6;
84201cc6:	25 e1 
84201cc8:	16 00       	r4 = r0 + Null;
bool validate_channels_and_build(OPERATOR_DATA *op_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* check changes in speaker, microphone and reference paths */
    bool spkr_changed = aec_reference_update_spkr_channel_status(op_extra_data);
84201cca:	ce 4e       	call (m) $_aec_reference_update_spkr_channel_status;
84201ccc:	17 00       	r5 = r0 + Null;
    bool mic_changed = aec_reference_update_mic_channel_status(op_extra_data);
84201cce:	32 00       	r0 = r4 + Null;
84201cd0:	50 4e       	call (m) $_aec_reference_update_mic_channel_status;
84201cd2:	10 09       	r6 = r0 + Null;
    bool ref_changed = aec_reference_update_ref_channel_status(op_extra_data);
84201cd4:	32 00       	r0 = r4 + Null;
84201cd6:	01 f0 3f e2 	call (m) $_aec_reference_update_ref_channel_status;
84201cda:	11 09       	r7 = r0 + Null;


    patch_fn_shared(aec_reference);

    /* update sidetone method */
    aec_reference_update_sidetone_method(op_extra_data);
84201cdc:	32 00       	r0 = r4 + Null;
84201cde:	01 f0 31 e4 	call (m) $_aec_reference_update_sidetone_method;

    /* rebuild graphs if there is change in
     * speaker or microphone path
     */
    if(!aec_reference_build_graphs(op_extra_data, spkr_changed, mic_changed))
84201ce2:	44 08       	r2 = r6 + Null;
84201ce4:	3b 00       	r1 = r5 + Null;
84201ce6:	32 00       	r0 = r4 + Null;
84201ce8:	01 f0 37 e6 	call (m) $_aec_reference_build_graphs;
84201cec:	10 04       	Null = r0 - Null;
84201cee:	3b 60       	if EQ jump (m) Lc_validate_channels_and_build_13;

84201cf0 <Lc_validate_channels_and_build_2>:
    }

    /* also if there is changes in reference path, then
     * apply that change to speaker graph
     */
    if(ref_changed || spkr_changed)
84201cf0:	0f f9 00 c2 	Null = r7 - Null;
84201cf4:	03 62       	if NE jump (m) Lc_validate_channels_and_build_4;

84201cf6 <Lc_validate_channels_and_build_3>:
84201cf6:	38 04       	Null = r5 - Null;
84201cf8:	0a 60       	if EQ jump (m) Lc_validate_channels_and_build_5;

84201cfa <Lc_validate_channels_and_build_4>:
    {
        if(!aec_reference_spkr_include_ref_path(op_extra_data, GetRefChannelStatus(op_extra_data)))
84201cfa:	61 f0 83 88 	rMAC = M[r4 + 524];
84201cfe:	13 f2 00 00 	r1 = rMAC AND 0x4000;
84201d02:	32 00       	r0 = r4 + Null;
84201d04:	03 f0 3f ea 	call (m) $_aec_reference_spkr_include_ref_path;
84201d08:	10 04       	Null = r0 - Null;
84201d0a:	2d 60       	if EQ jump (m) Lc_validate_channels_and_build_13;

84201d0c <Lc_validate_channels_and_build_5>:
            goto aFailed;
        }
    }

    if(op_extra_data->mic_graph != NULL ||
       op_extra_data->spkr_graph!= NULL)
84201d0c:	61 f0 75 88 	rMAC = M[r4 + 468];
84201d10:	04 62       	if NE jump (m) Lc_validate_channels_and_build_7;

84201d12 <Lc_validate_channels_and_build_6>:
84201d12:	61 f0 7f 88 	rMAC = M[r4 + 508];
84201d16:	16 60       	if EQ jump (m) Lc_validate_channels_and_build_10;

84201d18 <Lc_validate_channels_and_build_7>:
    {
        /* start running the graphs if not already running
         */
        if(op_extra_data->kick_id == TIMER_ID_INVALID)
84201d18:	60 f0 5e 88 	Null = M[r4 + 376];
84201d1c:	11 62       	if NE jump (m) Lc_validate_channels_and_build_9;

84201d1e <Lc_validate_channels_and_build_8>:
        {
            op_extra_data->kick_id = timer_schedule_event_in(op_extra_data->kick_period, aec_reference_timer_task,(void*)op_data);
84201d1e:	42 f0 07 f0 	r5 = Null + 69207877;
84201d22:	45 4b 
84201d24:	68 f0 67 88 	r6 = M[r4 + 412];
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(time_get_time(), time_in), TimerEventFunction, data_pointer);
84201d28:	ff fd 21 f0 	call (m) 0x6100;
84201d2c:	39 ee 
84201d2e:	42 0c       	r0 = r6 + r0;
84201d30:	54 08       	r2 = r8 + Null;
84201d32:	3b 00       	r1 = r5 + Null;
84201d34:	ff fd 21 f0 	call (m) 0x610a;
84201d38:	37 ee 
}
84201d3a:	62 f0 5e 8e 	M[r4 + 376] = r0;

84201d3e <Lc_validate_channels_and_build_9>:
    else
    {
        timer_cancel_event_atomic(&op_extra_data->kick_id);
    }

    return TRUE;
84201d3e:	42 20       	r0 = Null + 1;
84201d40:	16 6e       	jump (m) Lc_validate_channels_and_build_14;

84201d42 <Lc_validate_channels_and_build_10>:
            op_extra_data->kick_id = timer_schedule_event_in(op_extra_data->kick_period, aec_reference_timer_task,(void*)op_data);
        }
    }
    else
    {
        timer_cancel_event_atomic(&op_extra_data->kick_id);
84201d42:	06 f0 78 45 	r4 = r4 + 376;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84201d46:	ff fd c7 f1 	call (m) 0x3ad3a;
84201d4a:	35 ef 
    if (*timer_id != TIMER_ID_INVALID)
84201d4c:	32 e8       	r0 = M[r4 + Null];
84201d4e:	07 60       	if EQ jump (m) Lc_validate_channels_and_build_12;

84201d50 <Lc_validate_channels_and_build_11>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
84201d50:	04 00       	r2 = Null + Null;
84201d52:	03 00       	r1 = Null + Null;
84201d54:	ff fd 22 f0 	call (m) 0x6292;
84201d58:	3f e9 
        *timer_id = TIMER_ID_INVALID;
84201d5a:	30 ee       	M[r4 + Null] = Null;

84201d5c <Lc_validate_channels_and_build_12>:
    }
    interrupt_unblock();
84201d5c:	ff fd c7 f1 	call (m) 0x3ad56;
84201d60:	3b ef 
84201d62:	ee 6f       	jump (m) Lc_validate_channels_and_build_9;

84201d64 <Lc_validate_channels_and_build_13>:

  aFailed:
    /* it failed to complete the build for some reason,
     * clean up all the graphs.
     */
    aec_reference_cleanup(op_data);
84201d64:	52 08       	r0 = r8 + Null;
84201d66:	fc ff 27 e2 	call (m) $_aec_reference_cleanup;
    return FALSE;
84201d6a:	02 00       	r0 = Null + Null;

84201d6c <Lc_validate_channels_and_build_14>:
}
84201d6c:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84201d6e:	d8 4c       	rts;

84201d70 <$_aec_reference_update_mic_channel_status>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \return whether there is a change in speaker channel status that requires
 *         rebuilding of the speaker graph.
 */
bool aec_reference_update_mic_channel_status(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201d70:	72 1c       	pushm <FP(=SP), r4, r5>;

    unsigned i;
    unsigned mic_channel_status=0;
84201d72:	03 00       	r1 = Null + Null;
    unsigned number_mics=0;
84201d74:	04 00       	r2 = Null + Null;
    tCbuffer *inputBuf,*outputBuf;

    patch_fn_shared(aec_reference);

    /* Microphones are connected */
    op_extra_data->source_kicks = 0;
84201d76:	20 f0 9b 8e 	M[r0 + 620] = Null;
    if(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1] && op_extra_data->output_stream[AEC_REF_OUTPUT_TERMINAL1])
84201d7a:	91 88       	rMAC = M[r0 + 8];
84201d7c:	3c 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_17;

84201d7e <Lc_aec_reference_update_mic_channel_status_2>:
84201d7e:	d1 a8       	rMAC = M[r0 + 76];
84201d80:	3a 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_17;

84201d82 <Lc_aec_reference_update_mic_channel_status_3>:
    {
        bool all_mic_channels = TRUE;
        for(i=0;i<MAX_NUMBER_MICS;i++)
84201d82:	01 00       	rMAC = Null + Null;
84201d84:	04 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_5;

84201d86 <Lc_aec_reference_update_mic_channel_status_4>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
84201d86:	08 25       	Null = rMAC - 4;
84201d88:	02 f0 8f e0 	if C jump (m) Lc_aec_reference_update_mic_channel_status_6;

84201d8c <Lc_aec_reference_update_mic_channel_status_5>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
84201d8c:	8d 20       	r3 = rMAC + 2;
        {
            inputBuf  = op_extra_data->input_stream[MicrophoneTerminalByIndex(i)];
84201d8e:	6d 54       	r3 = r3 LSHIFT 2;
84201d90:	56 e9       	r4 = M[r0 + r3];

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84201d92:	cd 20       	r3 = rMAC + 3;
84201d94:	05 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_7;

84201d96 <Lc_aec_reference_update_mic_channel_status_6>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201d96:	0d 22       	r3 = rMAC + 8;
84201d98:	6d 54       	r3 = r3 LSHIFT 2;
84201d9a:	56 e9       	r4 = M[r0 + r3];
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84201d9c:	4d 22       	r3 = rMAC + 9;

84201d9e <Lc_aec_reference_update_mic_channel_status_7>:
            outputBuf = op_extra_data->output_stream[OutputTerminalByIndex(i)];
84201d9e:	27 f0 40 20 	r5 = r0 + 64;
84201da2:	6d 54       	r3 = r3 LSHIFT 2;
84201da4:	7d e9       	r3 = M[r5 + r3];

            if(inputBuf && outputBuf)
84201da6:	30 04       	Null = r4 - Null;
84201da8:	20 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_15;

84201daa <Lc_aec_reference_update_mic_channel_status_8>:
84201daa:	28 04       	Null = r3 - Null;
84201dac:	20 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_16;

84201dae <Lc_aec_reference_update_mic_channel_status_9>:
            {
                number_mics++;
84201dae:	64 20       	r2 = r2 + 1;

                if(i<4)
84201db0:	08 25       	Null = rMAC - 4;
84201db2:	02 f0 a9 e0 	if C jump (m) Lc_aec_reference_update_mic_channel_status_14;

84201db6 <Lc_aec_reference_update_mic_channel_status_10>:
                {
                    mic_channel_status |= (AEC_REFERENCE_CONSTANT_CONN_MIKE_1<<i);
84201db6:	0d 00       	r3 = rMAC + Null;
84201db8:	00 f5 95 de 	r3 = 0x1 LSHIFT r3;
84201dbc:	5b 13       	r1 = r1 OR r3;

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84201dbe:	cd 20       	r3 = rMAC + 3;

84201dc0 <Lc_aec_reference_update_mic_channel_status_11>:
                }
                else
                {
                    mic_channel_status |= ((AEC_REFERENCE_CONSTANT_CONN_MIKE_5>>4)<<i);
                }
                op_extra_data->source_kicks |= (1 << OutputTerminalByIndex(i) );
84201dc0:	00 f5 95 de 	r3 = 0x1 LSHIFT r3;
84201dc4:	26 f0 9b 88 	r4 = M[r0 + 620];
84201dc8:	ad 13       	r3 = r3 OR r4;
84201dca:	25 f0 9b 8e 	M[r0 + 620] = r3;

84201dce <Lc_aec_reference_update_mic_channel_status_12>:
    /* Microphones are connected */
    op_extra_data->source_kicks = 0;
    if(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1] && op_extra_data->output_stream[AEC_REF_OUTPUT_TERMINAL1])
    {
        bool all_mic_channels = TRUE;
        for(i=0;i<MAX_NUMBER_MICS;i++)
84201dce:	49 20       	rMAC = rMAC + 1;
84201dd0:	08 26       	Null = rMAC - 8;
84201dd2:	da 65       	if NC jump (m) Lc_aec_reference_update_mic_channel_status_4;

84201dd4 <Lc_aec_reference_update_mic_channel_status_13>:
            mic_channel_status = 0;
            op_extra_data->source_kicks = 0;
        }
    }

    if(mic_channel_status == 0)
84201dd4:	18 04       	Null = r1 - Null;
84201dd6:	0f 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_17;

84201dd8 <Lc__ite_21>:
84201dd8:	33 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_27;

84201dda <Lc_aec_reference_update_mic_channel_status_14>:
                {
                    mic_channel_status |= (AEC_REFERENCE_CONSTANT_CONN_MIKE_1<<i);
                }
                else
                {
                    mic_channel_status |= ((AEC_REFERENCE_CONSTANT_CONN_MIKE_5>>4)<<i);
84201dda:	0d 00       	r3 = rMAC + Null;
84201ddc:	10 f0 00 f5 	r3 = 0x1000 LSHIFT r3;
84201de0:	95 ce 
84201de2:	5b 13       	r1 = r1 OR r3;
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84201de4:	4d 22       	r3 = rMAC + 9;
84201de6:	ed 6f       	jump (m) Lc_aec_reference_update_mic_channel_status_11;

84201de8 <Lc_aec_reference_update_mic_channel_status_15>:
                }
                op_extra_data->source_kicks |= (1 << OutputTerminalByIndex(i) );
            }
            else if(inputBuf || outputBuf)
84201de8:	28 04       	Null = r3 - Null;
84201dea:	f2 61       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_12;

84201dec <Lc_aec_reference_update_mic_channel_status_16>:
                break;
            }
        }
        if(!all_mic_channels)
        {
            number_mics=0;
84201dec:	04 00       	r2 = Null + Null;
            mic_channel_status = 0;
84201dee:	03 00       	r1 = Null + Null;
            op_extra_data->source_kicks = 0;
84201df0:	20 f0 9b 8e 	M[r0 + 620] = Null;

84201df4 <Lc_aec_reference_update_mic_channel_status_17>:
        /* we cannot form N->N mic path, see if we
         * can form 1->0 mic path, the latter would enable
         * supporting sidetone without microphone output.
         */
        inputBuf  = op_extra_data->input_stream[MicrophoneTerminalByIndex(0)];
        outputBuf = op_extra_data->output_stream[OutputTerminalByIndex(0)];
84201df4:	d5 a8       	r3 = M[r0 + 76];
        if(inputBuf != NULL && outputBuf == NULL)
84201df6:	91 88       	rMAC = M[r0 + 8];
84201df8:	23 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_27;

84201dfa <Lc_aec_reference_update_mic_channel_status_18>:
84201dfa:	28 04       	Null = r3 - Null;
84201dfc:	21 62       	if NE jump (m) Lc_aec_reference_update_mic_channel_status_27;

84201dfe <Lc_aec_reference_update_mic_channel_status_19>:
        {
            /* mic0 connected, out0 disconnected, we can have 1->0 config */
            mic_channel_status = AEC_REFERENCE_CONSTANT_CONN_MIKE_1_INPUT_ONLY;
84201dfe:	01 f0 03 f0 	r1 = Null + 1048576;
84201e02:	00 40 
            number_mics = 1;
84201e04:	44 20       	r2 = Null + 1;

            /* However check that all other mics/outs are disconnected */
            for(i=1;i<MAX_NUMBER_MICS;i++)
84201e06:	21 00       	rMAC = r2 + Null;
84201e08:	04 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_21;

84201e0a <Lc_aec_reference_update_mic_channel_status_20>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
84201e0a:	08 25       	Null = rMAC - 4;
84201e0c:	02 f0 8f e0 	if C jump (m) Lc_aec_reference_update_mic_channel_status_22;

84201e10 <Lc_aec_reference_update_mic_channel_status_21>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
84201e10:	8d 20       	r3 = rMAC + 2;
            {
                inputBuf  = op_extra_data->input_stream[MicrophoneTerminalByIndex(i)];
84201e12:	6d 54       	r3 = r3 LSHIFT 2;
84201e14:	56 e9       	r4 = M[r0 + r3];

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84201e16:	cd 20       	r3 = rMAC + 3;
84201e18:	05 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_23;

84201e1a <Lc_aec_reference_update_mic_channel_status_22>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201e1a:	0d 22       	r3 = rMAC + 8;
84201e1c:	6d 54       	r3 = r3 LSHIFT 2;
84201e1e:	56 e9       	r4 = M[r0 + r3];
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84201e20:	4d 22       	r3 = rMAC + 9;

84201e22 <Lc_aec_reference_update_mic_channel_status_23>:
                outputBuf = op_extra_data->output_stream[OutputTerminalByIndex(i)];
84201e22:	27 f0 40 20 	r5 = r0 + 64;
84201e26:	6d 54       	r3 = r3 LSHIFT 2;
84201e28:	7d e9       	r3 = M[r5 + r3];
                if(inputBuf != NULL || outputBuf != NULL)
84201e2a:	30 04       	Null = r4 - Null;
84201e2c:	03 62       	if NE jump (m) Lc_aec_reference_update_mic_channel_status_25;

84201e2e <Lc_aec_reference_update_mic_channel_status_24>:
84201e2e:	28 04       	Null = r3 - Null;
84201e30:	04 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_26;

84201e32 <Lc_aec_reference_update_mic_channel_status_25>:
                {
                    /* Another mic input and/or output is connected,
                     * we cannot have 1->0 mic path either.
                     */
                    mic_channel_status = 0;
84201e32:	03 00       	r1 = Null + Null;
                    number_mics = 0;
84201e34:	04 00       	r2 = Null + Null;
                    break;
84201e36:	04 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_27;

84201e38 <Lc_aec_reference_update_mic_channel_status_26>:
            /* mic0 connected, out0 disconnected, we can have 1->0 config */
            mic_channel_status = AEC_REFERENCE_CONSTANT_CONN_MIKE_1_INPUT_ONLY;
            number_mics = 1;

            /* However check that all other mics/outs are disconnected */
            for(i=1;i<MAX_NUMBER_MICS;i++)
84201e38:	49 20       	rMAC = rMAC + 1;
84201e3a:	08 26       	Null = rMAC - 8;
84201e3c:	e7 65       	if NC jump (m) Lc_aec_reference_update_mic_channel_status_20;

84201e3e <Lc_aec_reference_update_mic_channel_status_27>:
                }
            }
        }
    }

    if((GetMicChannelStatus(op_extra_data)) == mic_channel_status)
84201e3e:	21 f0 83 88 	rMAC = M[r0 + 524];
84201e42:	0f f0 15 f8 	r3 = rMAC AND 0x1f000f;
84201e46:	0f 00 
84201e48:	e8 04       	Null = r3 - r1;
84201e4a:	03 62       	if NE jump (m) Lc_aec_reference_update_mic_channel_status_29;

84201e4c <Lc_aec_reference_update_mic_channel_status_28>:
    {
        /* No change in the mic path */
        return FALSE;
84201e4c:	02 00       	r0 = Null + Null;
84201e4e:	0a 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_30;

84201e50 <Lc_aec_reference_update_mic_channel_status_29>:
    }

    /* update number of mics */
    op_extra_data->num_mic_channels = number_mics;
84201e50:	24 f0 85 8e 	M[r0 + 532] = r2;

    /* update mic channel status */
    SetMicChannelStatus(op_extra_data, mic_channel_status);
84201e54:	f0 ff 11 f7 	rMAC = rMAC AND 0xffe0fff0;
84201e58:	f0 1f 
84201e5a:	c9 12       	rMAC = rMAC OR r1;
84201e5c:	21 f0 83 8e 	M[r0 + 524] = rMAC;

    return TRUE;
84201e60:	42 20       	r0 = Null + 1;

84201e62 <Lc_aec_reference_update_mic_channel_status_30>:
}
84201e62:	72 48       	popm <FP, r4, r5>;
84201e64:	d8 4c       	rts;

84201e66 <$_aec_reference_update_spkr_channel_status>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \return whether there is a change in speaker channel status that requires
 *         rebuilding of the speaker graph.
 */
bool aec_reference_update_spkr_channel_status(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201e66:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
    unsigned i;
    unsigned spkr_channel_status=0;
84201e68:	03 00       	r1 = Null + Null;
    unsigned number_spkrs=0;
84201e6a:	01 00       	rMAC = Null + Null;
    tCbuffer *inputBuf,*outputBuf;

    patch_fn_shared(aec_reference);

    /* Speakers are connected */
    op_extra_data->sink_kicks   = 0;
84201e6c:	20 f0 9c 8e 	M[r0 + 624] = Null;
    if(op_extra_data->input_stream[AEC_REF_INPUT_TERMINAL1] && op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
84201e70:	14 e8       	r2 = M[r0 + Null];
84201e72:	39 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201e74 <Lc_aec_reference_update_spkr_channel_status_2>:
84201e74:	54 a8       	r2 = M[r0 + 68];
84201e76:	37 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201e78 <Lc_aec_reference_update_spkr_channel_status_3>:
    {
        int in_count=1;
84201e78:	45 20       	r3 = Null + 1;
        int out_count=1;
84201e7a:	2e 00       	r4 = r3 + Null;

        /* Master Channel is connected */
        spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_SPKR_1;
84201e7c:	03 28       	r1 = Null + 16;

        /* Primary sink is connected */
        op_extra_data->sink_kicks = (1<<AEC_REF_INPUT_TERMINAL1);
84201e7e:	29 00       	rMAC = r3 + Null;
84201e80:	21 f0 9c 8e 	M[r0 + 624] = rMAC;

        for(i=1;i<MAX_NUMBER_SPEAKERS;i++)
84201e84:	04 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_5;

84201e86 <Lc_aec_reference_update_spkr_channel_status_4>:
        {
            int sink_idx = SpeakerInputTerminalByIndex(i);
84201e86:	88 24       	Null = rMAC - 2;
84201e88:	02 f0 8b e0 	if C jump (m) Lc_aec_reference_update_spkr_channel_status_6;

84201e8c <Lc_aec_reference_update_spkr_channel_status_5>:
84201e8c:	47 20       	r5 = Null + 1;

            /* Old terminals kept for backwards compatibility */
            outputBuf = op_extra_data->output_stream[SpeakerTerminalByIndex(i)];
84201e8e:	84 20       	r2 = Null + 2;
84201e90:	03 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_7;

84201e92 <Lc_aec_reference_update_spkr_channel_status_6>:
        /* Primary sink is connected */
        op_extra_data->sink_kicks = (1<<AEC_REF_INPUT_TERMINAL1);

        for(i=1;i<MAX_NUMBER_SPEAKERS;i++)
        {
            int sink_idx = SpeakerInputTerminalByIndex(i);
84201e92:	0f 21       	r5 = rMAC + 4;

            /* Old terminals kept for backwards compatibility */
            outputBuf = op_extra_data->output_stream[SpeakerTerminalByIndex(i)];
84201e94:	4c 21       	r2 = rMAC + 5;

84201e96 <Lc_aec_reference_update_spkr_channel_status_7>:
84201e96:	28 f0 40 20 	r6 = r0 + 64;
84201e9a:	64 54       	r2 = r2 LSHIFT 2;
84201e9c:	84 f0 04 e8 	r2 = M[r6 + r2];
            inputBuf  = op_extra_data->input_stream[sink_idx];
84201ea0:	01 f7 d8 c8 	r6 = r5 LSHIFT 2;

            if(inputBuf || outputBuf)
84201ea4:	28 f0 08 e8 	r6 = M[r0 + r6];
84201ea8:	03 62       	if NE jump (m) Lc_aec_reference_update_spkr_channel_status_9;

84201eaa <Lc_aec_reference_update_spkr_channel_status_8>:
84201eaa:	20 04       	Null = r2 - Null;
84201eac:	15 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_13;

84201eae <Lc_aec_reference_update_spkr_channel_status_9>:
            {
                spkr_channel_status |= (AEC_REFERENCE_CONSTANT_CONN_SPKR_1<<i);
84201eae:	09 09       	r7 = rMAC + Null;
84201eb0:	08 f9 99 ce 	r7 = 0x10 LSHIFT r7;
84201eb4:	00 f9 73 c8 	r1 = r1 OR r7;

                if(inputBuf)
84201eb8:	0f f8 00 c2 	Null = r6 - Null;
84201ebc:	23 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_18;

84201ebe <Lc_aec_reference_update_spkr_channel_status_10>:
                {
                    op_extra_data->sink_kicks |= (1<<sink_idx);
84201ebe:	00 f7 97 de 	r5 = 0x1 LSHIFT r5;
84201ec2:	28 f0 9c 88 	r6 = M[r0 + 624];
84201ec6:	00 f8 77 c8 	r5 = r5 OR r6;
84201eca:	27 f0 9c 8e 	M[r0 + 624] = r5;
                    in_count++;
84201ece:	6d 20       	r3 = r3 + 1;

84201ed0 <Lc_aec_reference_update_spkr_channel_status_11>:
                {
                    /* Special case allows mono input split to multiple outputs*/
                    return(FALSE);
                }

                if(outputBuf)
84201ed0:	20 04       	Null = r2 - Null;
84201ed2:	1c 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_20;

84201ed4 <Lc_aec_reference_update_spkr_channel_status_12>:
                {
                    out_count++;
84201ed4:	76 20       	r4 = r4 + 1;

84201ed6 <Lc_aec_reference_update_spkr_channel_status_13>:
        spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_SPKR_1;

        /* Primary sink is connected */
        op_extra_data->sink_kicks = (1<<AEC_REF_INPUT_TERMINAL1);

        for(i=1;i<MAX_NUMBER_SPEAKERS;i++)
84201ed6:	49 20       	rMAC = rMAC + 1;
84201ed8:	08 26       	Null = rMAC - 8;
84201eda:	d6 65       	if NC jump (m) Lc_aec_reference_update_spkr_channel_status_4;

84201edc <Lc_aec_reference_update_spkr_channel_status_14>:
                    return(FALSE);
                }
            }
        }
        /* Verify complete channel setup */
        number_spkrs = out_count;
84201edc:	31 00       	rMAC = r4 + Null;
        if(in_count==out_count)
84201ede:	a8 05       	Null = r3 - r4;
84201ee0:	18 62       	if NE jump (m) Lc_aec_reference_update_spkr_channel_status_21;

84201ee2 <Lc_aec_reference_update_spkr_channel_status_15>:
        {
            /* Parallel channels */
            spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA;
84201ee2:	db cd       	r1 = r1 OR 0x1000;

84201ee4 <Lc_aec_reference_update_spkr_channel_status_16>:
            /* Mono Input.  Split outputs */
            PL_ASSERT(in_count==1);
        }
    }

    if((GetSpkrChannelStatus(op_extra_data)) == spkr_channel_status)
84201ee4:	24 f0 83 88 	r2 = M[r0 + 524];
84201ee8:	45 f1 f0 1f 	r3 = r2 AND 0x3ff0;
84201eec:	e8 04       	Null = r3 - r1;
84201eee:	0c 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_19;

84201ef0 <Lc_aec_reference_update_spkr_channel_status_17>:
        /* No change in the speaker channel status */
        return FALSE;
    }

    /* update number of speaker channels */
    op_extra_data->num_spkr_channels = number_spkrs;
84201ef0:	21 f0 84 8e 	M[r0 + 528] = rMAC;

    /* update speaker channel status */
    SetSpkrChannelStatus(op_extra_data, spkr_channel_status);
84201ef4:	41 fe 0f 00 	rMAC = r2 AND 0xffffc00f;
84201ef8:	c9 12       	rMAC = rMAC OR r1;
84201efa:	21 f0 83 8e 	M[r0 + 524] = rMAC;
    return TRUE;
84201efe:	42 20       	r0 = Null + 1;
84201f00:	18 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_25;

84201f02 <Lc_aec_reference_update_spkr_channel_status_18>:
                if(inputBuf)
                {
                    op_extra_data->sink_kicks |= (1<<sink_idx);
                    in_count++;
                }
                else if(in_count>1)
84201f02:	68 24       	Null = r3 - 1;
84201f04:	e6 6d       	if LE jump (m) Lc_aec_reference_update_spkr_channel_status_11;

84201f06 <Lc_aec_reference_update_spkr_channel_status_19>:
                {
                    /* Special case allows mono input split to multiple outputs*/
                    return(FALSE);
84201f06:	02 00       	r0 = Null + Null;
84201f08:	14 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_25;

84201f0a <Lc_aec_reference_update_spkr_channel_status_20>:

                if(outputBuf)
                {
                    out_count++;
                }
                else if(out_count>1)
84201f0a:	70 24       	Null = r4 - 1;
84201f0c:	fd 6b       	if GT jump (m) Lc_aec_reference_update_spkr_channel_status_19;

84201f0e <Lc__ite_22>:
84201f0e:	e4 6f       	jump (m) Lc_aec_reference_update_spkr_channel_status_13;

84201f10 <Lc_aec_reference_update_spkr_channel_status_21>:
        if(in_count==out_count)
        {
            /* Parallel channels */
            spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA;
        }
        else if(out_count==1)
84201f10:	70 24       	Null = r4 - 1;
84201f12:	06 62       	if NE jump (m) Lc_aec_reference_update_spkr_channel_status_23;

84201f14 <Lc_aec_reference_update_spkr_channel_status_22>:
        {
            /* Mono Output.  Mix inputs */
            spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_TYPE_MIX;
84201f14:	20 f0 00 f3 	r1 = r1 OR 0x2000;
84201f18:	53 d8 
            number_spkrs = in_count;
84201f1a:	29 00       	rMAC = r3 + Null;
84201f1c:	e4 6f       	jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201f1e <Lc_aec_reference_update_spkr_channel_status_23>:
        }
        else
        {
            /* Mono Input.  Split outputs */
            PL_ASSERT(in_count==1);
84201f1e:	68 24       	Null = r3 - 1;
84201f20:	e2 61       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201f22 <Lc_aec_reference_update_spkr_channel_status_24>:
84201f22:	03 f0 39 4a 	r1 = Null + 1593;
84201f26:	02 f0 13 60 	r0 = Null + 4115;
84201f2a:	ff fd a8 f0 	call (m) 0x16ff0;
84201f2e:	27 e6 

84201f30 <Lc_aec_reference_update_spkr_channel_status_25>:

    /* update speaker channel status */
    SetSpkrChannelStatus(op_extra_data, spkr_channel_status);
    return TRUE;

}
84201f30:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201f32:	d8 4c       	rts;

84201f34 <$_aec_reference_update_ref_channel_status>:
 *         insertion/deletion of the reference sub-path into/from speaker graph.
 */
bool aec_reference_update_ref_channel_status(AEC_REFERENCE_OP_DATA *op_extra_data)
{

    unsigned ref_channel_status = 0;
84201f34:	01 00       	rMAC = Null + Null;
    patch_fn_shared(aec_reference);

    /* Check AEC reference */
    if(op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL] && (op_extra_data->channel_status&AEC_REFERENCE_CONSTANT_CONN_MIKE_1))
84201f36:	13 a8       	r1 = M[r0 + 64];
84201f38:	0c 60       	if EQ jump (m) Lc_aec_reference_update_ref_channel_status_4;

84201f3a <Lc_aec_reference_update_ref_channel_status_2>:
84201f3a:	23 f0 83 88 	r1 = M[r0 + 524];
84201f3e:	1b c0       	r1 = r1 AND 0x1;
84201f40:	08 60       	if EQ jump (m) Lc_aec_reference_update_ref_channel_status_4;

84201f42 <Lc_aec_reference_update_ref_channel_status_3>:
    {
        op_extra_data->source_kicks |= 1<<AEC_REF_REFERENCE_TERMINAL;
84201f42:	21 f0 9b 88 	rMAC = M[r0 + 620];
84201f46:	09 c8       	rMAC = rMAC OR 0x1;
84201f48:	21 f0 9b 8e 	M[r0 + 620] = rMAC;
        ref_channel_status = AEC_REFERENCE_CONSTANT_CONN_TYPE_REF;
84201f4c:	21 f0 00 40 	rMAC = Null + 16384;

84201f50 <Lc_aec_reference_update_ref_channel_status_4>:
    }

    if(ref_channel_status == (GetRefChannelStatus(op_extra_data)))
84201f50:	23 f0 83 88 	r1 = M[r0 + 524];
84201f54:	34 f2 00 00 	r2 = r1 AND 0x4000;
84201f58:	08 05       	Null = rMAC - r2;
84201f5a:	03 62       	if NE jump (m) Lc_aec_reference_update_ref_channel_status_6;

84201f5c <Lc_aec_reference_update_ref_channel_status_5>:
    {
        /* No change in reference path */
        return FALSE;
84201f5c:	02 00       	r0 = Null + Null;
84201f5e:	07 6e       	jump (m) Lc_aec_reference_update_ref_channel_status_7;

84201f60 <Lc_aec_reference_update_ref_channel_status_6>:
    }

    /* reference path has changed, update
     * channel status.
     */
    SetRefChannelStatus(op_extra_data, ref_channel_status);
84201f60:	33 fd ff 1f 	r1 = r1 AND 0xffffbfff;
84201f64:	c9 12       	rMAC = rMAC OR r1;
84201f66:	21 f0 83 8e 	M[r0 + 524] = rMAC;
    return TRUE;
84201f6a:	42 20       	r0 = Null + 1;

84201f6c <Lc_aec_reference_update_ref_channel_status_7>:
84201f6c:	d8 4c       	rts;

84201f6e <$_aec_reference_update_sidetone_method>:
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \return whether there is a change in sidetone mixing method
 */
void aec_reference_update_sidetone_method(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201f6e:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201f70:	16 00       	r4 = r0 + Null;
    AEC_REFERENCE_SIDETONE_METHOD sidetone_method = AEC_SIDETONE_NOT_REQUIRED;
84201f72:	07 00       	r5 = Null + Null;
    patch_fn_shared(aec_reference);

    /* reset state of sidetone */
    aec_reference_update_sidetone_status(op_extra_data);
84201f74:	f9 ff 25 eb 	call (m) $_aec_reference_update_sidetone_status;

    /* update HW sidetone availability */
    if((op_extra_data->params.OFFSET_CONFIG & AEC_REFERENCE_CONFIG_SUPPORT_HW_SIDETONE)
       != 0)
84201f78:	61 f0 34 88 	rMAC = M[r4 + 208];
84201f7c:	c9 c0       	rMAC = rMAC AND 0x4;
84201f7e:	0b 60       	if EQ jump (m) Lc_aec_reference_update_sidetone_method_3;

84201f80 <Lc_aec_reference_update_sidetone_method_2>:
    {
        /* See if current mic and speaker HW setup to do side tone mixing */
        op_extra_data->hw_sidetone_available =
            opmgr_override_have_sidetone_route(op_extra_data->mic_endpoint,
                                               op_extra_data->spkr_endpoint);
84201f80:	63 f0 a3 88 	r1 = M[r4 + 652];
84201f84:	62 f0 a2 88 	r0 = M[r4 + 648];
84201f88:	ff fd 1a f0 	call (m) 0x54aa;
84201f8c:	23 e9 
84201f8e:	62 f0 6e 8e 	M[r4 + 440] = r0;
84201f92:	03 6e       	jump (m) Lc_aec_reference_update_sidetone_method_4;

84201f94 <Lc_aec_reference_update_sidetone_method_3>:
    }
    else
    {
        op_extra_data->hw_sidetone_available = FALSE;
84201f94:	60 f0 6e 8e 	M[r4 + 440] = Null;

84201f98 <Lc_aec_reference_update_sidetone_method_4>:
    }

    /* If the config needs sidetone, decide which method it should use */
    if(op_extra_data->using_sidetone == USE_SIDETONE_FLAG)
84201f98:	61 f0 9a 88 	rMAC = M[r4 + 616];
84201f9c:	c8 24       	Null = rMAC - 3;
84201f9e:	0c 62       	if NE jump (m) Lc_aec_reference_update_sidetone_method_8;

84201fa0 <Lc_aec_reference_update_sidetone_method_5>:
    {
        if(op_extra_data->hw_sidetone_available)
84201fa0:	60 f0 6e 88 	Null = M[r4 + 440];
84201fa4:	03 60       	if EQ jump (m) Lc_aec_reference_update_sidetone_method_7;

84201fa6 <Lc_aec_reference_update_sidetone_method_6>:
        {
            /* if the config can have sidetone mixing in Hw then use that method */
            sidetone_method = AEC_SIDETONE_IN_HW;
84201fa6:	47 20       	r5 = Null + 1;
84201fa8:	07 6e       	jump (m) Lc_aec_reference_update_sidetone_method_8;

84201faa <Lc_aec_reference_update_sidetone_method_7>:
        {
            /* HW side tone isn't supported, and speaker and mic are
             * running at high task period, use separate graph for sidetone
             * mixing which will run at decimated task period.
             */
            sidetone_method = AEC_SIDETONE_IN_SW_USING_SEPARATE_GRAPH;
84201faa:	61 f0 6a 88 	rMAC = M[r4 + 424];
84201fae:	c7 20       	r5 = Null + 3;
84201fb0:	48 24       	Null = rMAC - 1;
84201fb2:	a9 f0 47 ce 	if LS r5 = Null + 2;

84201fb6 <Lc_aec_reference_update_sidetone_method_8>:
            sidetone_method = AEC_SIDETONE_IN_SW_BY_MIC_SPKR_GRAPH;
        }
    }

    /* update sidetone mixing method */
    op_extra_data->sidetone_method = sidetone_method;
84201fb6:	67 f0 bc 8b 	MB[r4 + 444] = r5;

84201fba <Lc_aec_reference_update_sidetone_method_9>:

}
84201fba:	f2 48       	popm <FP, r4, r5, rLink>;
84201fbc:	d8 4c       	rts;

84201fbe <$_aec_reference_build_graphs>:
 * \brief clean up speaker graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool aec_reference_build_graphs(AEC_REFERENCE_OP_DATA *op_extra_data, bool spkr_changed, bool mic_changed)
{
84201fbe:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201fc0:	16 00       	r4 = r0 + Null;
84201fc2:	44 de       	M[FP + 32] = r2;
84201fc4:	1b 09       	r9 = r1 + Null;
    unsigned max_sample_rate;

    patch_fn_shared(aec_reference);

    /* nothing to do if neither speaker nor mic has changed */
    if(!spkr_changed && !mic_changed)
84201fc6:	03 62       	if NE jump (m) Lc_aec_reference_build_graphs_3;

84201fc8 <Lc_aec_reference_build_graphs_2>:
84201fc8:	41 d8       	rMAC = M[FP + 32];
84201fca:	71 60       	if EQ jump (m) Lc_aec_reference_build_graphs_21;

84201fcc <Lc_aec_reference_build_graphs_3>:
    {
        return TRUE;
    }

    max_sample_rate = op_extra_data->mic_rate;
84201fcc:	62 f0 72 88 	r0 = M[r4 + 456];
    max_sample_rate = MAX(max_sample_rate, op_extra_data->spkr_rate);
84201fd0:	61 f0 7b 88 	rMAC = M[r4 + 492];
84201fd4:	50 04       	Null = r0 - rMAC;
84201fd6:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_5;

84201fda <Lc_aec_reference_build_graphs_4>:
84201fda:	0a 00       	r0 = rMAC + Null;

84201fdc <Lc_aec_reference_build_graphs_5>:
    max_sample_rate = MAX(max_sample_rate, op_extra_data->input_rate);
84201fdc:	61 f0 70 88 	rMAC = M[r4 + 448];
84201fe0:	50 04       	Null = r0 - rMAC;
84201fe2:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_7;

84201fe6 <Lc_aec_reference_build_graphs_6>:
84201fe6:	0a 00       	r0 = rMAC + Null;

84201fe8 <Lc_aec_reference_build_graphs_7>:
    max_sample_rate = MAX(max_sample_rate, op_extra_data->output_rate);
84201fe8:	61 f0 71 88 	rMAC = M[r4 + 452];
84201fec:	50 04       	Null = r0 - rMAC;
84201fee:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_9;

84201ff2 <Lc_aec_reference_build_graphs_8>:
84201ff2:	0a 00       	r0 = rMAC + Null;

84201ff4 <Lc_aec_reference_build_graphs_9>:
    op_extra_data->max_io_rate = max_sample_rate;
84201ff4:	62 f0 69 8e 	M[r4 + 420] = r0;

    /* 1ms more than a task period for max sample rate in all corners,
     * few samples more for considering resampling extra outputs.
     */
    size = frac_mult(max_sample_rate, op_extra_data->task_period_frac) + 4;
84201ff8:	63 f0 66 88 	r1 = M[r4 + 408];
84201ffc:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84202000:	29 f0 04 20 	r7 = r0 + 4;

    /* Min size, was constant size of 100 words before introducing,
     * configurable task period, don't go below that tested value.
     */
    size = MAX(size, 100);
84202004:	90 f0 64 24 	Null = r7 - 100;
84202008:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_build_graphs_11;

8420200c <Lc_aec_reference_build_graphs_10>:
8420200c:	09 f0 64 40 	r7 = Null + 100;

84202010 <Lc_aec_reference_build_graphs_11>:

    /* allocate buffer needed for resampler */
    if(op_extra_data->resampler_temp_buffer == NULL)
84202010:	61 f0 32 88 	rMAC = M[r4 + 200];
84202014:	58 62       	if NE jump (m) Lc_aec_reference_build_graphs_24;

84202016 <Lc_aec_reference_build_graphs_12>:
    {
        /* resampler_temp_buffer_size must already have been calculated */
        PL_ASSERT(0 != op_extra_data->resampler_temp_buffer_size);
84202016:	62 f0 33 88 	r0 = M[r4 + 204];
8420201a:	4b 62       	if NE jump (m) Lc_aec_reference_build_graphs_22;

8420201c <Lc_aec_reference_build_graphs_13>:
8420201c:	03 f0 84 51 	r1 = Null + 2436;
84202020:	02 f0 13 60 	r0 = Null + 4115;
84202024:	ff fd a7 f0 	call (m) 0x16ff0;
84202028:	2d ee 
8420202a:	6f 6e       	jump (m) Lc_aec_reference_build_graphs_32;

8420202c <Lc_aec_reference_build_graphs_14>:
        }
    }

    /** Setup Latency Control */
    {
    	unsigned jitter = frac_mult(op_extra_data->output_rate,op_extra_data->task_period_frac);
8420202c:	62 f0 71 88 	r0 = M[r4 + 452];
84202030:	63 f0 66 88 	r1 = M[r4 + 408];
84202034:	00 f3 72 c9 	r0 = r0 * r1 (frac);

	    op_extra_data->sync_block.jitter     = 	jitter + (jitter>>1);				/* 1.5 times task period */
84202038:	13 50       	r1 = r0 LSHIFT -1;
8420203a:	99 00       	rMAC = r1 + r0;
8420203c:	61 f0 ab 8e 	M[r4 + 684] = rMAC;
	    op_extra_data->sync_block.ref_delay  = frac_mult(op_extra_data->output_rate,FRACTIONAL(0.001)); 	 /* 1.0 msec */
84202040:	62 f0 71 88 	r0 = M[r4 + 452];
84202044:	02 f0 63 f0 	r1 = Null + 2147483;
84202048:	9b 48 
8420204a:	00 f3 72 c9 	r0 = r0 * r1 (frac);
8420204e:	62 f0 b0 8e 	M[r4 + 704] = r0;
	    op_extra_data->sync_block.block_sync = 0;
84202052:	60 f0 ad 8e 	M[r4 + 692] = Null;
	    op_extra_data->sync_block.rm_adjustment = 0;
84202056:	60 f0 b2 8e 	M[r4 + 712] = Null;
        op_extra_data->sync_block.frm_count = 0;
8420205a:	60 f0 b1 8e 	M[r4 + 708] = Null;
    }

    if(spkr_changed)
8420205e:	0f fb 00 c2 	Null = r9 - Null;
84202062:	09 60       	if EQ jump (m) Lc_aec_reference_build_graphs_16;

84202064 <Lc_aec_reference_build_graphs_15>:
    {
        /* any change in main speaker path will cause full
         * rebuild of every thing from scratch
         */
        aec_reference_cleanup_spkr_graph(op_extra_data);
84202064:	32 00       	r0 = r4 + Null;
84202066:	01 f0 23 ed 	call (m) $_aec_reference_cleanup_spkr_graph;
        /* rebuild speaker graph */
        if(!build_spkr_graph(op_extra_data))
8420206a:	32 00       	r0 = r4 + Null;
8420206c:	fb ff 3d ec 	call (m) $_build_spkr_graph;
84202070:	10 04       	Null = r0 - Null;
84202072:	27 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84202074 <Lc_aec_reference_build_graphs_16>:
        {
            return FALSE;
        }
    }

    if(mic_changed)
84202074:	41 d8       	rMAC = M[FP + 32];
84202076:	09 60       	if EQ jump (m) Lc_aec_reference_build_graphs_18;

84202078 <Lc_aec_reference_build_graphs_17>:
    {
        /* if only mic has changed, then only mic graph will be rebuilt */
        aec_reference_cleanup_mic_graph(op_extra_data);
84202078:	32 00       	r0 = r4 + Null;
8420207a:	01 f0 2b e7 	call (m) $_aec_reference_cleanup_mic_graph;

        /* mic graph is rebuilt if there is a change
         * in either mic path or speaker path */
        if(!build_mic_graph(op_extra_data))
8420207e:	32 00       	r0 = r4 + Null;
84202080:	fa ff 23 ea 	call (m) $_build_mic_graph;
84202084:	10 04       	Null = r0 - Null;
84202086:	1d 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84202088 <Lc_aec_reference_build_graphs_18>:
        }
    }

    /* update mic and speaker graphs to include sidetone mix if required */
    if(!aec_reference_mic_spkr_include_sidetone(
           op_extra_data, op_extra_data->sidetone_method == AEC_SIDETONE_IN_SW_BY_MIC_SPKR_GRAPH))
84202088:	61 f0 bc 81 	rMAC = MBS[r4 + 444];
8420208c:	03 00       	r1 = Null + Null;
8420208e:	88 24       	Null = rMAC - 2;
84202090:	20 f0 43 ce 	if EQ r1 = Null + 1;
84202094:	32 00       	r0 = r4 + Null;
84202096:	3b 4e       	call (m) $_aec_reference_mic_spkr_include_sidetone;
84202098:	10 04       	Null = r0 - Null;
8420209a:	13 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

8420209c <Lc_aec_reference_build_graphs_19>:
        return FALSE;
    }

#ifdef AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING
    /* build separate sidetone graph if required */
    if(!build_sidetone_graph(op_extra_data))
8420209c:	32 00       	r0 = r4 + Null;
8420209e:	03 f0 21 eb 	call (m) $_build_sidetone_graph;
842020a2:	10 04       	Null = r0 - Null;
842020a4:	0e 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

842020a6 <Lc_aec_reference_build_graphs_20>:
        return FALSE;
    }
#endif /* AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING */

    /*  Re-init */
    op_extra_data->ReInitFlag = TRUE;
842020a6:	41 20       	rMAC = Null + 1;
842020a8:	61 f0 5d 8e 	M[r4 + 372] = rMAC;

842020ac <Lc_aec_reference_build_graphs_21>:
    patch_fn_shared(aec_reference);

    /* nothing to do if neither speaker nor mic has changed */
    if(!spkr_changed && !mic_changed)
    {
        return TRUE;
842020ac:	42 20       	r0 = Null + 1;
842020ae:	2d 6e       	jump (m) Lc_aec_reference_build_graphs_32;

842020b0 <Lc_aec_reference_build_graphs_22>:
    {
        /* resampler_temp_buffer_size must already have been calculated */
        PL_ASSERT(0 != op_extra_data->resampler_temp_buffer_size);

        op_extra_data->resampler_temp_buffer =
            (unsigned*)xzpmalloc(op_extra_data->resampler_temp_buffer_size*sizeof(unsigned));
842020b0:	c3 20       	r1 = Null + 3;
842020b2:	52 54       	r0 = r0 LSHIFT 2;
842020b4:	ff fd 23 f0 	call (m) 0x68a6;
842020b8:	33 ef 
        if(op_extra_data->resampler_temp_buffer == NULL)
842020ba:	62 f0 32 8e 	M[r4 + 200] = r0;
842020be:	03 62       	if NE jump (m) Lc_aec_reference_build_graphs_24;

842020c0 <Lc_aec_reference_build_graphs_23>:
        {
            return FALSE;
842020c0:	02 00       	r0 = Null + Null;
842020c2:	23 6e       	jump (m) Lc_aec_reference_build_graphs_32;

842020c4 <Lc_aec_reference_build_graphs_24>:

    /* get the number of required scratch buffers based
     * on the number of speakers and mics that we have.
     */
    num_scratch_buffs = (MAX(op_extra_data->num_spkr_channels,
                             op_extra_data->num_mic_channels))*2;
842020c4:	61 f0 84 88 	rMAC = M[r4 + 528];
842020c8:	62 f0 85 88 	r0 = M[r4 + 532];
842020cc:	88 04       	Null = rMAC - r0;
842020ce:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_26;

842020d2 <Lc_aec_reference_build_graphs_25>:
842020d2:	02 6e       	jump (m) Lc_aec_reference_build_graphs_27;

842020d4 <Lc_aec_reference_build_graphs_26>:
842020d4:	0a 00       	r0 = rMAC + Null;

842020d6 <Lc_aec_reference_build_graphs_27>:
842020d6:	00 f2 da d8 	r8 = r0 LSHIFT 1;

    /* create scratch buffers, some of them might
     * already have been created */
    for(i=0;i<num_scratch_buffs;i++)
842020da:	07 00       	r5 = Null + Null;
842020dc:	68 f0 84 20 	r6 = r4 + 132;

842020e0 <Lc_aec_reference_build_graphs_28>:
842020e0:	af f7 00 c2 	Null = r5 - r8;
842020e4:	f2 ff c9 ee 	if C jump (m) Lc_aec_reference_build_graphs_14;

842020e8 <Lc_aec_reference_build_graphs_29>:
    {
        if(NULL == op_extra_data->scratch_bufs[i])
842020e8:	81 f0 00 e8 	rMAC = M[r6 + Null];
842020ec:	0b 62       	if NE jump (m) Lc_aec_reference_build_graphs_31;

842020ee <Lc_aec_reference_build_graphs_30>:
        {
            op_extra_data->scratch_bufs[i] = cbuffer_create_with_malloc_fast(size, BUF_DESC_SW_BUFFER);
842020ee:	03 00       	r1 = Null + Null;
842020f0:	4a 08       	r0 = r7 + Null;
842020f2:	ff fd 90 f0 	call (m) 0x142d4;
842020f6:	23 ef 
842020f8:	82 f0 00 ee 	M[r6 + Null] = r0;
            if(!op_extra_data->scratch_bufs[i])
842020fc:	81 f0 00 e8 	rMAC = M[r6 + Null];
84202100:	e0 61       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84202102 <Lc_aec_reference_build_graphs_31>:
    num_scratch_buffs = (MAX(op_extra_data->num_spkr_channels,
                             op_extra_data->num_mic_channels))*2;

    /* create scratch buffers, some of them might
     * already have been created */
    for(i=0;i<num_scratch_buffs;i++)
84202102:	7f 20       	r5 = r5 + 1;
84202104:	20 75       	r6 = r6 + 4;
84202106:	ed 6f       	jump (m) Lc_aec_reference_build_graphs_28;

84202108 <Lc_aec_reference_build_graphs_32>:

    /*  Re-init */
    op_extra_data->ReInitFlag = TRUE;

    return TRUE;
}
84202108:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420210a:	d8 4c       	rts;

8420210c <$_aec_reference_mic_spkr_include_sidetone>:
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \param include_sidetone whether to add or remove sidetone from graphs
 */
bool aec_reference_mic_spkr_include_sidetone(AEC_REFERENCE_OP_DATA* op_extra_data, bool include_sidetone)
{
8420210c:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
8420210e:	16 00       	r4 = r0 + Null;
    cbops_graph *spkr_graph = op_extra_data->spkr_graph;
    cbops_graph *mic_graph = op_extra_data->mic_graph;
84202110:	68 f0 75 88 	r6 = M[r4 + 468];

    /* we need to have a speaker graph */
    if(NULL == spkr_graph || NULL == mic_graph)
84202114:	6b f0 7f 88 	r9 = M[r4 + 508];
84202118:	04 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_3;

8420211a <Lc_aec_reference_mic_spkr_include_sidetone_2>:
8420211a:	0f f8 00 c2 	Null = r6 - Null;
8420211e:	a2 62       	if NE jump (m) Lc_aec_reference_mic_spkr_include_sidetone_16;

84202120 <Lc_aec_reference_mic_spkr_include_sidetone_3>:
    {
        /* No action if we don't have a speaker graph
         * however in that case we expect the sidetone is
         * not active.
         */
        PL_ASSERT(op_extra_data->spkr_sidetone_active == FALSE);
84202120:	60 f0 86 88 	Null = M[r4 + 536];
84202124:	9d 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_15;

84202126 <Lc_aec_reference_mic_spkr_include_sidetone_4>:
84202126:	03 f0 4b 4b 	r1 = Null + 1867;
8420212a:	02 f0 13 60 	r0 = Null + 4115;
8420212e:	ff fd a7 f0 	call (m) 0x16ff0;
84202132:	23 e6 
84202134:	0f f0 ad e4 	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

84202138 <Lc_aec_reference_mic_spkr_include_sidetone_5>:
            mic_st_rs_idx = op_extra_data->mic_st_input_idx;
        }
        else
        {
            /* no resampler, sidetone filter will transfer from internal buffer to output */
            mic_st_rs_idx = op_extra_data->mic_st_idx;
84202138:	61 f0 94 88 	rMAC = M[r4 + 592];
8420213c:	49 de       	M[FP + 36] = rMAC;

8420213e <Lc_aec_reference_mic_spkr_include_sidetone_6>:
        }

        /* set sidetone output buffer */
        cbops_set_output_io_buffer(mic_graph, op_extra_data->mic_st_idx, op_extra_data->mic_st_idx, op_extra_data->sidetone_buf);
8420213e:	63 f0 94 88 	r1 = M[r4 + 592];
84202142:	65 f0 31 88 	r3 = M[r4 + 196];
84202146:	1c 00       	r2 = r1 + Null;
84202148:	42 08       	r0 = r6 + Null;
8420214a:	ff fd be f0 	call (m) 0x19eb0;
8420214e:	27 eb 
            Note:  Sidetone is before resampler.
            Better solution is to place it at lowest sample rate */

        op_ptr = create_sidetone_filter_op(op_extra_data->mic_st_input_idx, mic_st_rs_idx, 3,
                                           (cbops_sidetone_params*)&op_extra_data->params.OFFSET_ST_CLIP_POINT,
                                           (void*)&op_extra_data->params.OFFSET_ST_PEQ_CONFIG);
84202150:	01 f0 10 ff 	push r4 + 272;
84202154:	16 cf 
84202156:	65 f0 f4 20 	r3 = r4 + 244;
8420215a:	c4 20       	r2 = Null + 3;
8420215c:	4b d8       	r1 = M[FP + 36];
8420215e:	62 f0 96 88 	r0 = M[r4 + 600];
84202162:	ff fd ae f1 	call (m) 0x37dc8;
84202166:	27 e3 
84202168:	7f 4c       	SP = SP + -4;
8420216a:	17 00       	r5 = r0 + Null;

        op_extra_data->mic_sidetone_op = op_ptr;
        if(!op_ptr)
8420216c:	67 f0 77 8e 	M[r4 + 476] = r5;
84202170:	a5 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_21;

84202172 <Lc_aec_reference_mic_spkr_include_sidetone_7>:
        {
            return FALSE;
        }

        /* insert resamler op into mic cbops graph */
        cbops_insert_operator_into_graph(mic_graph, op_ptr, after);
84202172:	4c 08       	r2 = r7 + Null;
84202174:	3b 00       	r1 = r5 + Null;
84202176:	42 08       	r0 = r6 + Null;
84202178:	ff fd bf f0 	call (m) 0x19f82;
8420217c:	2b e0 
        after = op_ptr;
8420217e:	3a 09       	r8 = r5 + Null;
        mic_num_st_ops++;
84202180:	09 71       	r7 = Null + 1;

        if(mic_st_rs_idx != op_extra_data->mic_st_idx)
84202182:	49 d8       	rMAC = M[FP + 36];
84202184:	62 f0 94 88 	r0 = M[r4 + 592];
84202188:	88 04       	Null = rMAC - r0;
8420218a:	24 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_10;

8420218c <Lc_aec_reference_mic_spkr_include_sidetone_8>:
                                               &mic_st_rs_idx,
                                               &op_extra_data->mic_st_idx,
                                               op_extra_data->mic_rate,
                                               op_extra_data->spkr_rate,
                                               op_extra_data->resampler_temp_buffer_size,
                                               op_extra_data->resampler_temp_buffer, 0, 0, 0);
8420218c:	00 f0 30 cf 	push Null;
84202190:	00 f0 30 cf 	push Null;
84202194:	00 f0 30 cf 	push Null;
84202198:	61 f0 32 88 	rMAC = M[r4 + 200];
8420219c:	09 1c       	pushm <rMAC>;
8420219e:	61 f0 33 88 	rMAC = M[r4 + 204];
842021a2:	09 1c       	pushm <rMAC>;
842021a4:	61 f0 7b 88 	rMAC = M[r4 + 492];
842021a8:	09 1c       	pushm <rMAC>;
842021aa:	65 f0 72 88 	r3 = M[r4 + 456];
842021ae:	64 f0 50 22 	r2 = r4 + 592;
842021b2:	43 12       	r1 = FP + 36;
842021b4:	4a 08       	r0 = r7 + Null;
842021b6:	ff fd bf f0 	call (m) 0x1a090;
842021ba:	3b e6 
842021bc:	7a 4c       	SP = SP + -24;
842021be:	11 09       	r7 = r0 + Null;
            if(!op_ptr)
842021c0:	7d 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_21;

842021c2 <Lc_aec_reference_mic_spkr_include_sidetone_9>:
            {
                return FALSE;
            }
            cbops_insert_operator_into_graph(mic_graph, op_ptr, after);
842021c2:	3c 00       	r2 = r5 + Null;
842021c4:	4b 08       	r1 = r7 + Null;
842021c6:	42 08       	r0 = r6 + Null;
842021c8:	ff fd be f0 	call (m) 0x19f82;
842021cc:	3b ed 
            after = op_ptr;
842021ce:	4a 09       	r8 = r7 + Null;
            mic_num_st_ops++;
842021d0:	11 71       	r7 = Null + 2;

842021d2 <Lc_aec_reference_mic_spkr_include_sidetone_10>:
        }

        /* Add in disgard on sidetone */

        op_ptr = create_sink_overflow_disgard_op(1,&op_extra_data->mic_st_idx,threshold);
842021d2:	63 f0 50 22 	r1 = r4 + 592;
842021d6:	42 20       	r0 = Null + 1;
842021d8:	44 d8       	r2 = M[FP + 32];
842021da:	ff fd ae f1 	call (m) 0x37e86;
842021de:	2d e5 
842021e0:	17 00       	r5 = r0 + Null;
#if defined(IO_DEBUG)
        op_extra_data->st_disgard_op = op_ptr;
#endif
        if(!op_ptr)
842021e2:	67 f0 d2 8e 	M[r4 + 840] = r5;
842021e6:	6a 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_21;

842021e8 <Lc_aec_reference_mic_spkr_include_sidetone_11>:
        {
            return FALSE;
        }
        cbops_insert_operator_into_graph(mic_graph,op_ptr, after);
842021e8:	54 08       	r2 = r8 + Null;
842021ea:	3b 00       	r1 = r5 + Null;
842021ec:	42 08       	r0 = r6 + Null;
842021ee:	ff fd be f0 	call (m) 0x19f82;
842021f2:	35 ec 
        mic_num_st_ops++;
842021f4:	09 75       	r7 = r7 + 1;

        /* save last operator in sidetone sub-path,
         * will be needed when removing the graph
         */
        op_extra_data->mic_st_last_op = op_ptr;
842021f6:	67 f0 97 8e 	M[r4 + 604] = r5;
        op_extra_data->mic_num_st_ops = mic_num_st_ops;
842021fa:	69 f0 95 8e 	M[r4 + 596] = r7;
        /** -------------------- SPKR SIDETONE SUB PATH ---------------------- **/
        /* Add sidetone mixer to resampler section,  Master channel only */
        cbops_set_input_io_buffer(spkr_graph,
                                  op_extra_data->spkr_st_in_idx,
                                  op_extra_data->spkr_st_in_idx,
                                  op_extra_data->sidetone_buf);
842021fe:	63 f0 8c 88 	r1 = M[r4 + 560];
84202202:	65 f0 31 88 	r3 = M[r4 + 196];
84202206:	1c 00       	r2 = r1 + Null;
84202208:	5a 08       	r0 = r9 + Null;
8420220a:	ff fd be f0 	call (m) 0x19e7c;
8420220e:	33 e3 

        /* create a multi-channel sidetone mix operator,
         * number of main channels = number of speakers
         * number of sidetone channels = 1
         */
        unsigned num_st_mix_channels  = op_extra_data->num_spkr_channels;
84202210:	62 f0 84 88 	r0 = M[r4 + 528];
        unsigned spkr_channel_status = GetSpkrChannelStatus(op_extra_data);
84202214:	61 f0 83 88 	rMAC = M[r4 + 524];
84202218:	11 f1 f0 1f 	rMAC = rMAC AND 0x3ff0;
        if((spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA) == 0)
8420221c:	c9 c5       	rMAC = rMAC AND 0x1000;
8420221e:	02 62       	if NE jump (m) Lc_aec_reference_mic_spkr_include_sidetone_13;

84202220 <Lc_aec_reference_mic_spkr_include_sidetone_12>:
        {
            /* speaker path isn't parallel channels,
             * sidetone mix has only one main channel
             */
            num_st_mix_channels = 1;
84202220:	42 20       	r0 = Null + 1;

84202222 <Lc_aec_reference_mic_spkr_include_sidetone_13>:
            num_st_mix_channels,                /* number of main channels */
            op_extra_data->spkr_stmix_in_idx,   /* idx for first input channel */
            op_extra_data->spkr_stmix_in_idx,   /* idx for first output channel */
            1,                                  /* number of sidetone channels */
            op_extra_data->spkr_st_in_idx,      /* idx for first sidetone input */
            op_extra_data->spkr_out_threshold); /* threshold for latency control */
84202222:	63 f0 8a 88 	r1 = M[r4 + 552];
84202226:	61 f0 a9 88 	rMAC = M[r4 + 676];
8420222a:	09 1c       	pushm <rMAC>;
8420222c:	61 f0 8c 88 	rMAC = M[r4 + 560];
84202230:	09 1c       	pushm <rMAC>;
84202232:	45 20       	r3 = Null + 1;
84202234:	1c 00       	r2 = r1 + Null;
84202236:	08 f0 3d e8 	call (m) $_create_multichan_sidetone_mix_op;
8420223a:	7e 4c       	SP = SP + -8;
8420223c:	17 00       	r5 = r0 + Null;
        if(op_ptr == NULL)
8420223e:	3e 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_21;

84202240 <Lc_aec_reference_mic_spkr_include_sidetone_14>:
        {
            return FALSE;
        }
        /* configure op to mix the sidetone input into all main channels */
        cbops_sidetone_mix_map_one_to_all(op_ptr, 0);
84202240:	03 00       	r1 = Null + Null;
84202242:	08 f0 33 e6 	call (m) $_cbops_sidetone_mix_map_one_to_all;

        /* insert sidetone mix operator into speaker graph */
        cbops_insert_operator_into_graph(spkr_graph, op_ptr, op_extra_data->spkr_st_point_op);
84202246:	64 f0 90 88 	r2 = M[r4 + 576];
8420224a:	3b 00       	r1 = r5 + Null;
8420224c:	5a 08       	r0 = r9 + Null;
8420224e:	ff fd be f0 	call (m) 0x19f82;
84202252:	35 e9 

        /* save the sidetone mix operator */
        op_extra_data->spkr_stmix_op = op_ptr;
84202254:	67 f0 92 8e 	M[r4 + 584] = r5;

        /* now speaker graph has sidetone mix operator */
        op_extra_data->spkr_sidetone_active = TRUE;
84202258:	41 20       	rMAC = Null + 1;
8420225a:	61 f0 86 8e 	M[r4 + 536] = rMAC;

8420225e <Lc_aec_reference_mic_spkr_include_sidetone_15>:
        /* No action if we don't have a speaker graph
         * however in that case we expect the sidetone is
         * not active.
         */
        PL_ASSERT(op_extra_data->spkr_sidetone_active == FALSE);
        return TRUE;
8420225e:	42 20       	r0 = Null + 1;
84202260:	80 6e       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

84202262 <Lc_aec_reference_mic_spkr_include_sidetone_16>:
    }

    if(!include_sidetone == !op_extra_data->spkr_sidetone_active)
84202262:	01 00       	rMAC = Null + Null;
84202264:	18 04       	Null = r1 - Null;
84202266:	20 f0 41 ce 	if EQ rMAC = Null + 1;
8420226a:	02 00       	r0 = Null + Null;
8420226c:	60 f0 86 88 	Null = M[r4 + 536];
84202270:	20 f0 42 ce 	if EQ r0 = Null + 1;
84202274:	88 04       	Null = rMAC - r0;
84202276:	f4 61       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_15;

84202278 <Lc_aec_reference_mic_spkr_include_sidetone_17>:
         * as current state.
         */
        return TRUE;
    }

    if(include_sidetone)
84202278:	18 04       	Null = r1 - Null;
8420227a:	34 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_24;

8420227c <Lc_aec_reference_mic_spkr_include_sidetone_18>:
    {
        /** -------------------- MIC SIDETONE SUB PATH ---------------------- **/
        /* side tone buffer size, 2ms more than task period */
        unsigned sidetone_buf_size = frac_mult(op_extra_data->spkr_rate,
                                               op_extra_data->task_period_frac + FRACTIONAL(0.002));
8420227c:	62 f0 7b 88 	r0 = M[r4 + 492];
84202280:	61 f0 66 88 	rMAC = M[r4 + 408];
84202284:	06 f1 13 f0 	r1 = rMAC + 4294967;
84202288:	37 31 
8420228a:	00 f3 72 c9 	r0 = r0 * r1 (frac);
        cbops_op *after = op_extra_data->mic_st_point;
8420228e:	69 f0 98 88 	r7 = M[r4 + 608];
        unsigned mic_num_st_ops = 0;
        unsigned  mic_st_rs_idx;
        cbops_op    *op_ptr;

        /* we don't expect SidetoneOA buffer already existing at this point */
        PL_ASSERT(op_extra_data->sidetone_buf == NULL);
84202292:	61 f0 31 88 	rMAC = M[r4 + 196];
84202296:	09 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_20;

84202298 <Lc_aec_reference_mic_spkr_include_sidetone_19>:
84202298:	03 f0 65 4b 	r1 = Null + 1893;
8420229c:	02 f0 13 60 	r0 = Null + 4115;
842022a0:	ff fd a6 f0 	call (m) 0x16ff0;
842022a4:	31 ea 
842022a6:	5d 6e       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

842022a8 <Lc_aec_reference_mic_spkr_include_sidetone_20>:

        /* Allocate Buffer between cbops Graphs */
        op_extra_data->sidetone_buf = cbuffer_create_with_malloc_fast(sidetone_buf_size, BUF_DESC_SW_BUFFER);
842022a8:	03 00       	r1 = Null + Null;
842022aa:	ff fd 90 f0 	call (m) 0x142d4;
842022ae:	2b e1 
842022b0:	62 f0 31 8e 	M[r4 + 196] = r0;

        if(!op_extra_data->sidetone_buf)
842022b4:	61 f0 31 88 	rMAC = M[r4 + 196];
842022b8:	03 62       	if NE jump (m) Lc_aec_reference_mic_spkr_include_sidetone_22;

842022ba <Lc_aec_reference_mic_spkr_include_sidetone_21>:
        {
            /* Not going ahead with creating mic sub path if we
             * cannot create shared buffer for sidetone path.
             */
            return FALSE;
842022ba:	02 00       	r0 = Null + Null;
842022bc:	52 6e       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

842022be <Lc_aec_reference_mic_spkr_include_sidetone_22>:
        }

        /* Minimum space needed in buffer */
        unsigned threshold = frac_mult(op_extra_data->spkr_rate,op_extra_data->task_period_frac) + 1;
842022be:	62 f0 7b 88 	r0 = M[r4 + 492];
842022c2:	63 f0 66 88 	r1 = M[r4 + 408];
842022c6:	00 f3 72 c9 	r0 = r0 * r1 (frac);
842022ca:	51 20       	rMAC = r0 + 1;
842022cc:	41 de       	M[FP + 32] = rMAC;

        if(op_extra_data->mic_rate != op_extra_data->spkr_rate)
842022ce:	61 f0 72 88 	rMAC = M[r4 + 456];
842022d2:	62 f0 7b 88 	r0 = M[r4 + 492];
842022d6:	88 04       	Null = rMAC - r0;
842022d8:	30 61       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_5;

842022da <Lc_aec_reference_mic_spkr_include_sidetone_23>:
        {
            /* Sidetone filter is inplace */
            mic_st_rs_idx = op_extra_data->mic_st_input_idx;
842022da:	61 f0 96 88 	rMAC = M[r4 + 600];
842022de:	49 de       	M[FP + 36] = rMAC;
842022e0:	2f 6f       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_6;

842022e2 <Lc_aec_reference_mic_spkr_include_sidetone_24>:
    }
    else
    {
        /** -------------------- REMOVING MIC SIDETONE SUB PATH ---------------------- **/
        /* removing sub-graph starts from its last operator */
        cbops_op *op = op_extra_data->mic_st_last_op;
842022e2:	63 f0 97 88 	r1 = M[r4 + 604];
        unsigned i;

        /* remove all the ops in the sidetone sub-path */
        for (i=0; i < op_extra_data->mic_num_st_ops; ++i)
842022e6:	07 00       	r5 = Null + Null;

842022e8 <Lc_aec_reference_mic_spkr_include_sidetone_25>:
842022e8:	61 f0 95 88 	rMAC = M[r4 + 596];
842022ec:	78 04       	Null = r5 - rMAC;
842022ee:	02 f0 97 e0 	if C jump (m) Lc_aec_reference_mic_spkr_include_sidetone_27;

842022f2 <Lc_aec_reference_mic_spkr_include_sidetone_26>:
        {
            cbops_op *prev_op = op->prev_operator_addr;
842022f2:	39 f0 00 e8 	r7 = M[r1 + Null];
            cbops_remove_operator_from_graph(mic_graph, op);
842022f6:	42 08       	r0 = r6 + Null;
842022f8:	ff fd be f0 	call (m) 0x19f54;
842022fc:	3d e2 
            op = prev_op;
842022fe:	4b 08       	r1 = r7 + Null;
        /* removing sub-graph starts from its last operator */
        cbops_op *op = op_extra_data->mic_st_last_op;
        unsigned i;

        /* remove all the ops in the sidetone sub-path */
        for (i=0; i < op_extra_data->mic_num_st_ops; ++i)
84202300:	7f 20       	r5 = r5 + 1;
84202302:	f3 6f       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_25;

84202304 <Lc_aec_reference_mic_spkr_include_sidetone_27>:
            cbops_remove_operator_from_graph(mic_graph, op);
            op = prev_op;
        }

        /*  tell the cbops not to care about sidetone buffer any more */
        cbops_unset_buffer(mic_graph, op_extra_data->mic_st_idx);
84202304:	63 f0 94 88 	r1 = M[r4 + 592];
84202308:	42 08       	r0 = r6 + Null;
8420230a:	ff fd be f0 	call (m) 0x19f9c;
8420230e:	33 e4 

        op_extra_data->mic_st_last_op = NULL;
84202310:	60 f0 97 8e 	M[r4 + 604] = Null;
        op_extra_data->mic_num_st_ops = 0;
84202314:	60 f0 95 8e 	M[r4 + 596] = Null;
        op_extra_data->mic_sidetone_op = NULL;
84202318:	60 f0 77 8e 	M[r4 + 476] = Null;

        /** -------------------- REMOVING SPKR SIDETONE SUB PATH ---------------------- **/
        /* remove the sidetone mix operator from speaker graph */
        PL_ASSERT(NULL != op_extra_data->spkr_stmix_op);
8420231c:	63 f0 92 88 	r1 = M[r4 + 584];
84202320:	09 62       	if NE jump (m) Lc_aec_reference_mic_spkr_include_sidetone_29;

84202322 <Lc_aec_reference_mic_spkr_include_sidetone_28>:
84202322:	03 f0 02 50 	r1 = Null + 2050;
84202326:	02 f0 13 60 	r0 = Null + 4115;
8420232a:	ff fd a6 f0 	call (m) 0x16ff0;
8420232e:	27 e6 
84202330:	18 6e       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

84202332 <Lc_aec_reference_mic_spkr_include_sidetone_29>:
        cbops_remove_operator_from_graph(spkr_graph, op_extra_data->spkr_stmix_op);
84202332:	5a 08       	r0 = r9 + Null;
84202334:	ff fd be f0 	call (m) 0x19f54;
84202338:	21 e1 
        op_extra_data->spkr_stmix_op = NULL;
8420233a:	60 f0 92 8e 	M[r4 + 584] = Null;

        /* also tell the cbops not to care about sidetone buffer any more */
        cbops_unset_buffer(spkr_graph, op_extra_data->spkr_st_in_idx);
8420233e:	63 f0 8c 88 	r1 = M[r4 + 560];
84202342:	5a 08       	r0 = r9 + Null;
84202344:	ff fd be f0 	call (m) 0x19f9c;
84202348:	39 e2 

        /* speaker graph no longer has sidetone mix operator*/
        op_extra_data->spkr_sidetone_active = FALSE;
8420234a:	60 f0 86 8e 	M[r4 + 536] = Null;

        /* Free Sidetone buffers, this must be
         * done after removing sidetone mix from
         * speaker graph.
         */
        if(op_extra_data->sidetone_buf != NULL)
8420234e:	62 f0 31 88 	r0 = M[r4 + 196];
84202352:	86 61       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_15;

84202354 <Lc_aec_reference_mic_spkr_include_sidetone_30>:
        {
            cbuffer_destroy(op_extra_data->sidetone_buf);
84202354:	ff fd 90 f0 	call (m) 0x1439a;
84202358:	27 e2 
            op_extra_data->sidetone_buf = NULL;
8420235a:	60 f0 31 8e 	M[r4 + 196] = Null;
8420235e:	80 6f       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_15;

84202360 <Lc_aec_reference_mic_spkr_include_sidetone_31>:

        DEBUG_GRAPHS("AEC REFERENCE: Side tone path removed!" );
    }

    return TRUE;
}
84202360:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202362:	d8 4c       	rts;

84202364 <$_aec_reference_cleanup_mic_graph>:
 * \brief clean up mic graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_mic_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84202364:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202366:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

    /* Clear links to graphs */
    op_extra_data->mic_rate_monitor_op = NULL;
84202368:	60 f0 76 8e 	M[r4 + 472] = Null;
    op_extra_data->mic_sw_rateadj_op = NULL;
8420236c:	60 f0 9d 8e 	M[r4 + 628] = Null;
    op_extra_data->mic_mute_op = NULL;
84202370:	60 f0 78 8e 	M[r4 + 480] = Null;

    /* if we have active sidetone path then remove
     * it from speaker graph
     */
    if(op_extra_data->spkr_sidetone_active)
84202374:	60 f0 86 88 	Null = M[r4 + 536];
84202378:	04 60       	if EQ jump (m) Lc_aec_reference_cleanup_mic_graph_3;

8420237a <Lc_aec_reference_cleanup_mic_graph_2>:
    {
        aec_reference_mic_spkr_include_sidetone(op_extra_data, FALSE);
8420237a:	03 00       	r1 = Null + Null;
8420237c:	fe ff 31 ec 	call (m) $_aec_reference_mic_spkr_include_sidetone;

84202380 <Lc_aec_reference_cleanup_mic_graph_3>:
    }

    /* Free cbops mic graph */
    if(op_extra_data->mic_graph != NULL)
84202380:	62 f0 75 88 	r0 = M[r4 + 468];
84202384:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_mic_graph_5;

84202386 <Lc_aec_reference_cleanup_mic_graph_4>:
    {
        destroy_graph(op_extra_data->mic_graph);
84202386:	ff fd bd f0 	call (m) 0x19e20;
8420238a:	3b e4 
        op_extra_data->mic_graph = NULL;
8420238c:	60 f0 75 8e 	M[r4 + 468] = Null;

84202390 <Lc_aec_reference_cleanup_mic_graph_5>:
    }

    /* update the state of sidetone */
    aec_reference_update_sidetone_status(op_extra_data);
84202390:	32 00       	r0 = r4 + Null;
84202392:	f7 ff 27 ea 	call (m) $_aec_reference_update_sidetone_status;

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    op_extra_data->mic_metadata_tag_left_words = 0;
84202396:	60 f0 c4 8e 	M[r4 + 784] = Null;

8420239a <Lc_aec_reference_cleanup_mic_graph_6>:
#endif

    DEBUG_GRAPHS("AEC REFERENCE: MIC graph's cleanup done!" );
}
8420239a:	f1 48       	popm <FP, r4, rLink>;
8420239c:	d8 4c       	rts;

8420239e <$_aec_reference_cleanup_graphs>:
 * \brief clean up all the cbops graphs
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_graphs(AEC_REFERENCE_OP_DATA *op_extra_data)
{
8420239e:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842023a0:	16 00       	r4 = r0 + Null;
    unsigned i;

    patch_fn_shared(aec_reference);

    /* Kill timer Task */
    timer_cancel_event_atomic(&op_extra_data->kick_id);
842023a2:	67 f0 78 21 	r5 = r4 + 376;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
842023a6:	ff fd c4 f1 	call (m) 0x3ad3a;
842023aa:	35 ec 
    if (*timer_id != TIMER_ID_INVALID)
842023ac:	3a e8       	r0 = M[r5 + Null];
842023ae:	07 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_3;

842023b0 <Lc_aec_reference_cleanup_graphs_2>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
842023b0:	04 00       	r2 = Null + Null;
842023b2:	03 00       	r1 = Null + Null;
842023b4:	ff fd 1f f0 	call (m) 0x6292;
842023b8:	3f e6 
        *timer_id = TIMER_ID_INVALID;
842023ba:	38 ee       	M[r5 + Null] = Null;

842023bc <Lc_aec_reference_cleanup_graphs_3>:
    }
    interrupt_unblock();
842023bc:	ff fd c4 f1 	call (m) 0x3ad56;
842023c0:	3b ec 

#ifdef AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING
    /* cleanup sidetone graph if we have one */
    if(NULL != op_extra_data->sidetone_graph)
842023c2:	61 f0 6c 88 	rMAC = M[r4 + 432];
842023c6:	04 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_5;

842023c8 <Lc_aec_reference_cleanup_graphs_4>:
    {
        /* clean sidetone graph */
        aec_reference_cleanup_sidetone_graph(op_extra_data);
842023c8:	32 00       	r0 = r4 + Null;
842023ca:	03 f0 35 e2 	call (m) $_aec_reference_cleanup_sidetone_graph;

842023ce <Lc_aec_reference_cleanup_graphs_5>:
    }
#endif
    /* clean mic graph */
    aec_reference_cleanup_mic_graph(op_extra_data);
842023ce:	32 00       	r0 = r4 + Null;
842023d0:	ca 4f       	call (m) $_aec_reference_cleanup_mic_graph;

    /* clean speaker graph */
    aec_reference_cleanup_spkr_graph(op_extra_data);
842023d2:	32 00       	r0 = r4 + Null;
842023d4:	1a 4e       	call (m) $_aec_reference_cleanup_spkr_graph;

    /* Free Internal buffers */
    for(i=0;i<AEC_NUM_SCRATCH_BUFFERS;i++)
842023d6:	07 00       	r5 = Null + Null;
842023d8:	68 f0 84 20 	r6 = r4 + 132;

842023dc <Lc_aec_reference_cleanup_graphs_6>:
    {
        if(op_extra_data->scratch_bufs[i] != NULL)
842023dc:	82 f0 00 e8 	r0 = M[r6 + Null];
842023e0:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_8;

842023e2 <Lc_aec_reference_cleanup_graphs_7>:
        {
            cbuffer_destroy(op_extra_data->scratch_bufs[i]);
842023e2:	ff fd 8f f0 	call (m) 0x1439a;
842023e6:	39 ed 
            op_extra_data->scratch_bufs[i] = NULL;
842023e8:	80 f0 00 ee 	M[r6 + Null] = Null;

842023ec <Lc_aec_reference_cleanup_graphs_8>:

    /* clean speaker graph */
    aec_reference_cleanup_spkr_graph(op_extra_data);

    /* Free Internal buffers */
    for(i=0;i<AEC_NUM_SCRATCH_BUFFERS;i++)
842023ec:	7f 20       	r5 = r5 + 1;
842023ee:	20 75       	r6 = r6 + 4;
842023f0:	38 2c       	Null = r5 - 16;
842023f2:	f5 65       	if NC jump (m) Lc_aec_reference_cleanup_graphs_6;

842023f4 <Lc_aec_reference_cleanup_graphs_9>:
            op_extra_data->scratch_bufs[i] = NULL;
        }
    }

    /* clear scratch buffer used by resampler operator */
    if(op_extra_data->resampler_temp_buffer != NULL)
842023f4:	62 f0 32 88 	r0 = M[r4 + 200];
842023f8:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_11;

842023fa <Lc_aec_reference_cleanup_graphs_10>:
    {
        pfree(op_extra_data->resampler_temp_buffer);
842023fa:	ff fd 22 f0 	call (m) 0x68d8;
842023fe:	3f e6 
        op_extra_data->resampler_temp_buffer = NULL;
84202400:	60 f0 32 8e 	M[r4 + 200] = Null;

84202404 <Lc_aec_reference_cleanup_graphs_11>:
    }

    DEBUG_GRAPHS("AEC REFERENCE: Full graphs cleanup done!" );
}
84202404:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84202406:	d8 4c       	rts;

84202408 <$_aec_reference_cleanup_spkr_graph>:
 * \brief clean up speaker graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_spkr_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84202408:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420240a:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

#if defined(IO_DEBUG)
    op_extra_data->insert_op = NULL;
8420240c:	60 f0 d1 8e 	M[r4 + 836] = Null;
    op_extra_data->st_disgard_op = NULL;
84202410:	60 f0 d2 8e 	M[r4 + 840] = Null;
#endif

    /* Clear links to graphs */
    op_extra_data->spkr_rate_monitor_op = NULL;
84202414:	60 f0 80 8e 	M[r4 + 512] = Null;
    op_extra_data->spkr_sw_rateadj_op = NULL;
84202418:	60 f0 9f 8e 	M[r4 + 636] = Null;
    op_extra_data->spkr_ref_point_op = NULL;
8420241c:	60 f0 8f 8e 	M[r4 + 572] = Null;
    op_extra_data->spkr_st_point_op = NULL;
84202420:	60 f0 90 8e 	M[r4 + 576] = Null;
    op_extra_data->spkr_ref_last_op = NULL;
84202424:	60 f0 91 8e 	M[r4 + 580] = Null;
    op_extra_data->spkr_ref_rs_op = NULL;
84202428:	60 f0 93 8e 	M[r4 + 588] = Null;
    op_extra_data->ref_sw_rateadj_op = NULL;
8420242c:	60 f0 9e 8e 	M[r4 + 632] = Null;

    /* if we have active sidetone path then remove
     * it from speaker graph
     */
    if(op_extra_data->spkr_sidetone_active)
84202430:	60 f0 86 88 	Null = M[r4 + 536];
84202434:	04 60       	if EQ jump (m) Lc_aec_reference_cleanup_spkr_graph_3;

84202436 <Lc_aec_reference_cleanup_spkr_graph_2>:
    {
        aec_reference_mic_spkr_include_sidetone(op_extra_data, FALSE);
84202436:	03 00       	r1 = Null + Null;
84202438:	fe ff 35 e6 	call (m) $_aec_reference_mic_spkr_include_sidetone;

8420243c <Lc_aec_reference_cleanup_spkr_graph_3>:
    }

    /* destroy speaker graph */
    if(op_extra_data->spkr_graph != NULL)
8420243c:	62 f0 7f 88 	r0 = M[r4 + 508];
84202440:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_spkr_graph_5;

84202442 <Lc_aec_reference_cleanup_spkr_graph_4>:
    {
        destroy_graph(op_extra_data->spkr_graph);
84202442:	ff fd bc f0 	call (m) 0x19e20;
84202446:	3f ee 
        op_extra_data->spkr_graph = NULL;
84202448:	60 f0 7f 8e 	M[r4 + 508] = Null;

8420244c <Lc_aec_reference_cleanup_spkr_graph_5>:
    }

    /* clear flag for reference path */
    op_extra_data->spkr_ref_active = FALSE;
8420244c:	60 f0 87 8e 	M[r4 + 540] = Null;

    /* clear flag for sidetone path */
    op_extra_data->spkr_sidetone_active = FALSE;
84202450:	60 f0 86 8e 	M[r4 + 536] = Null;

#ifdef AEC_REFERENCE_SPKR_TTP
    /* destroy any structure allocated for ttp playback */
    aec_reference_spkr_ttp_terminate(op_extra_data);
84202454:	32 00       	r0 = r4 + Null;
84202456:	05 f0 2d e0 	call (m) $_aec_reference_spkr_ttp_terminate;
#endif /* AEC_REFERENCE_SPKR_TTP */

#ifdef AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT
    /* Reset flag showing speaker started to consume data */
    op_extra_data->spkr_flow_started = FALSE;
8420245a:	60 f0 cc 8e 	M[r4 + 816] = Null;

8420245e <Lc_aec_reference_cleanup_spkr_graph_6>:
#endif

    /* TODO - Fill speakers with silence */

    DEBUG_GRAPHS("AEC REFERENCE: Speaker graph's cleanup done!" );
}
8420245e:	f1 48       	popm <FP, r4, rLink>;
84202460:	d8 4c       	rts;

84202462 <$_aec_reference_spkr_include_ref_path>:
 * \brief updates speaker graph to include/exclude path for reference output
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool aec_reference_spkr_include_ref_path(AEC_REFERENCE_OP_DATA* op_extra_data, bool include_ref_path)
{
84202462:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
84202464:	16 00       	r4 = r0 + Null;
84202466:	19 00       	rMAC = r1 + Null;
    cbops_graph *spkr_graph = op_extra_data->spkr_graph;
84202468:	68 f0 7f 88 	r6 = M[r4 + 508];
    cbops_op    *op_ptr;
    unsigned ref_idx = op_extra_data->spkr_ref_idx;
8420246c:	63 f0 8b 88 	r1 = M[r4 + 556];
84202470:	3b de       	M[FP + 28] = r1;

    /* No action if no speaker graph */
    if(NULL == spkr_graph)
84202472:	0f f8 00 c2 	Null = r6 - Null;
84202476:	58 62       	if NE jump (m) Lc_aec_reference_spkr_include_ref_path_11;

84202478 <Lc_aec_reference_spkr_include_ref_path_2>:
    {
        /* nothing to do but we expect no reference output */
        PL_ASSERT(op_extra_data->spkr_ref_active == FALSE);
84202478:	60 f0 87 88 	Null = M[r4 + 540];
8420247c:	53 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_10;

8420247e <Lc_aec_reference_spkr_include_ref_path_3>:
8420247e:	03 f0 2c 50 	r1 = Null + 2092;
84202482:	02 f0 13 60 	r0 = Null + 4115;
84202486:	ff fd a5 f0 	call (m) 0x16ff0;
8420248a:	2b eb 
8420248c:	c2 6e       	jump (m) Lc_aec_reference_spkr_include_ref_path_22;

8420248e <Lc_aec_reference_spkr_include_ref_path_4>:
            {
                return FALSE;
            }

            /* save the resampler op and it's scratch buffer index */
            op_extra_data->spkr_ref_rs_op = op_ptr;
8420248e:	67 f0 93 8e 	M[r4 + 588] = r5;
            op_extra_data->spkr_ref_rs_idx = ref_rm_in_idx;
84202492:	49 d8       	rMAC = M[FP + 36];
84202494:	61 f0 8e 8e 	M[r4 + 568] = rMAC;

            /* insert resamler op into speaker cbops graph */
            cbops_insert_operator_into_graph(spkr_graph,op_ptr, after);
84202498:	4c 08       	r2 = r7 + Null;
8420249a:	3b 00       	r1 = r5 + Null;
8420249c:	42 08       	r0 = r6 + Null;
8420249e:	ff fd bd f0 	call (m) 0x19f82;
842024a2:	25 e7 
            after = op_ptr;
842024a4:	39 09       	r7 = r5 + Null;
            spkr_num_ref_ops++;
842024a6:	0a 71       	r8 = Null + 1;

842024a8 <Lc_aec_reference_spkr_include_ref_path_5>:
        }

        /*  SW rate adjustment for reference */
        op_ptr = create_sw_rate_adj_op(1, &ref_rm_in_idx, &ref_idx,
                                       CBOPS_RATEADJUST_COEFFS,
                                       &op_extra_data->sync_block.rm_adjustment, 0);
842024a8:	00 f0 30 cf 	push Null;
842024ac:	85 2a       	r3 = Null + 26;
842024ae:	c4 11       	r2 = FP + 28;
842024b0:	43 12       	r1 = FP + 36;
842024b2:	02 f0 c8 ff 	push r4 + 712;
842024b6:	16 cf 
842024b8:	42 20       	r0 = Null + 1;
842024ba:	ff fd bb f0 	call (m) 0x19c66;
842024be:	2d ed 
842024c0:	7e 4c       	SP = SP + -8;
842024c2:	17 00       	r5 = r0 + Null;
        if(op_ptr == NULL)
842024c4:	7a 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_15;

842024c6 <Lc_aec_reference_spkr_include_ref_path_6>:
        {
            return FALSE;
        }

		/* store reference rate adjust operator */
        op_extra_data->ref_sw_rateadj_op = op_ptr;
842024c6:	67 f0 9e 8e 	M[r4 + 632] = r5;
        if(op_extra_data->mic_sync_enable)
842024ca:	60 f0 cd 88 	Null = M[r4 + 820];
842024ce:	05 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_8;

842024d0 <Lc_aec_reference_spkr_include_ref_path_7>:
        {
            /* if input and output are in the same clock, then mic output
             * can get sychronised to ref, and ref won't need rate adjustment.
             * The operator will be doing simple copy here.
             */
            cbops_rateadjust_passthrough_mode(op_ptr, TRUE);
842024d0:	43 20       	r1 = Null + 1;
842024d2:	ff fd bc f0 	call (m) 0x19d0a;
842024d6:	39 e1 

842024d8 <Lc_aec_reference_spkr_include_ref_path_8>:
        }

        /* insert rate adjust op into speaker cbops graph*/
        cbops_insert_operator_into_graph(spkr_graph, op_ptr, after);
842024d8:	4c 08       	r2 = r7 + Null;
842024da:	3b 00       	r1 = r5 + Null;
842024dc:	42 08       	r0 = r6 + Null;
842024de:	ff fd bd f0 	call (m) 0x19f82;
842024e2:	25 e5 
        after = op_ptr;
        spkr_num_ref_ops++;
842024e4:	0a 75       	r8 = r8 + 1;

        /* speaker latency cbops operator */
        op_ptr = create_speaker_latency_op(ref_idx, &op_extra_data->sync_block);
842024e6:	63 f0 ac 22 	r1 = r4 + 684;
842024ea:	3a d8       	r0 = M[FP + 28];
842024ec:	03 f0 31 ef 	call (m) $_create_speaker_latency_op;
842024f0:	11 09       	r7 = r0 + Null;
        if(op_ptr == NULL)
842024f2:	63 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_15;

842024f4 <Lc_aec_reference_spkr_include_ref_path_9>:
        {
            return FALSE;
        }
        /* insert speaker latency op into speaker cbops graph*/
        cbops_insert_operator_into_graph(spkr_graph, op_ptr, after);
842024f4:	3c 00       	r2 = r5 + Null;
842024f6:	4b 08       	r1 = r7 + Null;
842024f8:	42 08       	r0 = r6 + Null;
842024fa:	ff fd bd f0 	call (m) 0x19f82;
842024fe:	29 e4 
        spkr_num_ref_ops++;
84202500:	0a 75       	r8 = r8 + 1;
        /* save last operator in the reference sub-path and
         * also the number of operator in the sub-path,
         * these will be required when removing the
         * reference path
         */
        op_extra_data->spkr_ref_last_op = op_ptr;
84202502:	69 f0 91 8e 	M[r4 + 580] = r7;
        op_extra_data->spkr_num_ref_ops = spkr_num_ref_ops;
84202506:	6a f0 8d 8e 	M[r4 + 564] = r8;

        /* Now speaker graph includes reference sub path */
        op_extra_data->spkr_ref_active = TRUE;
8420250a:	47 20       	r5 = Null + 1;
8420250c:	67 f0 87 8e 	M[r4 + 540] = r5;

        /* have reasonable distance between MIC and REF at the beginning,
		 * assumes MIC buffer is empty now.
		 */
        cbuffer_move_write_to_read_point(op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL],
                                         op_extra_data->sync_block.jitter/2);
84202510:	62 f0 ab 88 	r0 = M[r4 + 684];
84202514:	13 50       	r1 = r0 LSHIFT -1;
84202516:	32 a8       	r0 = M[r4 + 64];
84202518:	ff fd be f1 	call (m) 0x3a14c;
8420251c:	35 e1 
 *
 * \param op pointer to cbop
 */
static inline void cbops_refresh_buffers(cbops_graph *graph)
{
   graph->refresh_buffers = TRUE;
8420251e:	87 f0 07 8e 	M[r6 + 28] = r5;

84202522 <Lc_aec_reference_spkr_include_ref_path_10>:
    /* No action if no speaker graph */
    if(NULL == spkr_graph)
    {
        /* nothing to do but we expect no reference output */
        PL_ASSERT(op_extra_data->spkr_ref_active == FALSE);
        return TRUE;
84202522:	42 20       	r0 = Null + 1;
84202524:	76 6e       	jump (m) Lc_aec_reference_spkr_include_ref_path_22;

84202526 <Lc_aec_reference_spkr_include_ref_path_11>:
    }

    if(!include_ref_path == !op_extra_data->spkr_ref_active)
84202526:	02 00       	r0 = Null + Null;
84202528:	08 04       	Null = rMAC - Null;
8420252a:	20 f0 42 ce 	if EQ r0 = Null + 1;
8420252e:	04 00       	r2 = Null + Null;
84202530:	60 f0 87 88 	Null = M[r4 + 540];
84202534:	20 f0 44 ce 	if EQ r2 = Null + 1;
84202538:	10 05       	Null = r0 - r2;
8420253a:	f4 61       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_10;

8420253c <Lc_aec_reference_spkr_include_ref_path_12>:
         * as current state.
         */
        return TRUE;
    }

    if(include_ref_path)
8420253c:	08 04       	Null = rMAC - Null;
8420253e:	3f 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_16;

84202540 <Lc_aec_reference_spkr_include_ref_path_13>:
    {
        /* Adding Reference path to speaker graph */

        unsigned ref_input_idx = op_extra_data->spkr_ref_input_idx;
84202540:	61 f0 88 88 	rMAC = M[r4 + 544];
84202544:	41 de       	M[FP + 32] = rMAC;
        unsigned ref_rm_in_idx = ref_input_idx;
84202546:	49 de       	M[FP + 36] = rMAC;
        cbops_op *after = op_extra_data->spkr_ref_point_op;
84202548:	69 f0 8f 88 	r7 = M[r4 + 572];
        unsigned spkr_num_ref_ops = 0;
8420254c:	02 09       	r8 = Null + Null;

        /* set buffer index for reference output in cbops graph */
        cbops_set_output_io_buffer(spkr_graph,
                                   ref_idx,
                                   ref_idx,
                                   op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL]);
8420254e:	35 a8       	r3 = M[r4 + 64];
84202550:	1c 00       	r2 = r1 + Null;
84202552:	42 08       	r0 = r6 + Null;
84202554:	ff fd bc f0 	call (m) 0x19eb0;
84202558:	3d ea 

        /* see if resampler is needed in reference path */
        if(op_extra_data->input_rate != op_extra_data->output_rate)
8420255a:	61 f0 70 88 	rMAC = M[r4 + 448];
8420255e:	62 f0 71 88 	r0 = M[r4 + 452];
84202562:	88 04       	Null = rMAC - r0;
84202564:	a2 61       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_5;

84202566 <Lc_aec_reference_spkr_include_ref_path_14>:
        {
            /* resampler outputs into internal buffer */
            ref_rm_in_idx = ref_idx+1;
84202566:	39 d8       	rMAC = M[FP + 28];
84202568:	4b 20       	r1 = rMAC + 1;
8420256a:	4b de       	M[FP + 36] = r1;
            /* NOTE: left scratch input is input to resampler */

            cbops_set_internal_io_buffer(spkr_graph,
                                         ref_rm_in_idx,
                                         ref_rm_in_idx,
                                         op_extra_data->scratch_bufs[op_extra_data->spkr_ref_scratch_idx]);
8420256c:	62 f0 89 88 	r0 = M[r4 + 548];
84202570:	31 00       	rMAC = r4 + Null;
84202572:	1c 00       	r2 = r1 + Null;
84202574:	52 54       	r0 = r0 LSHIFT 2;
84202576:	51 00       	rMAC = r0 + rMAC;
84202578:	15 f0 21 88 	r3 = M[rMAC + 132];
8420257c:	42 08       	r0 = r6 + Null;
8420257e:	ff fd bc f0 	call (m) 0x19ee4;
84202582:	27 eb 

            /* Add reference sample rate conversion (input_rate --> output_rate) - for 1 channel only */
            op_ptr = create_iir_resamplerv2_op(1, &ref_input_idx, &ref_rm_in_idx,
                                               op_extra_data->input_rate, op_extra_data->output_rate,
                                               op_extra_data->resampler_temp_buffer_size,
                                               op_extra_data->resampler_temp_buffer, 0, 0, 0);
84202584:	00 f0 30 cf 	push Null;
84202588:	00 f0 30 cf 	push Null;
8420258c:	00 f0 30 cf 	push Null;
84202590:	61 f0 32 88 	rMAC = M[r4 + 200];
84202594:	09 1c       	pushm <rMAC>;
84202596:	61 f0 33 88 	rMAC = M[r4 + 204];
8420259a:	09 1c       	pushm <rMAC>;
8420259c:	61 f0 71 88 	rMAC = M[r4 + 452];
842025a0:	09 1c       	pushm <rMAC>;
842025a2:	65 f0 70 88 	r3 = M[r4 + 448];
842025a6:	44 12       	r2 = FP + 36;
842025a8:	03 12       	r1 = FP + 32;
842025aa:	42 20       	r0 = Null + 1;
842025ac:	ff fd bd f0 	call (m) 0x1a090;
842025b0:	25 e7 
842025b2:	7a 4c       	SP = SP + -24;
842025b4:	17 00       	r5 = r0 + Null;

            if(op_ptr == NULL)
842025b6:	6c 63       	if NE jump (m) Lc_aec_reference_spkr_include_ref_path_4;

842025b8 <Lc_aec_reference_spkr_include_ref_path_15>:
            {
                return FALSE;
842025b8:	02 00       	r0 = Null + Null;
842025ba:	2b 6e       	jump (m) Lc_aec_reference_spkr_include_ref_path_22;

842025bc <Lc_aec_reference_spkr_include_ref_path_16>:
        DEBUG_GRAPHS("AEC REFERENCE: Reference path added!" );
    }
    else
    {
        /* removing sub-graph starts from its last operator */
        cbops_op *op = op_extra_data->spkr_ref_last_op;
842025bc:	63 f0 91 88 	r1 = M[r4 + 580];
        unsigned i;

        /* remove all the ops in the reference sub-path */
        for (i=0; i < op_extra_data->spkr_num_ref_ops; ++i)
842025c0:	07 00       	r5 = Null + Null;

842025c2 <Lc_aec_reference_spkr_include_ref_path_17>:
842025c2:	61 f0 8d 88 	rMAC = M[r4 + 564];
842025c6:	78 04       	Null = r5 - rMAC;
842025c8:	02 f0 97 e0 	if C jump (m) Lc_aec_reference_spkr_include_ref_path_19;

842025cc <Lc_aec_reference_spkr_include_ref_path_18>:
        {
            cbops_op *prev_op = op->prev_operator_addr;
842025cc:	39 f0 00 e8 	r7 = M[r1 + Null];
            cbops_remove_operator_from_graph(spkr_graph, op);
842025d0:	42 08       	r0 = r6 + Null;
842025d2:	ff fd bc f0 	call (m) 0x19f54;
842025d6:	23 ec 
            op = prev_op;
842025d8:	4b 08       	r1 = r7 + Null;
        /* removing sub-graph starts from its last operator */
        cbops_op *op = op_extra_data->spkr_ref_last_op;
        unsigned i;

        /* remove all the ops in the reference sub-path */
        for (i=0; i < op_extra_data->spkr_num_ref_ops; ++i)
842025da:	7f 20       	r5 = r5 + 1;
842025dc:	f3 6f       	jump (m) Lc_aec_reference_spkr_include_ref_path_17;

842025de <Lc_aec_reference_spkr_include_ref_path_19>:
            cbops_remove_operator_from_graph(spkr_graph, op);
            op = prev_op;
        }

        /*  tell the cbops not to care about reference buffer any more */
        cbops_unset_buffer(spkr_graph, ref_idx);
842025de:	3b d8       	r1 = M[FP + 28];
842025e0:	42 08       	r0 = r6 + Null;
842025e2:	ff fd bc f0 	call (m) 0x19f9c;
842025e6:	3b ed 

        if(op_extra_data->spkr_ref_rs_op != NULL)
842025e8:	61 f0 93 88 	rMAC = M[r4 + 588];
842025ec:	09 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_21;

842025ee <Lc_aec_reference_spkr_include_ref_path_20>:
        {
            /* if we have resampler in the reference path
             * then also the reserved index buffer should
             * get unset.
             */
            cbops_unset_buffer(spkr_graph, op_extra_data->spkr_ref_rs_idx);
842025ee:	63 f0 8e 88 	r1 = M[r4 + 568];
842025f2:	42 08       	r0 = r6 + Null;
842025f4:	ff fd bc f0 	call (m) 0x19f9c;
842025f8:	29 ed 
            op_extra_data->spkr_ref_rs_op = NULL;
842025fa:	60 f0 93 8e 	M[r4 + 588] = Null;

842025fe <Lc_aec_reference_spkr_include_ref_path_21>:
        }

        op_extra_data->spkr_num_ref_ops = 0;
842025fe:	60 f0 8d 8e 	M[r4 + 564] = Null;
        op_extra_data->spkr_ref_last_op = NULL;
84202602:	60 f0 91 8e 	M[r4 + 580] = Null;
        op_extra_data->ref_sw_rateadj_op = NULL;
84202606:	60 f0 9e 8e 	M[r4 + 632] = Null;

        /* speaker graph no longer has reference sub-path */
        op_extra_data->spkr_ref_active = FALSE;
8420260a:	60 f0 87 8e 	M[r4 + 540] = Null;
8420260e:	8a 6f       	jump (m) Lc_aec_reference_spkr_include_ref_path_10;

84202610 <Lc_aec_reference_spkr_include_ref_path_22>:
        DEBUG_GRAPHS("AEC REFERENCE: Reference path removed!" );
    }
    return TRUE;
}
84202610:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
84202612:	d8 4c       	rts;

84202614 <$_ups_params_aec>:
}

/* Callback function for getting parameters from persistent store */
bool ups_params_aec(void* instance_data,PS_KEY_TYPE key,PERSISTENCE_RANK rank,
                    uint16 length, unsigned* data, STATUS_KYMERA status,uint16 extra_status_info)
{
84202614:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84202616:	2f 00       	r5 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84202618:	ef fd ef ff 	call (m) 0x4e6;
8420261c:	2f e6 
8420261e:	16 00       	r4 = r0 + Null;
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data((OPERATOR_DATA*)instance_data);

    patch_fn_shared(aec_reference);

    cpsSetParameterFromPsStore(&op_extra_data->parms_def,length,data,status);
84202620:	e5 d5       	r3 = MHS[FP + -8];
84202622:	fc d9       	r2 = M[FP + -4];
84202624:	62 f0 7c 21 	r0 = r4 + 380;
84202628:	3b 00       	r1 = r5 + Null;
8420262a:	ef fd f1 ff 	call (m) 0xa0a;
8420262e:	21 ef 

    /* Set the Reinit flag after setting the parameters */
    op_extra_data->ReInitFlag = TRUE;
84202630:	41 20       	rMAC = Null + 1;
84202632:	61 f0 5d 8e 	M[r4 + 372] = rMAC;

    return(TRUE);
84202636:	0a 00       	r0 = rMAC + Null;

84202638 <Lc_ups_params_aec_2>:
}
84202638:	f2 48       	popm <FP, r4, r5, rLink>;
8420263a:	d8 4c       	rts;

8420263c <$_aec_reference_update_mic_reference_sync>:
 * aec_reference_update_mic_reference_sync
 * \brief keeps mic and ref syncronised by updatin mic or reference path warp value
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_update_mic_reference_sync( AEC_REFERENCE_OP_DATA * op_extra_data)
{
8420263c:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
8420263e:	16 00       	r4 = r0 + Null;
    int mic_ra = 0;
84202640:	28 de       	M[FP + 20] = Null;
    int spkr_ra = 0;
84202642:	30 de       	M[FP + 24] = Null;

    patch_fn_shared(aec_reference_run);
    /* This is run in main loop, decimate update as it won't be
     * needed to get updated that often
     */
    op_extra_data->ref_update_counter++;
84202644:	61 f0 c9 88 	rMAC = M[r4 + 804];
84202648:	49 20       	rMAC = rMAC + 1;
8420264a:	61 f0 c9 8e 	M[r4 + 804] = rMAC;
    if(op_extra_data->ref_update_counter >= AEC_REFERENCE_REF_RATE_UPDATE_PERIOD)
8420264e:	48 26       	Null = rMAC - 9;
84202650:	a7 64       	if NC jump (m) Lc_aec_reference_update_mic_reference_sync_28;

84202652 <Lc_aec_reference_update_mic_reference_sync_2>:
    {
        op_extra_data->ref_update_counter = 0;
84202652:	60 f0 c9 8e 	M[r4 + 804] = Null;
        if(op_extra_data->spkr_rate_enactment == RATEMATCHING_SUPPORT_HW)
84202656:	61 f0 7e 88 	rMAC = M[r4 + 504];
8420265a:	88 24       	Null = rMAC - 2;
8420265c:	0e 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_6;

8420265e <Lc_aec_reference_update_mic_reference_sync_3>:
            /* speaker is using HW rate adjustment, read the latest HW warp rate,
             * when using HW rate adjust pretend it is applied in SW and speaker rate
             * itself is perfect.
             * TODO: might need a constant offset for 44.1kHz-like speaker rates
             */
            if (!opmgr_override_get_hw_warp(op_extra_data->spkr_endpoint, &spkr_ra))
8420265e:	83 11       	r1 = FP + 24;
84202660:	62 f0 a3 88 	r0 = M[r4 + 652];
84202664:	ff fd 17 f0 	call (m) 0x5504;
84202668:	21 e5 
8420266a:	10 04       	Null = r0 - Null;
8420266c:	02 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_5;

8420266e <Lc_aec_reference_update_mic_reference_sync_4>:
            {
                spkr_ra = 0;
8420266e:	30 de       	M[FP + 24] = Null;

84202670 <Lc_aec_reference_update_mic_reference_sync_5>:
            }
            spkr_rt = (1<<STREAM_RATEMATCHING_FIX_POINT_SHIFT);
84202670:	04 f0 08 f0 	r6 = Null + 4194304;
84202674:	00 40 
84202676:	15 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_9;

84202678 <Lc_aec_reference_update_mic_reference_sync_6>:
        }
        else
        {
            /* get the latest speaker rate measurement */
            spkr_rt = rate_monitor_op_get_rate(op_extra_data->spkr_rate_monitor_op,0);
84202678:	62 f0 80 88 	r0 = M[r4 + 512];
8420267c:	03 00       	r1 = Null + Null;
8420267e:	ff fd 0d f4 	call 0x84270;
84202682:	32 ef 
84202684:	10 09       	r6 = r0 + Null;
            if(op_extra_data->spkr_rate_enactment == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
               /* if using standalone operator, no built-in adjust rate is applied */
               &&(0 == op_extra_data->spkr_ext_rate_adjust_op)
#endif
               )
84202686:	61 f0 7e 88 	rMAC = M[r4 + 504];
8420268a:	48 24       	Null = rMAC - 1;
8420268c:	0a 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_9;

8420268e <Lc_aec_reference_update_mic_reference_sync_7>:
8420268e:	60 f0 a1 88 	Null = M[r4 + 644];
84202692:	07 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_9;

84202694 <Lc_aec_reference_update_mic_reference_sync_8>:
            {
                /* if SW rate adjustment is used, get the current value */
                spkr_ra = cbops_sra_get_current_rate_adjust(op_extra_data->spkr_sw_rateadj_op);
84202694:	62 f0 9f 88 	r0 = M[r4 + 636];
84202698:	ff fd bb f0 	call (m) 0x19d2c;
8420269c:	35 e4 
8420269e:	32 de       	M[FP + 24] = r0;

842026a0 <Lc_aec_reference_update_mic_reference_sync_9>:
            }
        }
        if (op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
842026a0:	61 f0 cd 81 	rMAC = MBS[r4 + 461];
842026a4:	88 24       	Null = rMAC - 2;
842026a6:	12 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_14;

842026a8 <Lc_aec_reference_update_mic_reference_sync_10>:
            /* MIC is using HW rate adjustment, read the latest HW warp rate,
             * when using HW rate adjust pretend it is applied in SW and mic rate
             * itself is perfect.
             * TODO: might need a constant offset for 44.1khz-like mic rates
             */
            if (opmgr_override_get_hw_warp(op_extra_data->mic_endpoint, &mic_ra))
842026a8:	43 11       	r1 = FP + 20;
842026aa:	62 f0 a2 88 	r0 = M[r4 + 648];
842026ae:	ff fd 17 f0 	call (m) 0x5504;
842026b2:	37 e2 
842026b4:	10 04       	Null = r0 - Null;
842026b6:	05 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_12;

842026b8 <Lc_aec_reference_update_mic_reference_sync_11>:
            {
                mic_ra = -mic_ra;
842026b8:	29 d8       	rMAC = M[FP + 20];
842026ba:	41 04       	rMAC = Null - rMAC;
842026bc:	29 de       	M[FP + 20] = rMAC;
842026be:	02 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_13;

842026c0 <Lc_aec_reference_update_mic_reference_sync_12>:
            }
            else
            {
                mic_ra = 0;
842026c0:	28 de       	M[FP + 20] = Null;

842026c2 <Lc_aec_reference_update_mic_reference_sync_13>:
            }
            mic_rt = (1<<STREAM_RATEMATCHING_FIX_POINT_SHIFT);
842026c2:	04 f0 07 f0 	r5 = Null + 4194304;
842026c6:	00 40 
842026c8:	15 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_17;

842026ca <Lc_aec_reference_update_mic_reference_sync_14>:
        }
        else
        {
            /* get the latest speaker rate measurement */
            mic_rt = rate_monitor_op_get_rate(op_extra_data->mic_rate_monitor_op,0);
842026ca:	62 f0 76 88 	r0 = M[r4 + 472];
842026ce:	03 00       	r1 = Null + Null;
842026d0:	ff fd 0d f4 	call 0x84270;
842026d4:	20 ed 
842026d6:	17 00       	r5 = r0 + Null;
            if (op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
               /* if using standalone operator, no built-in adjust rate is applied */
               &&(0 == op_extra_data->mic_ext_rate_adjust_op)
#endif
               )
842026d8:	61 f0 cd 81 	rMAC = MBS[r4 + 461];
842026dc:	48 24       	Null = rMAC - 1;
842026de:	0a 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_17;

842026e0 <Lc_aec_reference_update_mic_reference_sync_15>:
842026e0:	60 f0 a0 88 	Null = M[r4 + 640];
842026e4:	07 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_17;

842026e6 <Lc_aec_reference_update_mic_reference_sync_16>:
            {
                mic_ra = cbops_sra_get_current_rate_adjust(op_extra_data->mic_sw_rateadj_op);
842026e6:	62 f0 9d 88 	r0 = M[r4 + 628];
842026ea:	ff fd bb f0 	call (m) 0x19d2c;
842026ee:	23 e2 
842026f0:	2a de       	M[FP + 20] = r0;

842026f2 <Lc_aec_reference_update_mic_reference_sync_17>:
         *   However to avoid any need to discard/insert in long runs (will cause echo canceller
         *   re-adaptation) we make sure that latency is always tending towards the centre of the
         *   desired range.
         */

        if(op_extra_data->sync_block.block_size != 0)
842026f2:	60 f0 ac 88 	Null = M[r4 + 688];
842026f6:	1e 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_19;

842026f8 <Lc_aec_reference_update_mic_reference_sync_18>:
        {
            int ref_mic_delay_to_centre =
                (int) op_extra_data->sync_block.ref_delay +
                (int) (op_extra_data->sync_block.jitter/2) -
                (int) op_extra_data->sync_block.speaker_delay;
842026f8:	62 f0 ab 88 	r0 = M[r4 + 684];
842026fc:	61 f0 b0 88 	rMAC = M[r4 + 704];
84202700:	12 50       	r0 = r0 LSHIFT -1;
84202702:	51 00       	rMAC = r0 + rMAC;
84202704:	62 f0 b5 88 	r0 = M[r4 + 724];
84202708:	89 04       	rMAC = rMAC - r0;
            op_extra_data->ref_mic_adj_fix += ref_mic_delay_to_centre * AEC_REFERENCE_REF_MIC_ADJ_COEFF;
8420270a:	62 f0 da 88 	r0 = M[r4 + 872];
8420270e:	8a 00       	r0 = rMAC + r0;
84202710:	62 f0 da 8e 	M[r4 + 872] = r0;
            op_extra_data->ref_mic_adj_fix = pl_min(op_extra_data->ref_mic_adj_fix, AEC_REFERENCE_REF_MIC_ADJ_MAX);
84202714:	03 f0 d6 40 	r1 = Null + 214;
84202718:	5f f3 42 ce 	r0 = MIN r1;
8420271c:	62 f0 da 8e 	M[r4 + 872] = r0;
            op_extra_data->ref_mic_adj_fix = pl_max(op_extra_data->ref_mic_adj_fix, -AEC_REFERENCE_REF_MIC_ADJ_MAX);
84202720:	62 f0 da 88 	r0 = M[r4 + 872];
84202724:	f3 f7 2a 7b 	r1 = Null + -214;
84202728:	6f f3 42 ce 	r0 = MAX r1;
8420272c:	62 f0 da 8e 	M[r4 + 872] = r0;
84202730:	03 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_20;

84202732 <Lc_aec_reference_update_mic_reference_sync_19>:
        }
        else
        {
            /* Note: REF-MIC latency control is disabled for block_size == 0 */
            op_extra_data->ref_mic_adj_fix = 0;
84202732:	60 f0 da 8e 	M[r4 + 872] = Null;

84202736 <Lc_aec_reference_update_mic_reference_sync_20>:
        }

        if(op_extra_data->mic_sync_enable)
84202736:	60 f0 cd 88 	Null = M[r4 + 820];
8420273a:	20 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_26;

8420273c <Lc_aec_reference_update_mic_reference_sync_21>:
        {
            /* if we are syncronising MIC to REF then calculate the rate needs
             * to be applied to the mic path, so it will be syncronised to
             * REFERENCE output(i.e. speaker input)*/
            int new_mic_ra = (int) aecref_calc_sync_mic_rate(spkr_ra,spkr_rt,mic_rt) - op_extra_data->ref_mic_adj_fix;
8420273c:	32 d8       	r0 = M[FP + 24];
8420273e:	3c 00       	r2 = r5 + Null;
84202740:	43 08       	r1 = r6 + Null;
84202742:	08 f0 27 ea 	call (m) $_aecref_calc_sync_mic_rate;
84202746:	61 f0 da 88 	rMAC = M[r4 + 872];
8420274a:	57 04       	r5 = r0 - rMAC;
            int diff = new_mic_ra - mic_ra;
8420274c:	29 d8       	rMAC = M[FP + 20];
8420274e:	7b 04       	r1 = r5 - rMAC;
            if(diff != 0)
84202750:	18 04       	Null = r1 - Null;
84202752:	11 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_25;

84202754 <Lc_aec_reference_update_mic_reference_sync_22>:
            {
                if (op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
84202754:	61 f0 cd 81 	rMAC = MBS[r4 + 461];
84202758:	88 24       	Null = rMAC - 2;
8420275a:	07 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_24;

8420275c <Lc_aec_reference_update_mic_reference_sync_23>:
                {
                    /* HW rate adjustment, apply the change only */
                    opmgr_override_set_ratematch_adjustment(op_extra_data->mic_endpoint, diff);
8420275c:	62 f0 a2 88 	r0 = M[r4 + 648];
84202760:	ff fd 16 f0 	call (m) 0x54b4;
84202764:	35 ea 
84202766:	07 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_25;

84202768 <Lc_aec_reference_update_mic_reference_sync_24>:
                }
                else
                {
                    /* apply new SW rate adjustment */
                    cbops_sra_set_rate_adjust(op_extra_data->mic_sw_rateadj_op,
                                              new_mic_ra);
84202768:	62 f0 9d 88 	r0 = M[r4 + 628];
8420276c:	3b 00       	r1 = r5 + Null;
8420276e:	ff fd ba f0 	call (m) 0x19d10;
84202772:	23 ed 

84202774 <Lc_aec_reference_update_mic_reference_sync_25>:
                }
            }
            op_extra_data->mic_rate_adjustment = new_mic_ra;
84202774:	67 f0 74 8e 	M[r4 + 464] = r5;
84202778:	11 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_27;

8420277a <Lc_aec_reference_update_mic_reference_sync_26>:
        {

            /* We are synchronising REFERENCE to MIC output,
             * Update reference SW rate adjustment.
             */
            op_extra_data->sync_block.rm_adjustment = (int) aecref_calc_ref_rate(mic_rt,mic_ra,spkr_rt,spkr_ra) + op_extra_data->ref_mic_adj_fix;
8420277a:	35 d8       	r3 = M[FP + 24];
8420277c:	2b d8       	r1 = M[FP + 20];
8420277e:	44 08       	r2 = r6 + Null;
84202780:	3a 00       	r0 = r5 + Null;
84202782:	08 f0 3f e6 	call (m) $_aecref_calc_ref_rate;
84202786:	61 f0 da 88 	rMAC = M[r4 + 872];
8420278a:	8b 00       	r1 = rMAC + r0;
8420278c:	63 f0 b2 8e 	M[r4 + 712] = r1;

            /* update rate adjust for reference path */
            cbops_sra_set_rate_adjust(op_extra_data->ref_sw_rateadj_op,
                                      op_extra_data->sync_block.rm_adjustment);
84202790:	62 f0 9e 88 	r0 = M[r4 + 632];
84202794:	ff fd ba f0 	call (m) 0x19d10;
84202798:	3d eb 

8420279a <Lc_aec_reference_update_mic_reference_sync_27>:

        }
        /* Clear frm_count to disable backup rate adjustment
         *  when rate adjustment is enacted
         */
        op_extra_data->sync_block.frm_count = 0;
8420279a:	60 f0 b1 8e 	M[r4 + 708] = Null;

8420279e <Lc_aec_reference_update_mic_reference_sync_28>:
    }
}
8420279e:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
842027a0:	d8 4c       	rts;

842027a2 <$_aec_reference_init_hw_sidetone>:
842027a2:	d8 4c       	rts;

842027a4 <$_aec_reference_update_hw_sidetone>:
/**
842027a4:	d8 4c       	rts;

842027a6 <$_aec_reference_update_stream_and_validate_channels>:
 * \param bufval, cbuffer buffer pointer for new connection (NULL for disconnection)
 *
 * \return whether re-validation carried out successfully
 */
bool aec_reference_update_stream_and_validate_channels(OPERATOR_DATA *op_data, tCbuffer **bufp, tCbuffer *bufval)
{
842027a6:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842027a8:	17 00       	r5 = r0 + Null;
842027aa:	1e 00       	r4 = r1 + Null;
842027ac:	20 09       	r6 = r2 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
842027ae:	ef fd ee ff 	call (m) 0x4e6;
842027b2:	39 e9 
842027b4:	12 09       	r8 = r0 + Null;
    patch_fn_shared(aec_reference);

    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* if operator isn't running just set the stream buffer and exit */
    if (!opmgr_op_is_running(op_data))
842027b6:	3a 00       	r0 = r5 + Null;
842027b8:	ff fd 17 f0 	call (m) 0x5700;
842027bc:	29 ea 
842027be:	10 04       	Null = r0 - Null;
842027c0:	07 62       	if NE jump (m) Lc_aec_reference_update_stream_and_validate_channels_5;

842027c2 <Lc_aec_reference_update_stream_and_validate_channels_2>:
    {
        if(bufp != NULL)
842027c2:	30 04       	Null = r4 - Null;
842027c4:	03 60       	if EQ jump (m) Lc_aec_reference_update_stream_and_validate_channels_4;

842027c6 <Lc_aec_reference_update_stream_and_validate_channels_3>:
        {
            *bufp = bufval;
842027c6:	68 f0 00 ee 	M[r4 + Null] = r6;

842027ca <Lc_aec_reference_update_stream_and_validate_channels_4>:
        }

        return TRUE;
842027ca:	42 20       	r0 = Null + 1;
842027cc:	17 6e       	jump (m) Lc_aec_reference_update_stream_and_validate_channels_10;

842027ce <Lc_aec_reference_update_stream_and_validate_channels_5>:
    }

    /* block interrupts if the op has a runnig task */
    bool interrupts_blocked = FALSE;
842027ce:	01 09       	r7 = Null + Null;
    if(op_extra_data->kick_id != TIMER_ID_INVALID)
842027d0:	a0 f0 5e 88 	Null = M[r8 + 376];
842027d4:	05 60       	if EQ jump (m) Lc_aec_reference_update_stream_and_validate_channels_7;

842027d6 <Lc_aec_reference_update_stream_and_validate_channels_6>:
    {
        LOCK_INTERRUPTS;
842027d6:	ff fd c2 f1 	call (m) 0x3ad3a;
842027da:	25 eb 
        interrupts_blocked = TRUE;
842027dc:	09 71       	r7 = Null + 1;

842027de <Lc_aec_reference_update_stream_and_validate_channels_7>:
    }

    /* set the stream buffer */
    if(bufp != NULL)
842027de:	30 04       	Null = r4 - Null;
842027e0:	03 60       	if EQ jump (m) Lc_aec_reference_update_stream_and_validate_channels_9;

842027e2 <Lc_aec_reference_update_stream_and_validate_channels_8>:
    {
        *bufp = bufval;
842027e2:	68 f0 00 ee 	M[r4 + Null] = r6;

842027e6 <Lc_aec_reference_update_stream_and_validate_channels_9>:
    }

    /* revisit the graphs based on latest connections */
    bool retval = validate_channels_and_build(op_data);
842027e6:	3a 00       	r0 = r5 + Null;
842027e8:	fa ff 37 e6 	call (m) $_validate_channels_and_build;
842027ec:	16 00       	r4 = r0 + Null;
842027ee:	0f f9 00 c2 	Null = r7 - Null;
842027f2:	f1 fd c2 f1 	if NE call (m) 0x3ad56;
842027f6:	25 eb 
    if(interrupts_blocked)
    {
        UNLOCK_INTERRUPTS;
    }

    return retval;
842027f8:	32 00       	r0 = r4 + Null;

842027fa <Lc_aec_reference_update_stream_and_validate_channels_10>:
}
842027fa:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842027fc:	d8 4c       	rts;

842027fe <$_build_sidetone_graph>:
 * \brief updates speaker graph to include/exclude side tone mixing
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool build_sidetone_graph(AEC_REFERENCE_OP_DATA* op_extra_data)
{
842027fe:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84202800:	16 00       	r4 = r0 + Null;
    tCbuffer *mic_buf = op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1];
84202802:	b7 88       	r5 = M[r4 + 8];
    unsigned* idxs;
    unsigned num_io = 2;
84202804:	10 71       	r6 = Null + 2;
    cbops_graph *sidetone_graph;
    cbops_op *op_ptr;
    cbops_op *override_op_ptr;
    unsigned st_mic_idx = 0;          /* buffer index for mic input */
    unsigned st_filter_out_idx = 1;   /* buffer index for sidetone filter output */
    unsigned resampler_out_idx = 0;   /* buffer index for output of possible resampler */
84202806:	40 de       	M[FP + 32] = Null;
    unsigned sidetone_idx = st_filter_out_idx; /* buffer index for sidetone buffer */
84202808:	0a 71       	r8 = Null + 1;
    unsigned sidetone_buf_size;
    unsigned spkr_threshold = frac_mult(op_extra_data->spkr_rate, op_extra_data->kick_period_frac)+1;
8420280a:	62 f0 7b 88 	r0 = M[r4 + 492];
8420280e:	63 f0 68 88 	r1 = M[r4 + 416];
84202812:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84202816:	51 20       	rMAC = r0 + 1;
84202818:	49 de       	M[FP + 36] = rMAC;
    unsigned safety_threshold;
    unsigned spkr_channel_status = GetSpkrChannelStatus(op_extra_data);
8420281a:	61 f0 83 88 	rMAC = M[r4 + 524];
8420281e:	19 f1 f0 1f 	r7 = rMAC AND 0x3ff0;
    unsigned num_sidetone_spkrs = 1;
84202822:	53 09       	r9 = r8 + Null;
     * --------------------------------------------------------------------------------------------------*/

    patch_fn_shared(aec_reference);

    /* destroy cbops graph if already running */
    if(NULL != op_extra_data->sidetone_graph)
84202824:	61 f0 6c 88 	rMAC = M[r4 + 432];
84202828:	03 60       	if EQ jump (m) Lc_build_sidetone_graph_3;

8420282a <Lc_build_sidetone_graph_2>:
    {
        aec_reference_cleanup_sidetone_graph(op_extra_data);
8420282a:	32 00       	r0 = r4 + Null;
8420282c:	f9 4e       	call (m) $_aec_reference_cleanup_sidetone_graph;

8420282e <Lc_build_sidetone_graph_3>:
    }

    /* see if we need to setup a separate graph for sidetone mixing */
    if(op_extra_data->sidetone_method != AEC_SIDETONE_IN_SW_USING_SEPARATE_GRAPH)
8420282e:	61 f0 bc 81 	rMAC = MBS[r4 + 444];
84202832:	c8 24       	Null = rMAC - 3;
84202834:	e1 62       	if NE jump (m) Lc_build_sidetone_graph_25;

84202836 <Lc_build_sidetone_graph_4>:
    }

    DEBUG_GRAPHS("AEC_REFERENCE: Building sidetone graph ...");

    /* Determine number of speakers to have sidetone */
    if((spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA) == 0)
84202836:	91 f0 00 10 	rMAC = r7 AND 0x1000;
8420283a:	05 62       	if NE jump (m) Lc_build_sidetone_graph_7;

8420283c <Lc_build_sidetone_graph_5>:
    {
        if((spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_MIX) == 0)
8420283c:	91 f1 00 00 	rMAC = r7 AND 0x2000;
84202840:	02 62       	if NE jump (m) Lc_build_sidetone_graph_7;

84202842 <Lc_build_sidetone_graph_6>:
        {
            /* mono to stereo, mix to both */
            num_sidetone_spkrs = 2;
84202842:	43 09       	r9 = r6 + Null;

84202844 <Lc_build_sidetone_graph_7>:
        }
    }

    /* limit to available speakers */
    num_sidetone_spkrs = MIN(num_sidetone_spkrs, op_extra_data->num_spkr_channels);
84202844:	61 f0 84 88 	rMAC = M[r4 + 528];
84202848:	1f fb 00 c2 	Null = r9 - rMAC;
8420284c:	02 64       	if NC jump (m) Lc_build_sidetone_graph_9;

8420284e <Lc_build_sidetone_graph_8>:
8420284e:	0b 09       	r9 = rMAC + Null;

84202850 <Lc_build_sidetone_graph_9>:

    /* we don't expect Sidetone buffer already existing at this point */
    PL_ASSERT(op_extra_data->sidetone_buf == NULL);
84202850:	61 f0 31 88 	rMAC = M[r4 + 196];
84202854:	d3 60       	if EQ jump (m) Lc_build_sidetone_graph_26;

84202856 <Lc_build_sidetone_graph_10>:
84202856:	03 f0 ac 41 	r1 = Null + 428;
8420285a:	02 f0 13 60 	r0 = Null + 4115;
8420285e:	ff fd a3 f0 	call (m) 0x16ff0;
84202862:	33 ec 
84202864:	db 6e       	jump (m) Lc_build_sidetone_graph_30;

84202866 <Lc_build_sidetone_graph_11>:
    /* Allocate Buffer for sidetone samples,
     * size = sidetone_task_period + 1ms for latency control
     */
    sidetone_buf_size = frac_mult(op_extra_data->spkr_rate,
                                  op_extra_data->kick_period_frac +
                                  FRACTIONAL(0.001));
84202866:	62 f0 7b 88 	r0 = M[r4 + 492];
8420286a:	61 f0 68 88 	rMAC = M[r4 + 416];
8420286e:	83 f0 13 f0 	r1 = rMAC + 2147483;
84202872:	9b 28 
84202874:	00 f3 72 c9 	r0 = r0 * r1 (frac);

    op_extra_data->sidetone_buf = cbuffer_create_with_malloc_fast(sidetone_buf_size, BUF_DESC_SW_BUFFER);
84202878:	03 00       	r1 = Null + Null;
8420287a:	ff fd 8d f0 	call (m) 0x142d4;
8420287e:	3b e2 
84202880:	62 f0 31 8e 	M[r4 + 196] = r0;
    if(!op_extra_data->sidetone_buf)
84202884:	61 f0 31 88 	rMAC = M[r4 + 196];
84202888:	c8 60       	if EQ jump (m) Lc_build_sidetone_graph_29;

8420288a <Lc_build_sidetone_graph_12>:
    }

    /* create clone cbuffers for mic buffer */
    op_extra_data->sidetone_mic_buf = cbuffer_create(mic_buf->base_addr,
                                                     cbuffer_get_size_in_words(mic_buf),
                                                     BUF_DESC_SW_BUFFER);
8420288a:	3a 00       	r0 = r5 + Null;
8420288c:	ff fd 8d f0 	call (m) 0x14450;
84202890:	25 ee 
84202892:	13 00       	r1 = r0 + Null;
84202894:	fa 88       	r0 = M[r5 + 12];
84202896:	04 00       	r2 = Null + Null;
84202898:	ff fd 8d f0 	call (m) 0x1429c;
8420289c:	25 e0 
8420289e:	62 f0 6d 8e 	M[r4 + 436] = r0;
    if(op_extra_data->sidetone_mic_buf == NULL)
842028a2:	61 f0 6d 88 	rMAC = M[r4 + 436];
842028a6:	b9 60       	if EQ jump (m) Lc_build_sidetone_graph_29;

842028a8 <Lc_build_sidetone_graph_13>:
        return FALSE;
    }


    /* do we need resampler for side tone generation */
    if(op_extra_data->spkr_rate != op_extra_data->mic_rate)
842028a8:	61 f0 7b 88 	rMAC = M[r4 + 492];
842028ac:	62 f0 72 88 	r0 = M[r4 + 456];
842028b0:	88 04       	Null = rMAC - r0;
842028b2:	05 60       	if EQ jump (m) Lc_build_sidetone_graph_15;

842028b4 <Lc_build_sidetone_graph_14>:
    {
        /* Extra buffer needed between sidetone filter and resampler,
         * as resampler can't work in-place
         */
        num_io++;
842028b4:	18 71       	r6 = Null + 3;
        resampler_out_idx = st_filter_out_idx + 1;
842028b6:	81 20       	rMAC = Null + 2;
842028b8:	41 de       	M[FP + 32] = rMAC;
        sidetone_idx++;
842028ba:	0a 09       	r8 = rMAC + Null;

842028bc <Lc_build_sidetone_graph_15>:

    /* create indexes for cbops buffers,
     * this needs to be deleted before leaving
     * this function.
     */
    idxs = create_default_indexes(num_io);
842028bc:	42 08       	r0 = r6 + Null;
842028be:	ff fd bb f0 	call (m) 0x19fe6;
842028c2:	29 e9 
842028c4:	11 09       	r7 = r0 + Null;
    if(idxs == NULL)
842028c6:	a9 60       	if EQ jump (m) Lc_build_sidetone_graph_29;

842028c8 <Lc_build_sidetone_graph_16>:
    {
        return(FALSE);
    }

    /* Allocate sidetone graph */
    sidetone_graph = cbops_alloc_graph(num_io);
842028c8:	42 08       	r0 = r6 + Null;
842028ca:	ff fd ba f0 	call (m) 0x19de0;
842028ce:	37 e8 
842028d0:	10 09       	r6 = r0 + Null;
    if(!sidetone_graph)
842028d2:	9f 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

842028d4 <Lc_build_sidetone_graph_17>:
    {
        goto aFailed;
    }
    op_extra_data->sidetone_graph = sidetone_graph;
842028d4:	68 f0 6c 8e 	M[r4 + 432] = r6;

    /* set mic input buffer */
    cbops_set_input_io_buffer(sidetone_graph,
                              st_mic_idx,
                              st_mic_idx,
                              op_extra_data->sidetone_mic_buf);
842028d8:	65 f0 6d 88 	r3 = M[r4 + 436];
842028dc:	04 00       	r2 = Null + Null;
842028de:	03 00       	r1 = Null + Null;
842028e0:	ff fd ba f0 	call (m) 0x19e7c;
842028e4:	3d ec 
     * into speakers by override operator)
     */
    cbops_set_output_io_buffer(sidetone_graph,
                               sidetone_idx,
                               sidetone_idx,
                               op_extra_data->sidetone_buf);
842028e6:	65 f0 31 88 	r3 = M[r4 + 196];
842028ea:	54 08       	r2 = r8 + Null;
842028ec:	53 08       	r1 = r8 + Null;
842028ee:	42 08       	r0 = r6 + Null;
842028f0:	ff fd ba f0 	call (m) 0x19eb0;
842028f4:	21 ee 
      Note:  Sidetone is before resampler.
      Better solution is to place it at lowest sample rate
    */
    op_ptr = create_sidetone_filter_op(st_mic_idx, st_filter_out_idx, 3,
                                       (cbops_sidetone_params*)&op_extra_data->params.OFFSET_ST_CLIP_POINT,
                                       (void*)&op_extra_data->params.OFFSET_ST_PEQ_CONFIG);
842028f6:	01 f0 10 ff 	push r4 + 272;
842028fa:	16 cf 
842028fc:	65 f0 f4 20 	r3 = r4 + 244;
84202900:	c4 20       	r2 = Null + 3;
84202902:	43 20       	r1 = Null + 1;
84202904:	02 00       	r0 = Null + Null;
84202906:	ff fd aa f1 	call (m) 0x37dc8;
8420290a:	23 e6 
8420290c:	7f 4c       	SP = SP + -4;
    op_extra_data->mic_sidetone_op = op_ptr;
    if(!op_ptr)
8420290e:	62 f0 77 8e 	M[r4 + 476] = r0;
84202912:	7f 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

84202914 <Lc_build_sidetone_graph_18>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(sidetone_graph,op_ptr);
84202914:	13 00       	r1 = r0 + Null;
84202916:	42 08       	r0 = r6 + Null;
84202918:	ff fd ba f0 	call (m) 0x19f16;
8420291c:	3f ef 

    /* DC remove on sidetone */
    op_ptr = create_dc_remove_op(1, &idxs[st_filter_out_idx], &idxs[st_filter_out_idx]);
8420291e:	94 f0 04 20 	r2 = r7 + 4;
84202922:	93 f0 04 20 	r1 = r7 + 4;
84202926:	42 20       	r0 = Null + 1;
84202928:	ff fd 60 f1 	call (m) 0x2e980;
8420292c:	39 e2 
    if(!op_ptr)
8420292e:	10 04       	Null = r0 - Null;
84202930:	70 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

84202932 <Lc_build_sidetone_graph_19>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(sidetone_graph, op_ptr);
84202932:	13 00       	r1 = r0 + Null;
84202934:	42 08       	r0 = r6 + Null;
84202936:	ff fd ba f0 	call (m) 0x19f16;
8420293a:	21 ef 

    /* see if we need resampler in sidetone path */
    if(resampler_out_idx != 0)
8420293c:	41 d8       	rMAC = M[FP + 32];
8420293e:	2a 60       	if EQ jump (m) Lc_build_sidetone_graph_22;

84202940 <Lc_build_sidetone_graph_20>:
    {
        /* sidetone filter will write into scratch buff */
        cbops_set_internal_io_buffer(sidetone_graph,
                                     st_filter_out_idx,
                                     st_filter_out_idx,
                                     op_extra_data->scratch_bufs[0]);
84202940:	65 f0 21 88 	r3 = M[r4 + 132];
84202944:	44 20       	r2 = Null + 1;
84202946:	23 00       	r1 = r2 + Null;
84202948:	42 08       	r0 = r6 + Null;
8420294a:	ff fd ba f0 	call (m) 0x19ee4;
8420294e:	3b ec 
                                           &idxs[st_filter_out_idx],
                                           &idxs[resampler_out_idx],
                                           op_extra_data->mic_rate,
                                           op_extra_data->spkr_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, 0, 0, 0);
84202950:	00 f0 30 cf 	push Null;
84202954:	00 f0 30 cf 	push Null;
84202958:	00 f0 30 cf 	push Null;
8420295c:	61 f0 32 88 	rMAC = M[r4 + 200];
84202960:	09 1c       	pushm <rMAC>;
84202962:	61 f0 33 88 	rMAC = M[r4 + 204];
84202966:	09 1c       	pushm <rMAC>;
84202968:	61 f0 7b 88 	rMAC = M[r4 + 492];
8420296c:	09 1c       	pushm <rMAC>;
8420296e:	65 f0 72 88 	r3 = M[r4 + 456];
84202972:	94 f0 08 20 	r2 = r7 + 8;
84202976:	93 f0 04 20 	r1 = r7 + 4;
8420297a:	42 20       	r0 = Null + 1;
8420297c:	ff fd bb f0 	call (m) 0x1a090;
84202980:	35 e8 
84202982:	7a 4c       	SP = SP + -24;
        if(!op_ptr)
84202984:	10 04       	Null = r0 - Null;
84202986:	45 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

84202988 <Lc_build_sidetone_graph_21>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(sidetone_graph,op_ptr);
84202988:	13 00       	r1 = r0 + Null;
8420298a:	42 08       	r0 = r6 + Null;
8420298c:	ff fd ba f0 	call (m) 0x19f16;
84202990:	2b ec 

84202992 <Lc_build_sidetone_graph_22>:
    op_ptr = create_sink_overflow_disgard_op(1,                   /* number of channels */
                                             &idxs[sidetone_idx], /* buffer indexes */
                                             /* Minimum space needed in buffer at the beginning of
                                              * process, if not enough space this op will discard some
                                              * samples to free space for new incoming mic sapmples */
                                             spkr_threshold);
84202992:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
84202996:	49 08       	rMAC = r7 + Null;
84202998:	51 00       	rMAC = r0 + rMAC;
8420299a:	0f 00       	r5 = rMAC + Null;
8420299c:	42 20       	r0 = Null + 1;
8420299e:	3b 00       	r1 = r5 + Null;
842029a0:	4c d8       	r2 = M[FP + 36];
842029a2:	ff fd aa f1 	call (m) 0x37e86;
842029a6:	25 e7 
#if defined(IO_DEBUG)
    op_extra_data->st_disgard_op = op_ptr;
#endif

    if(!op_ptr)
842029a8:	62 f0 d2 8e 	M[r4 + 840] = r0;
842029ac:	32 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

842029ae <Lc_build_sidetone_graph_23>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(sidetone_graph,op_ptr);
842029ae:	13 00       	r1 = r0 + Null;
842029b0:	42 08       	r0 = r6 + Null;
842029b2:	ff fd ba f0 	call (m) 0x19f16;
842029b6:	25 eb 
     */

    /* safety_threshold, this is a small safety zone to make sure
     * sidetone mixing is ahead of reading by HW, (1/4 of a ms)
     */
    safety_threshold = frac_mult(op_extra_data->spkr_rate, FRACTIONAL(0.00025))+1;
842029b8:	62 f0 7b 88 	r0 = M[r4 + 492];
842029bc:	00 f0 13 f4 	r1 = Null + 536870;
842029c0:	26 61 
842029c2:	00 f3 72 c9 	r0 = r0 * r1 (frac);
842029c6:	51 20       	rMAC = r0 + 1;
        &op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1], /* spkr mmu buffer(s) */
        num_sidetone_spkrs,                                 /* number of speaker(s) */
        &idxs[sidetone_idx],                                /* indexes for sidetone buffer */
        spkr_threshold,                                     /* speaker threshold */
        safety_threshold                                    /* safety threshold */
                                                );
842029c8:	09 1c       	pushm <rMAC>;
842029ca:	49 d8       	rMAC = M[FP + 36];
842029cc:	08 f0 42 e0 	pushm <rMAC, r5>;
842029d0:	64 f0 44 20 	r2 = r4 + 68;
842029d4:	b2 88       	r0 = M[r4 + 8];
842029d6:	03 00       	r1 = Null + Null;
842029d8:	5d 08       	r3 = r9 + Null;
842029da:	03 f0 29 ef 	call (m) $_create_aec_ref_sidetone_op;
842029de:	7d 4c       	SP = SP + -12;
    if(!override_op_ptr)
842029e0:	10 04       	Null = r0 - Null;
842029e2:	17 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

842029e4 <Lc_build_sidetone_graph_24>:
    {
        goto aFailed;
    }
    cbops_set_override_operator(sidetone_graph, override_op_ptr);
842029e4:	13 00       	r1 = r0 + Null;
842029e6:	42 08       	r0 = r6 + Null;
842029e8:	ff fd ba f0 	call (m) 0x19f3e;
842029ec:	37 ea 

    DEBUG_GRAPHS("AEC REFERENCE: Building sidetone graph, Done!");
    pfree(idxs);
842029ee:	4a 08       	r0 = r7 + Null;
842029f0:	ff fd 1f f0 	call (m) 0x68d8;
842029f4:	29 e7 

842029f6 <Lc_build_sidetone_graph_25>:
    }

    /* see if we need to setup a separate graph for sidetone mixing */
    if(op_extra_data->sidetone_method != AEC_SIDETONE_IN_SW_USING_SEPARATE_GRAPH)
    {
        return TRUE;
842029f6:	42 20       	r0 = Null + 1;
842029f8:	11 6e       	jump (m) Lc_build_sidetone_graph_30;

842029fa <Lc_build_sidetone_graph_26>:
    /* limit to available speakers */
    num_sidetone_spkrs = MIN(num_sidetone_spkrs, op_extra_data->num_spkr_channels);

    /* we don't expect Sidetone buffer already existing at this point */
    PL_ASSERT(op_extra_data->sidetone_buf == NULL);
    PL_ASSERT(op_extra_data->sidetone_mic_buf == NULL);
842029fa:	61 f0 6d 88 	rMAC = M[r4 + 436];
842029fe:	34 61       	if EQ jump (m) Lc_build_sidetone_graph_11;

84202a00 <Lc_build_sidetone_graph_27>:
84202a00:	03 f0 ad 41 	r1 = Null + 429;
84202a04:	02 f0 13 60 	r0 = Null + 4115;
84202a08:	ff fd a2 f0 	call (m) 0x16ff0;
84202a0c:	29 ef 
84202a0e:	06 6e       	jump (m) Lc_build_sidetone_graph_30;

84202a10 <Lc_build_sidetone_graph_28>:
    pfree(idxs);

    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building sidetone graph, Failed!");
    pfree(idxs);
84202a10:	4a 08       	r0 = r7 + Null;
84202a12:	ff fd 1f f0 	call (m) 0x68d8;
84202a16:	27 e6 

84202a18 <Lc_build_sidetone_graph_29>:
    if(!op_extra_data->sidetone_buf)
    {
        /* Not going ahead with creating sidetone graph if we
         * cannot create shared buffer for sidetone path.
         */
        return FALSE;
84202a18:	02 00       	r0 = Null + Null;

84202a1a <Lc_build_sidetone_graph_30>:
    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building sidetone graph, Failed!");
    pfree(idxs);
    return(FALSE);
}
84202a1a:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202a1c:	d8 4c       	rts;

84202a1e <$_aec_reference_cleanup_sidetone_graph>:
 * \brief clean up sidetone graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_sidetone_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84202a1e:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202a20:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

    /* mic_sidetone_op, no longer is valid` */
    op_extra_data->mic_sidetone_op = NULL;
84202a22:	60 f0 77 8e 	M[r4 + 476] = Null;

    /* Free cbops sidetone graph */
    if(op_extra_data->sidetone_graph != NULL)
84202a26:	62 f0 6c 88 	r0 = M[r4 + 432];
84202a2a:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_sidetone_graph_3;

84202a2c <Lc_aec_reference_cleanup_sidetone_graph_2>:
    {
        destroy_graph(op_extra_data->sidetone_graph);
84202a2c:	ff fd b9 f0 	call (m) 0x19e20;
84202a30:	35 ef 
        op_extra_data->sidetone_graph = NULL;
84202a32:	60 f0 6c 8e 	M[r4 + 432] = Null;

84202a36 <Lc_aec_reference_cleanup_sidetone_graph_3>:
    }

    /* Free Sidetone buffers */
    if(op_extra_data->sidetone_buf != NULL)
84202a36:	62 f0 31 88 	r0 = M[r4 + 196];
84202a3a:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_sidetone_graph_5;

84202a3c <Lc_aec_reference_cleanup_sidetone_graph_4>:
    {
        cbuffer_destroy(op_extra_data->sidetone_buf);
84202a3c:	ff fd 8c f0 	call (m) 0x1439a;
84202a40:	3f ea 
        op_extra_data->sidetone_buf = NULL;
84202a42:	60 f0 31 8e 	M[r4 + 196] = Null;

84202a46 <Lc_aec_reference_cleanup_sidetone_graph_5>:
    }

    /* free cbuffer structure for clone mic buff */
    if(op_extra_data->sidetone_mic_buf != NULL)
84202a46:	62 f0 6d 88 	r0 = M[r4 + 436];
84202a4a:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_sidetone_graph_7;

84202a4c <Lc_aec_reference_cleanup_sidetone_graph_6>:
    {
        cbuffer_destroy_struct(op_extra_data->sidetone_mic_buf);
84202a4c:	ff fd 8c f0 	call (m) 0x143cc;
84202a50:	21 ec 
        op_extra_data->sidetone_mic_buf = NULL;
84202a52:	60 f0 6d 8e 	M[r4 + 436] = Null;

84202a56 <Lc_aec_reference_cleanup_sidetone_graph_7>:
    }

    DEBUG_GRAPHS("AEC REFERENCE: SIDETONE graph's cleanup done!" );
}
84202a56:	f1 48       	popm <FP, r4, rLink>;
84202a58:	d8 4c       	rts;

84202a5a <Lc_build_mic_graph_is_required_1>:
 */
static bool build_mic_graph_is_required(AEC_REFERENCE_OP_DATA *op_extra_data,
                                        bool sidetone_enabled)
{
    /* check if we have mic config at all */
    if((op_extra_data->channel_status&CHAN_STATE_MIC_MASK) == 0)
84202a5a:	21 f0 83 88 	rMAC = M[r0 + 524];
84202a5e:	0f f0 14 f8 	r2 = rMAC AND 0x1f000f;
84202a62:	0f 00 
84202a64:	03 62       	if NE jump (m) Lc_build_mic_graph_is_required_3;

84202a66 <Lc_build_mic_graph_is_required_2>:
    {
        /* mic path isn't needed */
        return FALSE;
84202a66:	02 00       	r0 = Null + Null;
84202a68:	12 6e       	jump (m) Lc_build_mic_graph_is_required_8;

84202a6a <Lc_build_mic_graph_is_required_3>:
    }

    /* default: mic path required with output */
    op_extra_data->mic_graph_no_output = FALSE;
84202a6a:	20 f0 db 8e 	M[r0 + 876] = Null;

    if((op_extra_data->channel_status&AEC_REFERENCE_CONSTANT_CONN_MIKE_1_INPUT_ONLY) != 0)
84202a6e:	08 f0 11 f0 	rMAC = rMAC AND 0x100000;
84202a72:	00 00 
84202a74:	0b 60       	if EQ jump (m) Lc_build_mic_graph_is_required_7;

84202a76 <Lc_build_mic_graph_is_required_4>:
        /* This check is only for efficiency, knowing that 1->0 mic config
         * only needed if sidetone is enabled. if sidetone not enabled,
         * or enabled but will be done using separate graph then no need
         * to build mic graph at all.
         */
        if(!sidetone_enabled || op_extra_data->task_decim_factor > 1)
84202a76:	18 04       	Null = r1 - Null;
84202a78:	f7 61       	if EQ jump (m) Lc_build_mic_graph_is_required_2;

84202a7a <Lc_build_mic_graph_is_required_5>:
84202a7a:	21 f0 6a 88 	rMAC = M[r0 + 424];
84202a7e:	48 24       	Null = rMAC - 1;
84202a80:	f8 ff e7 ef 	if HI jump (m) Lc_build_mic_graph_is_required_2;

84202a84 <Lc_build_mic_graph_is_required_6>:
            /* mic path isn't needed */
            return FALSE;
        }

        /* build mic path without output */
        op_extra_data->mic_graph_no_output = TRUE;
84202a84:	41 20       	rMAC = Null + 1;
84202a86:	21 f0 db 8e 	M[r0 + 876] = rMAC;

84202a8a <Lc_build_mic_graph_is_required_7>:
    }

    return TRUE;
84202a8a:	42 20       	r0 = Null + 1;

84202a8c <Lc_build_mic_graph_is_required_8>:
84202a8c:	d8 4c       	rts;

84202a8e <Lc_build_mic_graph_add_output_subgraph_1>:
static bool build_mic_graph_add_output_subgraph(AEC_REFERENCE_OP_DATA *op_extra_data,
                                                unsigned *idxs,
                                                unsigned intern_idx,
                                                unsigned out_idx,
                                                bool sidetone_enabled)
{
84202a8e:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84202a90:	12 09       	r8 = r0 + Null;
84202a92:	43 de       	M[FP + 32] = r1;
84202a94:	4c de       	M[FP + 36] = r2;
84202a96:	28 09       	r6 = r3 + Null;
84202a98:	f9 d9       	rMAC = M[FP + -4];
84202a9a:	51 de       	M[FP + 40] = rMAC;
    cbops_graph *mic_graph = op_extra_data->mic_graph;
84202a9c:	ab f0 75 88 	r9 = M[r8 + 468];
    unsigned num_mics = op_extra_data->num_mic_channels;
84202aa0:	a9 f0 85 88 	r7 = M[r8 + 532];
    cbops_op *op_ptr = NULL;
    unsigned i,j;

    /* Setup output Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
84202aa4:	06 00       	r4 = Null + Null;
84202aa6:	07 00       	r5 = Null + Null;
84202aa8:	04 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_3;

84202aaa <Lc_build_mic_graph_add_output_subgraph_2>:
    }
}

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
84202aaa:	38 25       	Null = r5 - 4;
84202aac:	02 f0 89 e0 	if C jump (m) Lc_build_mic_graph_add_output_subgraph_4;

84202ab0 <Lc_build_mic_graph_add_output_subgraph_3>:
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84202ab0:	fa 20       	r0 = r5 + 3;
84202ab2:	02 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_5;

84202ab4 <Lc_build_mic_graph_add_output_subgraph_4>:
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84202ab4:	7a 22       	r0 = r5 + 9;

84202ab6 <Lc_build_mic_graph_add_output_subgraph_5>:
    {
        /* MIC outputs may not be consecutive */
        tCbuffer *buffer_ptr_snk = op_extra_data->output_stream[OutputTerminalByIndex(j)];
84202ab6:	a1 f0 40 20 	rMAC = r8 + 64;
84202aba:	52 54       	r0 = r0 LSHIFT 2;
        if(buffer_ptr_snk != NULL)
84202abc:	8d e8       	r3 = M[rMAC + r0];
84202abe:	0d 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_9;

84202ac0 <Lc_build_mic_graph_add_output_subgraph_6>:
        {
            if(i < num_mics)
84202ac0:	9f f6 00 c2 	Null = r4 - r7;
84202ac4:	02 f0 93 e0 	if C jump (m) Lc_build_mic_graph_add_output_subgraph_8;

84202ac8 <Lc_build_mic_graph_add_output_subgraph_7>:
            {
                /* Outputs */
                cbops_set_output_io_buffer(mic_graph, out_idx + i, out_idx, buffer_ptr_snk);
84202ac8:	8f f6 03 c0 	r1 = r4 + r6;
84202acc:	44 08       	r2 = r6 + Null;
84202ace:	5a 08       	r0 = r9 + Null;
84202ad0:	ff fd b9 f0 	call (m) 0x19eb0;
84202ad4:	21 ef 

84202ad6 <Lc_build_mic_graph_add_output_subgraph_8>:
            }
            i++;
84202ad6:	76 20       	r4 = r4 + 1;

84202ad8 <Lc_build_mic_graph_add_output_subgraph_9>:
    unsigned num_mics = op_extra_data->num_mic_channels;
    cbops_op *op_ptr = NULL;
    unsigned i,j;

    /* Setup output Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
84202ad8:	7f 20       	r5 = r5 + 1;
84202ada:	38 26       	Null = r5 - 8;
84202adc:	e7 65       	if NC jump (m) Lc_build_mic_graph_add_output_subgraph_2;

84202ade <Lc_build_mic_graph_add_output_subgraph_10>:
            }
            i++;
        }
    }
    /* expect to have exactly num_mics outputs connected */
    PL_ASSERT(i==num_mics);
84202ade:	9f f6 00 c2 	Null = r4 - r7;
84202ae2:	09 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_12;

84202ae4 <Lc_build_mic_graph_add_output_subgraph_11>:
84202ae4:	03 f0 a9 42 	r1 = Null + 681;
84202ae8:	02 f0 13 60 	r0 = Null + 4115;
84202aec:	ff fd a2 f0 	call (m) 0x16ff0;
84202af0:	25 e8 
84202af2:	68 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_26;

84202af4 <Lc_build_mic_graph_add_output_subgraph_12>:

    /* Handle output */
    if(op_extra_data->mic_rate!=op_extra_data->output_rate)
84202af4:	a5 f0 72 88 	r3 = M[r8 + 456];
84202af8:	a1 f0 71 88 	rMAC = M[r8 + 452];
84202afc:	68 04       	Null = r3 - rMAC;
84202afe:	22 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_17;

84202b00 <Lc_build_mic_graph_add_output_subgraph_13>:
    {
        /* If only operator then shift input to output */
        unsigned shift_amount = (intern_idx != 0) ? 0 :  op_extra_data->mic_shift;
84202b00:	4a d8       	r0 = M[FP + 36];
84202b02:	03 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_15;

84202b04 <Lc_build_mic_graph_add_output_subgraph_14>:
84202b04:	02 00       	r0 = Null + Null;
84202b06:	03 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_16;

84202b08 <Lc_build_mic_graph_add_output_subgraph_15>:
84202b08:	a2 f0 7a 88 	r0 = M[r8 + 488];

84202b0c <Lc_build_mic_graph_add_output_subgraph_16>:
        /*  Add Resampler Operators per channel (mic_rate --> output_rate) */
        op_ptr = create_iir_resamplerv2_op(num_mics,
                                           &idxs[intern_idx], &idxs[out_idx],
                                           op_extra_data->mic_rate,op_extra_data->output_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, shift_amount, 0, 0);
84202b0c:	00 f0 30 cf 	push Null;
84202b10:	00 f0 30 cf 	push Null;
84202b14:	11 1c       	pushm <r0>;
84202b16:	a2 f0 32 88 	r0 = M[r8 + 200];
84202b1a:	11 1c       	pushm <r0>;
84202b1c:	a2 f0 33 88 	r0 = M[r8 + 204];
84202b20:	11 1c       	pushm <r0>;
84202b22:	09 1c       	pushm <rMAC>;
84202b24:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
84202b28:	44 d8       	r2 = M[FP + 32];
84202b2a:	23 00       	r1 = r2 + Null;
84202b2c:	14 01       	r2 = r0 + r2;
84202b2e:	4a d8       	r0 = M[FP + 36];
84202b30:	52 54       	r0 = r0 LSHIFT 2;
84202b32:	d3 00       	r1 = r0 + r1;
84202b34:	4a 08       	r0 = r7 + Null;
84202b36:	ff fd ba f0 	call (m) 0x1a090;
84202b3a:	3b ea 
84202b3c:	7a 4c       	SP = SP + -24;
84202b3e:	16 00       	r4 = r0 + Null;
84202b40:	11 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_19;

84202b42 <Lc_build_mic_graph_add_output_subgraph_17>:
        {
            return FALSE;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
    }
    else if (sidetone_enabled)
84202b42:	51 d8       	rMAC = M[FP + 40];
84202b44:	1c 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_23;

84202b46 <Lc_build_mic_graph_add_output_subgraph_18>:
    {
        /* Need to copy internal buffer to output before sidetone */
        op_ptr = create_shift_op(num_mics,&idxs[intern_idx], &idxs[out_idx],0);
84202b46:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
84202b4a:	44 d8       	r2 = M[FP + 32];
84202b4c:	05 00       	r3 = Null + Null;
84202b4e:	23 00       	r1 = r2 + Null;
84202b50:	14 01       	r2 = r0 + r2;
84202b52:	4a d8       	r0 = M[FP + 36];
84202b54:	52 54       	r0 = r0 LSHIFT 2;
84202b56:	d3 00       	r1 = r0 + r1;
84202b58:	4a 08       	r0 = r7 + Null;
84202b5a:	ff fd 5e f1 	call (m) 0x2e942;
84202b5e:	29 ef 
84202b60:	16 00       	r4 = r0 + Null;

84202b62 <Lc_build_mic_graph_add_output_subgraph_19>:
        op_ptr = create_iir_resamplerv2_op(num_mics,
                                           &idxs[intern_idx], &idxs[out_idx],
                                           op_extra_data->mic_rate,op_extra_data->output_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, shift_amount, 0, 0);
        if(op_ptr == NULL)
84202b62:	30 04       	Null = r4 - Null;
84202b64:	03 62       	if NE jump (m) Lc_build_mic_graph_add_output_subgraph_21;

84202b66 <Lc_build_mic_graph_add_output_subgraph_20>:
        {
            return FALSE;
84202b66:	02 00       	r0 = Null + Null;
84202b68:	2d 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_26;

84202b6a <Lc_build_mic_graph_add_output_subgraph_21>:
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
84202b6a:	33 00       	r1 = r4 + Null;
84202b6c:	5a 08       	r0 = r9 + Null;
84202b6e:	ff fd b9 f0 	call (m) 0x19f16;
84202b72:	29 ed 
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
    }

    /* Handle sidetone */
    if(sidetone_enabled && op_ptr != NULL)
84202b74:	51 d8       	rMAC = M[FP + 40];
84202b76:	03 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_23;

84202b78 <Lc_build_mic_graph_add_output_subgraph_22>:
    {
        /* mic sidetone path will be inserted
         * after this operator so it can do in-place
         * processing.
         */
        op_extra_data->mic_st_point = op_ptr;
84202b78:	a6 f0 98 8e 	M[r8 + 608] = r4;

84202b7c <Lc_build_mic_graph_add_output_subgraph_23>:
    }

    /* add mute operator, it can be controlled by
     * message to the operator
     */
    op_ptr = create_mute_op(num_mics, &idxs[out_idx]);
84202b7c:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
84202b80:	43 d8       	r1 = M[FP + 32];
84202b82:	d3 00       	r1 = r0 + r1;
84202b84:	4a 08       	r0 = r7 + Null;
84202b86:	ff fd a9 f1 	call (m) 0x37ebc;
84202b8a:	37 e9 
84202b8c:	16 00       	r4 = r0 + Null;
    if(!op_ptr)
84202b8e:	ec 61       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_20;

84202b90 <Lc_build_mic_graph_add_output_subgraph_24>:
    {
        return FALSE;
    }
    cbops_append_operator_to_graph(mic_graph,op_ptr);
84202b90:	33 00       	r1 = r4 + Null;
84202b92:	5a 08       	r0 = r9 + Null;
84202b94:	ff fd b9 f0 	call (m) 0x19f16;
84202b98:	23 ec 
    op_extra_data->mic_mute_op = op_ptr;
84202b9a:	a6 f0 78 8e 	M[r8 + 480] = r4;
    /* apply user config to mute operator, we don't apply
     * ramping at the beginning, so user can mute right from
     * the beginning.
     */
    cbops_mute_enable(op_extra_data->mic_mute_op, op_extra_data->mic_mute_enable_config, TRUE);
84202b9e:	44 20       	r2 = Null + 1;
84202ba0:	a3 f0 79 88 	r1 = M[r8 + 484];
84202ba4:	32 00       	r0 = r4 + Null;
84202ba6:	04 f0 31 e0 	call (m) $_cbops_mute_enable;

    /* Insert latency operator */
    op_ptr = create_mic_latency_op(out_idx,&op_extra_data->sync_block);
84202baa:	a3 f0 ac 22 	r1 = r8 + 684;
84202bae:	42 08       	r0 = r6 + Null;
84202bb0:	8f 4e       	call (m) $_create_mic_latency_op;
    if(op_ptr == NULL)
84202bb2:	10 04       	Null = r0 - Null;
84202bb4:	d9 61       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_20;

84202bb6 <Lc_build_mic_graph_add_output_subgraph_25>:
    {
        return FALSE;
    }
    cbops_append_operator_to_graph(mic_graph,op_ptr);
84202bb6:	13 00       	r1 = r0 + Null;
84202bb8:	5a 08       	r0 = r9 + Null;
84202bba:	ff fd b9 f0 	call (m) 0x19f16;
84202bbe:	3d ea 

    return TRUE;
84202bc0:	42 20       	r0 = Null + 1;

84202bc2 <Lc_build_mic_graph_add_output_subgraph_26>:
}
84202bc2:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202bc4:	d8 4c       	rts;

84202bc6 <Lc_aec_reference_update_input_output_rates_1>:
 * \irate input rate in Hz
 * \orate output rate in Hz
 * \return TRUE if it can accept the new rates else FALSE.
 */
static bool aec_reference_update_input_output_rates(OPERATOR_DATA *op_data, unsigned irate, unsigned orate)
{
84202bc6:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84202bc8:	11 09       	r7 = r0 + Null;
84202bca:	1f 00       	r5 = r1 + Null;
84202bcc:	20 09       	r6 = r2 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) base_op_get_instance_data(op_data);
84202bce:	ef fd ec ff 	call (m) 0x4e6;
84202bd2:	39 e8 
84202bd4:	16 00       	r4 = r0 + Null;
 * \return TRUE if it can accept the new rates else FALSE.
 */
static bool aec_reference_update_input_output_rates(OPERATOR_DATA *op_data, unsigned irate, unsigned orate)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    bool rebuild = FALSE;
84202bd6:	02 09       	r8 = Null + Null;

    patch_fn_shared(aec_reference);

    L2_DBG_MSG2("AEC REFERENCE: set rates = %d %d", irate, orate);
84202bd8:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84202bdc:	88 24       	Null = rMAC - 2;
84202bde:	09 68       	if LT jump (m) Lc_aec_reference_update_input_output_rates_3;

84202be0 <Lc_aec_reference_update_input_output_rates_2>:
84202be0:	55 f1 02 f0 	r0 = Null + 357564799;
84202be4:	7f 41 
84202be6:	44 08       	r2 = r6 + Null;
84202be8:	3b 00       	r1 = r5 + Null;
84202bea:	ef fd f0 ff 	call (m) 0xcf2;
84202bee:	29 e8 

84202bf0 <Lc_aec_reference_update_input_output_rates_3>:

    if(op_extra_data->input_rate!=irate)
84202bf0:	61 f0 70 88 	rMAC = M[r4 + 448];
84202bf4:	c8 05       	Null = rMAC - r5;
84202bf6:	10 60       	if EQ jump (m) Lc_aec_reference_update_input_output_rates_6;

84202bf8 <Lc_aec_reference_update_input_output_rates_4>:
    {
        op_extra_data->input_rate = irate;
84202bf8:	67 f0 70 8e 	M[r4 + 448] = r5;
        if (opmgr_op_is_running(op_data))
84202bfc:	4a 08       	r0 = r7 + Null;
84202bfe:	ff fd 15 f0 	call (m) 0x5700;
84202c02:	23 e8 
84202c04:	10 04       	Null = r0 - Null;
84202c06:	08 60       	if EQ jump (m) Lc_aec_reference_update_input_output_rates_6;

84202c08 <Lc_aec_reference_update_input_output_rates_5>:
        {
            /* if the operator is running, any change in input
             * rate should trigger a rebuild of speaker graph
             */
            SetSpkrChannelStatus(op_extra_data, 0);
84202c08:	61 f0 83 88 	rMAC = M[r4 + 524];
84202c0c:	11 fe 0f 00 	rMAC = rMAC AND 0xffffc00f;
84202c10:	61 f0 83 8e 	M[r4 + 524] = rMAC;
            rebuild = TRUE;
84202c14:	0a 71       	r8 = Null + 1;

84202c16 <Lc_aec_reference_update_input_output_rates_6>:
        }
    }

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* configure sample rate for MIC ttp */
    ttp_configure_rate(op_extra_data->mic_time_to_play, orate);
84202c16:	62 f0 c8 88 	r0 = M[r4 + 800];
84202c1a:	43 08       	r1 = r6 + Null;
84202c1c:	ff fd b4 f0 	call (m) 0x1961a;
84202c20:	3f ef 
#endif

    if(op_extra_data->output_rate!=orate)
84202c22:	61 f0 71 88 	rMAC = M[r4 + 452];
84202c26:	8f f1 00 c2 	Null = rMAC - r6;
84202c2a:	1b 60       	if EQ jump (m) Lc_aec_reference_update_input_output_rates_10;

84202c2c <Lc_aec_reference_update_input_output_rates_7>:
    {
        op_extra_data->output_rate = orate;
84202c2c:	68 f0 71 8e 	M[r4 + 452] = r6;
        if (opmgr_op_is_running(op_data))
84202c30:	4a 08       	r0 = r7 + Null;
84202c32:	ff fd 15 f0 	call (m) 0x5700;
84202c36:	2f e6 
84202c38:	10 04       	Null = r0 - Null;
84202c3a:	13 60       	if EQ jump (m) Lc_aec_reference_update_input_output_rates_10;

84202c3c <Lc_aec_reference_update_input_output_rates_8>:
        {
            /* if the operator is running, any change in output
             * rate should trigger a rebuild of microphone graph
             */
            SetMicChannelStatus(op_extra_data, 0);
84202c3c:	61 f0 83 88 	rMAC = M[r4 + 524];
84202c40:	f0 ff 11 f7 	rMAC = rMAC AND 0xffe0fff0;
84202c44:	f0 1f 
84202c46:	61 f0 83 8e 	M[r4 + 524] = rMAC;

84202c4a <Lc_aec_reference_update_input_output_rates_9>:
        /* At least one of input or output rate has changed while the operator
         * is running. This will require fresh rebuild of the affected cbops graphs.
         * No need to do this when operator isn't running since this will be done
         * at start point.
         */
        if(!aec_reference_update_stream_and_validate_channels(op_data, NULL, NULL))
84202c4a:	04 00       	r2 = Null + Null;
84202c4c:	03 00       	r1 = Null + Null;
84202c4e:	4a 08       	r0 = r7 + Null;
84202c50:	fd ff 37 ea 	call (m) $_aec_reference_update_stream_and_validate_channels;
        {
            /* Not the best way to indicate failure, but best we can do */
            return FALSE;
84202c54:	11 00       	rMAC = r0 + Null;
84202c56:	02 00       	r0 = Null + Null;
84202c58:	08 04       	Null = rMAC - Null;
84202c5a:	21 f0 42 ce 	if NE r0 = Null + 1;
84202c5e:	05 6e       	jump (m) Lc_aec_reference_update_input_output_rates_12;

84202c60 <Lc_aec_reference_update_input_output_rates_10>:
            SetMicChannelStatus(op_extra_data, 0);
            rebuild = TRUE;
        }
    }

    if(rebuild)
84202c60:	0f fa 00 c2 	Null = r8 - Null;
84202c64:	f3 63       	if NE jump (m) Lc_aec_reference_update_input_output_rates_9;

84202c66 <Lc_aec_reference_update_input_output_rates_11>:
            /* Not the best way to indicate failure, but best we can do */
            return FALSE;
        }
    }

    return TRUE;
84202c66:	42 20       	r0 = Null + 1;

84202c68 <Lc_aec_reference_update_input_output_rates_12>:
}
84202c68:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84202c6a:	d8 4c       	rts;

84202c6c <$_create_aec_ref_spkr_op>:
84202c6c:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;

/*
 * create_insert_op
 */
cbops_op* create_aec_ref_spkr_op(unsigned nr_inputs,unsigned* input_idx, unsigned *interm_idxs, unsigned in_threshold,unsigned nr_outputs,unsigned* output_idx,unsigned out_threshold, unsigned max_jitter)
{
84202c6e:	10 09       	r6 = r0 + Null;
84202c70:	19 09       	r7 = r1 + Null;
84202c72:	23 09       	r9 = r2 + Null;
84202c74:	2a 09       	r8 = r3 + Null;
84202c76:	ff d9       	r5 = M[FP + -4];
    // cbop param struct size (header plus cbop-specific parameters)
    cbops_op *op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_aec_ref_op, nr_inputs, nr_outputs) +
                                        /* Extend for interim buffers' indexes */
                                        nr_inputs*sizeof(unsigned));
84202c78:	c3 20       	r1 = Null + 3;
84202c7a:	00 f8 d2 d8 	r0 = r6 LSHIFT 1;
84202c7e:	ba 00       	r0 = r5 + r0;
84202c80:	52 54       	r0 = r0 LSHIFT 2;
84202c82:	12 39       	r0 = r0 + 52;
84202c84:	ff fd 1e f0 	call (m) 0x68a6;
84202c88:	23 e1 
84202c8a:	16 00       	r4 = r0 + Null;
    if(op)
84202c8c:	1e 60       	if EQ jump (m) Lc_create_aec_ref_spkr_op_3;

84202c8e <Lc_create_aec_ref_spkr_op_2>:
    {
        cbops_aec_ref_op *params;

        /* Setup Operator func table */
        op->function_vector    = cbops_aec_ref_spkr_table;
84202c8e:	07 f0 01 f0 	rMAC = Null + 7340356;
84202c92:	44 41 
84202c94:	b1 8e       	M[r4 + 8] = rMAC;

        /* Setup cbop param struct header info */
        params = (cbops_aec_ref_op*)cbops_populate_param_hdr(op, nr_inputs, nr_outputs, input_idx, output_idx);
84202c96:	f1 d9       	rMAC = M[FP + -8];
84202c98:	09 1c       	pushm <rMAC>;
84202c9a:	4d 08       	r3 = r7 + Null;
84202c9c:	3c 00       	r2 = r5 + Null;
84202c9e:	43 08       	r1 = r6 + Null;
84202ca0:	ff fd b9 f0 	call (m) 0x1a00e;
84202ca4:	2f eb 
84202ca6:	7f 4c       	SP = SP + -4;
84202ca8:	17 00       	r5 = r0 + Null;

        /* Setup cbop-specific parameters - well, just one in this case. Just exemplifies using the
         * generic macro, but in this cbop's case we could get to the param location "directly"
         */
        params->in_threshold  = in_threshold;
84202caa:	7a f0 00 ee 	M[r5 + Null] = r8;
        params->max_advance   = out_threshold;
84202cae:	e9 d9       	rMAC = M[FP + -12];
84202cb0:	79 8e       	M[r5 + 4] = rMAC;
        params->max_jitter   = max_jitter;
84202cb2:	e1 d9       	rMAC = M[FP + -16];
84202cb4:	b9 8f       	M[r5 + 24] = rMAC;

        /* copy intermediate idxs */
        memcpy(params->interm_idxs, interm_idxs, sizeof(unsigned)*nr_inputs);
84202cb6:	01 f8 d4 c8 	r2 = r6 LSHIFT 2;
84202cba:	3a 2b       	r0 = r5 + 28;
84202cbc:	5b 08       	r1 = r9 + Null;
84202cbe:	ff fd ba f0 	call (m) 0x1a192;
84202cc2:	35 e6 

        params->buffer_adj = 3;
84202cc4:	c1 20       	rMAC = Null + 3;
84202cc6:	b9 8e       	M[r5 + 8] = rMAC;

84202cc8 <Lc_create_aec_ref_spkr_op_3>:
    }

    return(op);
84202cc8:	32 00       	r0 = r4 + Null;

84202cca <Lc_create_aec_ref_spkr_op_4>:
}
84202cca:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202ccc:	d8 4c       	rts;

84202cce <$_create_mic_latency_op>:
84202cce:	c8 1c       	pushm <FP(=SP), rLink>;
 * \param common Pointer to common aec_latency_common latency structure
 * \return pointer to created cbops latency operator, NULL if fails to create.
 */
cbops_op* create_mic_latency_op(unsigned idx, aec_latency_common *common)
{
    return create_latency_op(idx, common, cbops_mic_latency_table);
84202cd0:	07 f0 04 f0 	r2 = Null + 7340368;
84202cd4:	50 41 
84202cd6:	0a 4e       	call (m) Lc_create_latency_op_1;

84202cd8 <Lc_create_mic_latency_op_2>:
}
84202cd8:	c8 48       	popm <FP, rLink>;
84202cda:	d8 4c       	rts;

84202cdc <$_create_speaker_latency_op>:
 * \param idx index of speaker master channel
 * \param common Pointer to common aec_latency_common latency structure
 * \return pointer to created cbops latency operator, NULL if fails to create.
 */
cbops_op* create_speaker_latency_op(unsigned idx, aec_latency_common *common)
{
84202cdc:	c8 1c       	pushm <FP(=SP), rLink>;
    return create_latency_op(idx, common, cbops_speaker_latency_table);
84202cde:	07 f0 04 f0 	r2 = Null + 7340380;
84202ce2:	5c 41 
84202ce4:	03 4e       	call (m) Lc_create_latency_op_1;

84202ce6 <Lc_create_speaker_latency_op_2>:
}
84202ce6:	c8 48       	popm <FP, rLink>;
84202ce8:	d8 4c       	rts;

84202cea <Lc_create_latency_op_1>:
 * \param common Pointer to common aec_latency_common latency structure
 * \function_vector cbops function for the operator
 * \return pointer to created cbops latency operator, NULL if fails to create.
 */
static cbops_op* create_latency_op(unsigned idx, aec_latency_common *common, void *function_vector)
{
84202cea:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84202cec:	11 09       	r7 = r0 + Null;
84202cee:	18 09       	r6 = r1 + Null;
84202cf0:	26 00       	r4 = r2 + Null;

    patch_fn_shared(aec_reference);
    // cbop param struct size (header plus cbop-specific parameters, no buffer table)
    cbops_op *op = (cbops_op*)xzpmalloc(sizeof_cbops_op(latency_op, 0, 0));
84202cf2:	c3 20       	r1 = Null + 3;
84202cf4:	02 31       	r0 = Null + 36;
84202cf6:	ff fd 1d f0 	call (m) 0x68a6;
84202cfa:	31 ed 
84202cfc:	17 00       	r5 = r0 + Null;

    if(op)
84202cfe:	0f 60       	if EQ jump (m) Lc_create_latency_op_3;

84202d00 <Lc_create_latency_op_2>:
    {
        latency_op *params = (latency_op *)cbops_populate_param_hdr(op,
                                                                    0,    /* number of inputs */
                                                                    0,    /* number of outputs */
                                                                    NULL, /* input index table */
                                                                    NULL);/* output index table */
84202d00:	00 f0 30 cf 	push Null;
84202d04:	05 00       	r3 = Null + Null;
84202d06:	04 00       	r2 = Null + Null;
84202d08:	03 00       	r1 = Null + Null;
84202d0a:	ff fd b9 f0 	call (m) 0x1a00e;
84202d0e:	25 e8 
84202d10:	7f 4c       	SP = SP + -4;
        /* Setup Operator func table */
        op->function_vector = function_vector;
84202d12:	be 8e       	M[r5 + 8] = r4;

        /* Setup cbop param struct header info */

        params->index  = idx;
84202d14:	29 f0 00 ee 	M[r0 + Null] = r7;
        params->common = common;
84202d18:	28 f0 02 8e 	M[r0 + 8] = r6;

84202d1c <Lc_create_latency_op_3>:
    }

    return(op);
84202d1c:	3a 00       	r0 = r5 + Null;

84202d1e <Lc_create_latency_op_4>:
}
84202d1e:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84202d20:	d8 4c       	rts;

84202d22 <$_aec_reference_spkr_ttp_run>:
84202d22:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \param error current TTP error in speaker path
 * \param max_to_process Pointer max amount of data available to process by speaker cbops
 */
void aec_reference_spkr_ttp_run(AEC_REFERENCE_OP_DATA  *op_extra_data, unsigned *max_to_process)
{
84202d24:	16 00       	r4 = r0 + Null;
84202d26:	1a 09       	r8 = r1 + Null;
    TIME_INTERVAL error = 0;
84202d28:	38 de       	M[FP + 28] = Null;
    bool error_valid;
    unsigned amount_can_process = *max_to_process;
84202d2a:	a8 f0 00 e8 	r6 = M[r8 + Null];
    /* only used for debug log */
    TIME current_time = time_get_time();
84202d2e:	ff fd 19 f0 	call (m) 0x6100;
84202d32:	33 ee 
84202d34:	11 09       	r7 = r0 + Null;

    patch_fn_shared(aec_reference_run);

    /* calculate current TTP error */
    error_valid = aec_reference_spkr_ttp_get_error(op_extra_data, &error);
84202d36:	c3 11       	r1 = FP + 28;
84202d38:	32 00       	r0 = r4 + Null;
84202d3a:	df 4e       	call (m) Lc_aec_reference_spkr_ttp_get_error_1;

    /* see if we have received void tags while in TTP mode */
    if(op_extra_data->spkr_void_tag_observed)
84202d3c:	60 f0 b9 88 	Null = M[r4 + 740];
84202d40:	0b 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_run_4;

84202d42 <Lc_aec_reference_spkr_ttp_run_2>:
    {
        /* increment a counter, so this shows the time that we have
         * continuously seen void tag
         */
        op_extra_data->spkr_void_tag_counter++;
84202d42:	61 f0 ba 88 	rMAC = M[r4 + 744];
84202d46:	49 20       	rMAC = rMAC + 1;
84202d48:	61 f0 ba 8e 	M[r4 + 744] = rMAC;

        if(op_extra_data->spkr_void_tag_counter == SPKR_TTP_VOID_TAG_COOL_OFF_TIME_MS)
84202d4c:	88 3c       	Null = rMAC - 50;
84202d4e:	06 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_run_5;

84202d50 <Lc_aec_reference_spkr_ttp_run_3>:
             */

            /* error isn't valid anymore, only seeing a timestamp tag will
             * make it valid again
             */
            op_extra_data->spkr_last_timestamp_valid = FALSE;
84202d50:	60 f0 b8 8e 	M[r4 + 736] = Null;
84202d54:	72 6e       	jump (m) Lc_aec_reference_spkr_ttp_run_23;

84202d56 <Lc_aec_reference_spkr_ttp_run_4>:
            error_valid = FALSE;
        }
    }
    else
    {
        op_extra_data->spkr_void_tag_counter = 0;
84202d56:	60 f0 ba 8e 	M[r4 + 744] = Null;

84202d5a <Lc_aec_reference_spkr_ttp_run_5>:
    }

    if(!error_valid)
84202d5a:	10 04       	Null = r0 - Null;
84202d5c:	6e 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_run_23;

84202d5e <Lc_aec_reference_spkr_ttp_run_6>:
    L2_DBG_MSG2("AEC REFERENCE SPEAKER: time=%d, ttp error=%d", current_time, error);
#endif

    /* See if the input is too late */
    if(error < -op_extra_data->spkr_error_threshold &&
       amount_can_process > 0)
84202d5e:	39 d8       	rMAC = M[FP + 28];
84202d60:	62 f0 bb 88 	r0 = M[r4 + 748];
84202d64:	82 04       	r0 = Null - r0;
84202d66:	88 04       	Null = rMAC - r0;
84202d68:	2e 66       	if GE jump (m) Lc_aec_reference_spkr_ttp_run_13;

84202d6a <Lc_aec_reference_spkr_ttp_run_7>:
84202d6a:	0f f8 00 c2 	Null = r6 - Null;
84202d6e:	2b 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_run_13;

84202d70 <Lc_aec_reference_spkr_ttp_run_8>:
    {
        /* Calculate how many samples we are late,
         * we discard late samples, as much as available
         */
        unsigned samples_to_trash = convert_time_to_samples((unsigned)(-error), op_extra_data->input_rate);
84202d70:	63 f0 70 88 	r1 = M[r4 + 448];
84202d74:	42 04       	r0 = Null - rMAC;
84202d76:	ff fd ab f0 	call (m) 0x18422;
84202d7a:	2d e5 
84202d7c:	13 00       	r1 = r0 + Null;

        /* limit to amount available */
        samples_to_trash = MIN(amount_can_process, samples_to_trash);
84202d7e:	2f f8 00 c2 	Null = r6 - r0;
84202d82:	02 f0 e5 e0 	if C jump (m) Lc_aec_reference_spkr_ttp_run_15;

84202d86 <Lc_aec_reference_spkr_ttp_run_9>:
84202d86:	43 08       	r1 = r6 + Null;

84202d88 <Lc_aec_reference_spkr_ttp_run_10>:

        if(samples_to_trash > 0)
        {
            /* We have something to trash */
            unsigned samples_trashed = aec_reference_spkr_ttp_discard_samples(op_extra_data,samples_to_trash);
84202d88:	32 00       	r0 = r4 + Null;
84202d8a:	7d 4e       	call (m) Lc_aec_reference_spkr_ttp_discard_samples_1;
84202d8c:	17 00       	r5 = r0 + Null;
            L3_DBG_MSG3("AEC REFERENCE SPEAKER TTP - discard samples=%d, time =%d , error=%d",
                        samples_trashed, current_time, error);
84202d8e:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84202d92:	c8 24       	Null = rMAC - 3;
84202d94:	0a 68       	if LT jump (m) Lc_aec_reference_spkr_ttp_run_12;

84202d96 <Lc_aec_reference_spkr_ttp_run_11>:
84202d96:	3d d8       	r3 = M[FP + 28];
84202d98:	55 f1 02 f0 	r0 = Null + 357564977;
84202d9c:	31 42 
84202d9e:	4c 08       	r2 = r7 + Null;
84202da0:	3b 00       	r1 = r5 + Null;
84202da2:	ef fd ef ff 	call (m) 0xd08;
84202da6:	27 eb 

84202da8 <Lc_aec_reference_spkr_ttp_run_12>:

            /* some samples discarded, update error */
            error += convert_samples_to_time(samples_trashed, op_extra_data->input_rate);
84202da8:	63 f0 70 88 	r1 = M[r4 + 448];
84202dac:	3a 00       	r0 = r5 + Null;
84202dae:	ff fd ab f0 	call (m) 0x183fe;
84202db2:	31 e2 
84202db4:	39 d8       	rMAC = M[FP + 28];
84202db6:	51 00       	rMAC = r0 + rMAC;
84202db8:	39 de       	M[FP + 28] = rMAC;

            /* update amount left to process */
            amount_can_process -= samples_trashed;
84202dba:	00 f7 38 c2 	r6 = r6 - r5;

            /* ttp play back needs resetting */
            aec_reference_spkr_ttp_reset(op_extra_data);
84202dbe:	32 00       	r0 = r4 + Null;
84202dc0:	01 f0 2f e9 	call (m) Lc_aec_reference_spkr_ttp_reset_1;

84202dc4 <Lc_aec_reference_spkr_ttp_run_13>:
        }
    }

    if (pl_abs_i32(error) < op_extra_data->spkr_error_threshold)
84202dc4:	3a d8       	r0 = M[FP + 28];
84202dc6:	61 f0 bb 88 	rMAC = M[r4 + 748];
84202dca:	4f f2 42 ce 	r0 = ABS r0;
84202dce:	50 04       	Null = r0 - rMAC;
84202dd0:	02 f0 9d e0 	if C jump (m) Lc_aec_reference_spkr_ttp_run_16;

84202dd4 <Lc_aec_reference_spkr_ttp_run_14>:
    {
        /* This is normal situation, we have on-time input
         * and we can control ttp error
         */
        aec_reference_spkr_ttp_error_control(op_extra_data, error);
84202dd4:	3b d8       	r1 = M[FP + 28];
84202dd6:	32 00       	r0 = r4 + Null;
84202dd8:	01 f0 3d e9 	call (m) Lc_aec_reference_spkr_ttp_error_control_1;

        /* real audio is played, go to higher threshold */
        op_extra_data->spkr_error_threshold = SPKR_TTP_MAX_LATENCY_HIGH_THRESHOLD_US;
84202ddc:	01 f0 d0 4b 	rMAC = Null + 2000;
84202de0:	61 f0 bb 8e 	M[r4 + 748] = rMAC;
84202de4:	28 6e       	jump (m) Lc_aec_reference_spkr_ttp_run_22;

84202de6 <Lc_aec_reference_spkr_ttp_run_15>:
        unsigned samples_to_trash = convert_time_to_samples((unsigned)(-error), op_extra_data->input_rate);

        /* limit to amount available */
        samples_to_trash = MIN(amount_can_process, samples_to_trash);

        if(samples_to_trash > 0)
84202de6:	10 04       	Null = r0 - Null;
84202de8:	d0 63       	if NE jump (m) Lc_aec_reference_spkr_ttp_run_10;

84202dea <Lc__ite_4>:
84202dea:	ed 6f       	jump (m) Lc_aec_reference_spkr_ttp_run_13;

84202dec <Lc_aec_reference_spkr_ttp_run_16>:
    {
        /* Input is early, so we cannot allow samples from input buffers to be played now
         * instead we need to insert silence until time to play has reached. Silence insertion
         * is managed by cbops, we only tell cbops not to use samples from input buffer.
         */
        unsigned samples_early = convert_time_to_samples((unsigned)(error), op_extra_data->input_rate);
84202dec:	63 f0 70 88 	r1 = M[r4 + 448];
84202df0:	3a d8       	r0 = M[FP + 28];
84202df2:	ff fd ab f0 	call (m) 0x18422;
84202df6:	31 e1 
        if(samples_early >= op_extra_data->spkr_in_threshold)
84202df8:	63 f0 a8 88 	r1 = M[r4 + 672];
84202dfc:	d0 04       	Null = r0 - r1;
84202dfe:	03 64       	if NC jump (m) Lc_aec_reference_spkr_ttp_run_18;

84202e00 <Lc_aec_reference_spkr_ttp_run_17>:
        {
            /* It's early more than the amount cbops is expected to copy,
             * so allow nothing to copy.
             */
            amount_can_process = 0;
84202e00:	00 09       	r6 = Null + Null;
84202e02:	07 6e       	jump (m) Lc_aec_reference_spkr_ttp_run_20;

84202e04 <Lc_aec_reference_spkr_ttp_run_18>:
        {
            /* It's still early but less than the expected amount, we allow cbops to consume
             * expected amount less the amount early, silence insertion will be used for the amount early.
             * next time we expect to switch to normal TTP playback.
             */
            amount_can_process = MIN(op_extra_data->spkr_in_threshold - samples_early, amount_can_process);
84202e04:	99 04       	rMAC = r1 - r0;
84202e06:	8f f1 00 c2 	Null = rMAC - r6;
84202e0a:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_spkr_ttp_run_20;

84202e0e <Lc_aec_reference_spkr_ttp_run_19>:
84202e0e:	08 09       	r6 = rMAC + Null;

84202e10 <Lc_aec_reference_spkr_ttp_run_20>:
        }

        /* We are not playing real audio, so keep the threshold low */
        op_extra_data->spkr_error_threshold = SPKR_TTP_MAX_LATENCY_LOW_THRESHOLD_US;
84202e10:	01 f0 fa 40 	rMAC = Null + 250;
84202e14:	61 f0 bb 8e 	M[r4 + 748] = rMAC;

        L3_DBG_MSG3("AEC REFERENCE SPEAKER TTP: possible silence insertion: time=%d, samples=%d, max_proc=%d",
                    current_time, op_extra_data->spkr_in_threshold-amount_can_process, amount_can_process);
84202e18:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84202e1c:	c8 24       	Null = rMAC - 3;
84202e1e:	0b 68       	if LT jump (m) Lc_aec_reference_spkr_ttp_run_22;

84202e20 <Lc_aec_reference_spkr_ttp_run_21>:
84202e20:	8f f3 04 c2 	r2 = r1 - r6;
84202e24:	55 f1 02 f0 	r0 = Null + 357565045;
84202e28:	75 42 
84202e2a:	45 08       	r3 = r6 + Null;
84202e2c:	4b 08       	r1 = r7 + Null;
84202e2e:	ef fd ef ff 	call (m) 0xd08;
84202e32:	3b e6 

84202e34 <Lc_aec_reference_spkr_ttp_run_22>:

    }

    /* update amount to process */
    *max_to_process = amount_can_process;
84202e34:	a8 f0 00 ee 	M[r8 + Null] = r6;

84202e38 <Lc_aec_reference_spkr_ttp_run_23>:
    return;
}
84202e38:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
84202e3a:	d8 4c       	rts;

84202e3c <$_aec_reference_spkr_ttp_init>:
84202e3c:	d8 4c       	rts;

84202e3e <$_aec_reference_spkr_ttp_update_last_timestamp>:
 *        stamp associated with last consumed sample.
 * \param op_extra_data pointer to AEC_REFERENCE_OP_DATA data
 * \param amount_read amount read from input buffer
 */
void aec_reference_spkr_ttp_update_last_timestamp(AEC_REFERENCE_OP_DATA   *op_extra_data, unsigned amount_read)
{
84202e3e:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202e40:	16 00       	r4 = r0 + Null;
84202e42:	1a 00       	r0 = r1 + Null;

    patch_fn_shared(aec_reference);
    if(op_extra_data->spkr_last_timestamp_valid)
84202e44:	60 f0 b8 88 	Null = M[r4 + 736];
84202e48:	0b 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_update_last_timestamp_3;

84202e4a <Lc_aec_reference_spkr_ttp_update_last_timestamp_2>:
    {
        /* work out time stamp for next input block for the just read block,
         * TODO_AEC_REFERENCE_TTP: for further accuracy we could consider the tag sp_adjust as well */
        TIME_INTERVAL time_passed = convert_samples_to_time(amount_read, op_extra_data->input_rate);
84202e4a:	63 f0 70 88 	r1 = M[r4 + 448];
84202e4e:	ff fd aa f0 	call (m) 0x183fe;
84202e52:	31 ed 
        op_extra_data->spkr_last_timestamp = time_add(op_extra_data->spkr_last_timestamp, time_passed);
84202e54:	61 f0 b7 88 	rMAC = M[r4 + 732];
84202e58:	51 00       	rMAC = r0 + rMAC;
84202e5a:	61 f0 b7 8e 	M[r4 + 732] = rMAC;

84202e5e <Lc_aec_reference_spkr_ttp_update_last_timestamp_3>:
    }
}
84202e5e:	f1 48       	popm <FP, r4, rLink>;
84202e60:	d8 4c       	rts;

84202e62 <$_aec_reference_spkr_ttp_terminate>:
 * aec_reference_spkr_ttp_terminate
 * \brief terminates the speaker timed playback
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_spkr_ttp_terminate(AEC_REFERENCE_OP_DATA  *op_extra_data)
{
84202e62:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202e64:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

    /* destroy I'D controller */
    ttp_pid_controller_destroy(op_extra_data -> spkr_pid);
84202e66:	62 f0 bc 88 	r0 = M[r4 + 752];
84202e6a:	ff fd b2 f0 	call (m) 0x192c4;
84202e6e:	3b e2 
    op_extra_data->spkr_pid = NULL;
84202e70:	60 f0 bc 8e 	M[r4 + 752] = Null;
    op_extra_data->spkr_timed_playback_mode = FALSE;
84202e74:	60 f0 b6 8e 	M[r4 + 728] = Null;
    op_extra_data->spkr_last_timestamp_valid = 0;
84202e78:	60 f0 b8 8e 	M[r4 + 736] = Null;
    op_extra_data->spkr_void_tag_counter = 0;
84202e7c:	60 f0 ba 8e 	M[r4 + 744] = Null;

84202e80 <Lc_aec_reference_spkr_ttp_terminate_2>:
}
84202e80:	f1 48       	popm <FP, r4, rLink>;
84202e82:	d8 4c       	rts;

84202e84 <Lc_aec_reference_spkr_ttp_discard_samples_1>:
 * \param amount_to_discard number of samples to discard
 *
 * \return number of samples discarded
 > */
static unsigned aec_reference_spkr_ttp_discard_samples(AEC_REFERENCE_OP_DATA  *op_extra_data, unsigned amount_to_discard)
{
84202e84:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84202e86:	16 00       	r4 = r0 + Null;
84202e88:	1f 00       	r5 = r1 + Null;
    unsigned idx;

    patch_fn_shared(aec_reference);

    for(idx=0; idx < MAX_NUMBER_SPEAKERS; idx++)
84202e8a:	00 09       	r6 = Null + Null;
84202e8c:	05 6e       	jump (m) Lc_aec_reference_spkr_ttp_discard_samples_3;

84202e8e <Lc_aec_reference_spkr_ttp_discard_samples_2>:
    {
        tCbuffer *this_buf = op_extra_data->input_stream[SpeakerInputTerminalByIndex(idx)];
84202e8e:	80 f0 02 24 	Null = r6 - 2;
84202e92:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_spkr_ttp_discard_samples_4;

84202e96 <Lc_aec_reference_spkr_ttp_discard_samples_3>:
84202e96:	42 08       	r0 = r6 + Null;
84202e98:	03 6e       	jump (m) Lc_aec_reference_spkr_ttp_discard_samples_5;

84202e9a <Lc_aec_reference_spkr_ttp_discard_samples_4>:
84202e9a:	82 f0 04 20 	r0 = r6 + 4;

84202e9e <Lc_aec_reference_spkr_ttp_discard_samples_5>:
84202e9e:	52 54       	r0 = r0 LSHIFT 2;
        if(NULL !=  this_buf)
84202ea0:	b2 e8       	r0 = M[r4 + r0];
84202ea2:	07 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_discard_samples_8;

84202ea4 <Lc_aec_reference_spkr_ttp_discard_samples_6>:
        {
            unsigned amount_data = cbuffer_calc_amount_data_in_words(this_buf);
84202ea4:	ff fd b7 f1 	call (m) 0x39dd4;
84202ea8:	31 e9 
            amount_to_discard = MIN(amount_to_discard, amount_data);
84202eaa:	b8 04       	Null = r5 - r0;
84202eac:	02 64       	if NC jump (m) Lc_aec_reference_spkr_ttp_discard_samples_8;

84202eae <Lc_aec_reference_spkr_ttp_discard_samples_7>:
84202eae:	17 00       	r5 = r0 + Null;

84202eb0 <Lc_aec_reference_spkr_ttp_discard_samples_8>:
{
    unsigned idx;

    patch_fn_shared(aec_reference);

    for(idx=0; idx < MAX_NUMBER_SPEAKERS; idx++)
84202eb0:	08 75       	r6 = r6 + 1;
84202eb2:	80 f0 08 24 	Null = r6 - 8;
84202eb6:	ec 65       	if NC jump (m) Lc_aec_reference_spkr_ttp_discard_samples_2;

84202eb8 <Lc_aec_reference_spkr_ttp_discard_samples_9>:
            amount_to_discard = MIN(amount_to_discard, amount_data);
        }
    }

    /* don't continue if nothing to discard */
    if(amount_to_discard == 0)
84202eb8:	38 04       	Null = r5 - Null;
84202eba:	03 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_discard_samples_11;

84202ebc <Lc_aec_reference_spkr_ttp_discard_samples_10>:
    {
        return 0;
84202ebc:	02 00       	r0 = Null + Null;
84202ebe:	1b 6e       	jump (m) Lc_aec_reference_spkr_ttp_discard_samples_19;

84202ec0 <Lc_aec_reference_spkr_ttp_discard_samples_11>:
    }

    /* advance the read point of all speaker graph input buffers */
    for(idx=0; idx < MAX_NUMBER_SPEAKERS; idx++)
84202ec0:	00 09       	r6 = Null + Null;
84202ec2:	05 6e       	jump (m) Lc_aec_reference_spkr_ttp_discard_samples_13;

84202ec4 <Lc_aec_reference_spkr_ttp_discard_samples_12>:
    {
        tCbuffer *this_buf = op_extra_data->input_stream[SpeakerInputTerminalByIndex(idx)];
84202ec4:	80 f0 02 24 	Null = r6 - 2;
84202ec8:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_spkr_ttp_discard_samples_14;

84202ecc <Lc_aec_reference_spkr_ttp_discard_samples_13>:
84202ecc:	42 08       	r0 = r6 + Null;
84202ece:	03 6e       	jump (m) Lc_aec_reference_spkr_ttp_discard_samples_15;

84202ed0 <Lc_aec_reference_spkr_ttp_discard_samples_14>:
84202ed0:	82 f0 04 20 	r0 = r6 + 4;

84202ed4 <Lc_aec_reference_spkr_ttp_discard_samples_15>:
84202ed4:	52 54       	r0 = r0 LSHIFT 2;
        if(NULL !=  this_buf)
84202ed6:	b2 e8       	r0 = M[r4 + r0];
84202ed8:	05 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_discard_samples_17;

84202eda <Lc_aec_reference_spkr_ttp_discard_samples_16>:
        {
            cbuffer_advance_read_ptr(this_buf, amount_to_discard);
84202eda:	3b 00       	r1 = r5 + Null;
84202edc:	ff fd b7 f1 	call (m) 0x39de2;
84202ee0:	27 e8 

84202ee2 <Lc_aec_reference_spkr_ttp_discard_samples_17>:
    {
        return 0;
    }

    /* advance the read point of all speaker graph input buffers */
    for(idx=0; idx < MAX_NUMBER_SPEAKERS; idx++)
84202ee2:	08 75       	r6 = r6 + 1;
84202ee4:	80 f0 08 24 	Null = r6 - 8;
84202ee8:	ee 65       	if NC jump (m) Lc_aec_reference_spkr_ttp_discard_samples_12;

84202eea <Lc_aec_reference_spkr_ttp_discard_samples_18>:
    }

    /* any change of buffer pointers outside cbops will need
     * refreshing buffers by cbops
     */
    cbops_refresh_buffers(op_extra_data->spkr_graph);
84202eea:	61 f0 7f 88 	rMAC = M[r4 + 508];
84202eee:	42 20       	r0 = Null + 1;
84202ef0:	ca 8f       	M[rMAC + 28] = r0;
    return amount_to_discard;
84202ef2:	3a 00       	r0 = r5 + Null;

84202ef4 <Lc_aec_reference_spkr_ttp_discard_samples_19>:

}
84202ef4:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84202ef6:	d8 4c       	rts;

84202ef8 <Lc_aec_reference_spkr_ttp_get_error_1>:
 *        and (estimated) actual playback time. So the error will be
 *        positive if ttp is later than actual playback time.
 * return whether the error is valid
 */
static bool aec_reference_spkr_ttp_get_error(AEC_REFERENCE_OP_DATA *op_extra_data, TIME_INTERVAL *error)
{
84202ef8:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
84202efa:	16 00       	r4 = r0 + Null;
84202efc:	18 09       	r6 = r1 + Null;
    /* see if we have valid metadata buffer */
    tCbuffer *met_buf = op_extra_data->spkr_input_metadata_buffer;
    patch_fn_shared(aec_reference_run);

    if (met_buf!= NULL && buff_has_metadata(met_buf))
84202efe:	62 f0 c2 88 	r0 = M[r4 + 776];
84202f02:	94 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_23;

84202f04 <Lc_aec_reference_spkr_ttp_get_error_2>:
84202f04:	91 89       	rMAC = M[r0 + 24];
84202f06:	92 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_23;

84202f08 <Lc_aec_reference_spkr_ttp_get_error_3>:
    {
        /* see if input has a timestamped tag */
        unsigned b4idx = 0;
84202f08:	30 de       	M[FP + 24] = Null;
        metadata_tag *mtag = buff_metadata_peek_ex(met_buf, &b4idx);
84202f0a:	83 11       	r1 = FP + 24;
84202f0c:	ff fd 8d f0 	call (m) 0x14930;
84202f10:	25 e1 
84202f12:	17 00       	r5 = r0 + Null;

        if(mtag != NULL)
84202f14:	5d 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_18;

84202f16 <Lc_aec_reference_spkr_ttp_get_error_4>:
        {
            if(IS_TIMESTAMPED_TAG(mtag))
84202f16:	79 88       	rMAC = M[r5 + 4];
84202f18:	12 f0 30 00 	r0 = rMAC AND 0x30;
84202f1c:	4c 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_14;

84202f1e <Lc_aec_reference_spkr_ttp_get_error_5>:
84202f1e:	ca c2       	r0 = rMAC AND 0x40;
84202f20:	4a 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_14;

84202f22 <Lc_aec_reference_spkr_ttp_get_error_6>:
            {
                unsigned *err_offset_id;
                unsigned out_length;

                /* go back to first input sample */
                TIME_INTERVAL time_back = convert_samples_to_time(b4idx / OCTETS_PER_SAMPLE, op_extra_data->input_rate);
84202f22:	63 f0 70 88 	r1 = M[r4 + 448];
84202f26:	32 d8       	r0 = M[FP + 24];
84202f28:	52 50       	r0 = r0 LSHIFT -2;
84202f2a:	ff fd aa f0 	call (m) 0x183fe;
84202f2e:	35 e6 

                /* set the time stamp,
                 * TODO_AEC_REFERENCE_TTP: for further accuracy we could consider the tag sp_adjust as well */
                op_extra_data->spkr_last_timestamp = time_sub(mtag->timestamp, time_back);
84202f30:	39 89       	rMAC = M[r5 + 16];
84202f32:	89 04       	rMAC = rMAC - r0;
84202f34:	61 f0 b7 8e 	M[r4 + 732] = rMAC;

                /* See if tag's timestamp has an offset*/
                if (buff_metadata_find_private_data(mtag, META_PRIV_KEY_TTP_OFFSET, &out_length,
                                                    (void **)&err_offset_id))
84202f38:	c5 11       	r3 = FP + 28;
84202f3a:	04 12       	r2 = FP + 32;
84202f3c:	43 20       	r1 = Null + 1;
84202f3e:	3a 00       	r0 = r5 + Null;
84202f40:	ff fd 8c f0 	call (m) 0x14762;
84202f44:	23 e1 
84202f46:	10 04       	Null = r0 - Null;
84202f48:	0e 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_9;

84202f4a <Lc_aec_reference_spkr_ttp_get_error_7>:
                {
                    int *err_offset_ptr = ttp_info_get(*err_offset_id);
84202f4a:	39 d8       	rMAC = M[FP + 28];
84202f4c:	0a e8       	r0 = M[rMAC + Null];
84202f4e:	ff fd b6 f0 	call (m) 0x19c1a;
84202f52:	2d e6 
                    if (err_offset_ptr != NULL)
84202f54:	10 04       	Null = r0 - Null;
84202f56:	07 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_9;

84202f58 <Lc_aec_reference_spkr_ttp_get_error_8>:
                    {
                        /* subtract the offset */
                        op_extra_data->spkr_last_timestamp =
                            time_sub(op_extra_data->spkr_last_timestamp, *err_offset_ptr);
84202f58:	61 f0 b7 88 	rMAC = M[r4 + 732];
84202f5c:	12 e8       	r0 = M[r0 + Null];
84202f5e:	89 04       	rMAC = rMAC - r0;
84202f60:	61 f0 b7 8e 	M[r4 + 732] = rMAC;

84202f64 <Lc_aec_reference_spkr_ttp_get_error_9>:
                    }
                }

                /* this will stay valid */
                op_extra_data->spkr_last_timestamp_valid = TRUE;
84202f64:	41 20       	rMAC = Null + 1;
84202f66:	61 f0 b8 8e 	M[r4 + 736] = rMAC;

                /* switch to timed playback mode if not already,
                 * this is irreversible
                 */
                if(!op_extra_data->spkr_timed_playback_mode)
84202f6a:	60 f0 b6 88 	Null = M[r4 + 728];
84202f6e:	20 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_13;

84202f70 <Lc_aec_reference_spkr_ttp_get_error_10>:
                    /* For the first time we have seen a timestamp,
                     * This means the metadata buffer will supply timestamp tags
                     * that are required for timed playback. Now is the time to
                     * switch to timed playback mode for speaker graph.
                     */
                    op_extra_data->spkr_timed_playback_mode = aec_reference_spkr_ttp_setup_timed_playback(op_extra_data);
84202f70:	32 00       	r0 = r4 + Null;
84202f72:	5f 4e       	call (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_1;
84202f74:	62 f0 b6 8e 	M[r4 + 728] = r0;
                    if(op_extra_data->spkr_timed_playback_mode)
84202f78:	60 f0 b6 88 	Null = M[r4 + 728];
84202f7c:	19 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_13;

84202f7e <Lc_aec_reference_spkr_ttp_get_error_11>:
                        /* tell the endpoint that speaker is performing rate adjustment, normally
                         * this is done when enacting config is received from framework, however
                         * in case we haven't received (can happen if input is coming from a2dp
                         * source) we do it here.
                         */
                        opmgr_override_set_ratematch_enacting(op_extra_data->spkr_endpoint, TRUE);
84202f7e:	43 20       	r1 = Null + 1;
84202f80:	62 f0 a3 88 	r0 = M[r4 + 652];
84202f84:	ff fd 12 f0 	call (m) 0x554a;
84202f88:	27 ee 

                        /* tell the overridden endpoint that we are in timed playback mode,
                         * this is to prevent extra accumulation of HW warps in endpoint so it
                         * won't mess with PID controller. (only nedded for hw rate adjust)
                         */
                        opmgr_override_set_direct_warp(op_extra_data->spkr_endpoint, TRUE);
84202f8a:	43 20       	r1 = Null + 1;
84202f8c:	62 f0 a3 88 	r0 = M[r4 + 652];
84202f90:	ff fd 12 f0 	call (m) 0x54c4;
84202f94:	35 e9 

                        L2_DBG_MSG1("AEC REFERENCE: Speaker graph switched to timed play back mode: %d",
                                    op_extra_data->spkr_timed_playback_mode);
84202f96:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84202f9a:	88 24       	Null = rMAC - 2;
84202f9c:	09 68       	if LT jump (m) Lc_aec_reference_spkr_ttp_get_error_13;

84202f9e <Lc_aec_reference_spkr_ttp_get_error_12>:
84202f9e:	63 f0 b6 88 	r1 = M[r4 + 728];
84202fa2:	55 f1 02 f0 	r0 = Null + 357565133;
84202fa6:	cd 42 
84202fa8:	ef fd ee ff 	call (m) 0xcde;
84202fac:	37 e9 

84202fae <Lc_aec_reference_spkr_ttp_get_error_13>:
                    L2_DBG_MSG2("AEC REFERENCE, stopped seeing VOID tags, time=%d, %d",
                                time_get_time(), op_extra_data->spkr_void_tag_counter);
                }
#endif
                /* void tag not seen */
                op_extra_data->spkr_void_tag_observed = FALSE;
84202fae:	60 f0 b9 8e 	M[r4 + 740] = Null;
84202fb2:	0e 6e       	jump (m) Lc_aec_reference_spkr_ttp_get_error_18;

84202fb4 <Lc_aec_reference_spkr_ttp_get_error_14>:

            } /* IS_TIMESTAMPED_TAG(mtag) */
            else if(IS_VOID_TTP_TAG(mtag) && op_extra_data->spkr_timed_playback_mode)
84202fb4:	11 f0 70 00 	rMAC = rMAC AND 0x70;
84202fb8:	10 f0 50 24 	Null = rMAC - 80;
84202fbc:	09 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_18;

84202fbe <Lc_aec_reference_spkr_ttp_get_error_15>:
84202fbe:	38 89       	Null = M[r5 + 16];
84202fc0:	07 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_18;

84202fc2 <Lc_aec_reference_spkr_ttp_get_error_16>:
84202fc2:	60 f0 b6 88 	Null = M[r4 + 728];
84202fc6:	04 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_18;

84202fc8 <Lc_aec_reference_spkr_ttp_get_error_17>:
                if(!op_extra_data->spkr_void_tag_observed)
                {
                    L2_DBG_MSG1("AEC REFERENCE, started seeing VOID tags, time=%d", time_get_time());
                }
#endif
                op_extra_data->spkr_void_tag_observed = TRUE;
84202fc8:	41 20       	rMAC = Null + 1;
84202fca:	61 f0 b9 8e 	M[r4 + 740] = rMAC;

84202fce <Lc_aec_reference_spkr_ttp_get_error_18>:
            }
        } /* if(mtag != NULL) */

        if(op_extra_data->spkr_last_timestamp_valid)
84202fce:	60 f0 b8 88 	Null = M[r4 + 736];
84202fd2:	29 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_22;

84202fd4 <Lc_aec_reference_spkr_ttp_get_error_19>:
             *
             * TODO_AEC_REFERENCE_TTP: since the task for speaker graph is timer based, the time
             * of sampling isn't aligned with the output consuming time, so it
             * could have up to one sample period random jitter.
             */
            TIME cur_time = time_get_time();
84202fd4:	ff fd 18 f0 	call (m) 0x6100;
84202fd8:	2d e9 
84202fda:	17 00       	r5 = r0 + Null;
            unsigned amount_in_output = cbuffer_calc_amount_data_in_words(op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1]);
84202fdc:	72 a8       	r0 = M[r4 + 68];
84202fde:	ff fd b6 f1 	call (m) 0x39dd4;
84202fe2:	37 ef 
            TIME_INTERVAL offset = convert_samples_to_time(amount_in_output, op_extra_data->spkr_rate);
84202fe4:	63 f0 7b 88 	r1 = M[r4 + 492];
84202fe8:	ff fd aa f0 	call (m) 0x183fe;
84202fec:	37 e0 
84202fee:	11 09       	r7 = r0 + Null;
84202ff0:	49 08       	rMAC = r7 + Null;

            /* if we have SW rate adjustment in the graph */
            if(op_extra_data->spkr_sw_rateadj_op != NULL)
84202ff2:	62 f0 9f 88 	r0 = M[r4 + 636];
84202ff6:	0f 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_21;

84202ff8 <Lc_aec_reference_spkr_ttp_get_error_20>:
            {
                /* adjust for the phase difference between first input and first output sample */
                offset -= (int)frac_mult(SECOND, (int)cbops_sra_get_phase(op_extra_data->spkr_sw_rateadj_op)) / (int) op_extra_data->spkr_rate;
84202ff8:	ff fd b6 f0 	call (m) 0x19db2;
84202ffc:	3b ed 
84202ffe:	00 f0 a3 f7 	r1 = Null + 1000000;
84203002:	40 42 
84203004:	61 f0 7b 88 	rMAC = M[r4 + 492];
84203008:	2f f3 42 c9 	r0 = r1 * r0 (frac);
8420300c:	8a 4c       	Div = r0 / rMAC;
8420300e:	c1 4c       	rMAC = DivResult;
84203010:	1f f9 01 c2 	rMAC = r7 - rMAC;

84203014 <Lc_aec_reference_spkr_ttp_get_error_21>:
            /* Add extra delay that might occur in the path
             * (adjustment for any resampler, HW rate matching,
             *  cbops algorithmic delays and any external delay)
             * TODO_AEC_REFERENCE_TTP: spkr_extra_delay isn't set yet
             */
            offset += op_extra_data->spkr_extra_delay;
84203014:	62 f0 c0 88 	r0 = M[r4 + 768];
84203018:	51 00       	rMAC = r0 + rMAC;

            /* compute error */
            *error = time_sub(op_extra_data->spkr_last_timestamp, cur_time) - offset;
8420301a:	62 f0 b7 88 	r0 = M[r4 + 732];
8420301e:	d2 05       	r0 = r0 - r5;
84203020:	1f f2 88 c3 	M[r6] = r0 - rMAC;

84203024 <Lc_aec_reference_spkr_ttp_get_error_22>:
        }

        return op_extra_data->spkr_last_timestamp_valid;
84203024:	62 f0 b8 88 	r0 = M[r4 + 736];
84203028:	02 6e       	jump (m) Lc_aec_reference_spkr_ttp_get_error_24;

8420302a <Lc_aec_reference_spkr_ttp_get_error_23>:
    } /* buff_has_metadata  */

    /* always return invalid error if we don't have metadata buffer */
    return FALSE;
8420302a:	02 00       	r0 = Null + Null;

8420302c <Lc_aec_reference_spkr_ttp_get_error_24>:
}
8420302c:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
8420302e:	d8 4c       	rts;

84203030 <Lc_aec_reference_spkr_ttp_setup_timed_playback_1>:
 *
 * \param op_extra_data pointer to AEC_REFERENCE_OP_DATA data
 * return TRUE if setting up was successful else FALSE.
 */
static bool aec_reference_spkr_ttp_setup_timed_playback(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84203030:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84203032:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

    if(op_extra_data -> spkr_pid == NULL)
84203034:	61 f0 bc 88 	rMAC = M[r4 + 752];
84203038:	0e 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_5;

8420303a <Lc_aec_reference_spkr_ttp_setup_timed_playback_2>:
    {
        /* create PID controller */
        op_extra_data -> spkr_pid = ttp_pid_controller_create();
8420303a:	ff fd b1 f0 	call (m) 0x192b6;
8420303e:	3d e3 
84203040:	62 f0 bc 8e 	M[r4 + 752] = r0;
        if(NULL == op_extra_data -> spkr_pid)
84203044:	62 f0 bc 88 	r0 = M[r4 + 752];
84203048:	03 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_4;

8420304a <Lc_aec_reference_spkr_ttp_setup_timed_playback_3>:
        {
            /* We cannot go to timed playback mode without PID controller */
            return FALSE;
8420304a:	02 00       	r0 = Null + Null;
8420304c:	4f 6e       	jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_15;

8420304e <Lc_aec_reference_spkr_ttp_setup_timed_playback_4>:

        /* Use default parameters for this controller,
         * TODO_AEC_REFERENCE_TTP: see if we need any specific setting and/or
         * per sample rate setting
         */
        ttp_pid_controller_use_default_parameters(op_extra_data -> spkr_pid);
8420304e:	ff fd b1 f0 	call (m) 0x193ee;
84203052:	21 ed 

84203054 <Lc_aec_reference_spkr_ttp_setup_timed_playback_5>:
    }

    /* reset speaker ttp control */
    aec_reference_spkr_ttp_reset(op_extra_data);
84203054:	32 00       	r0 = r4 + Null;
84203056:	4c 4e       	call (m) Lc_aec_reference_spkr_ttp_reset_1;

    /* use ttp SW rate adjust if speaker is capable */
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_HW)
84203058:	61 f0 7c 88 	rMAC = M[r4 + 496];
8420305c:	88 24       	Null = rMAC - 2;
8420305e:	12 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_9;

84203060 <Lc_aec_reference_spkr_ttp_setup_timed_playback_6>:
    {
        op_extra_data->spkr_ttp_adjust_type = RATEMATCHING_SUPPORT_HW;
84203060:	81 20       	rMAC = Null + 2;
84203062:	61 f0 c1 8e 	M[r4 + 772] = rMAC;

        /* we want to do HW rate matching in timed playback mode */
        if(op_extra_data->spkr_sw_rateadj_op != NULL)
84203066:	62 f0 9f 88 	r0 = M[r4 + 636];
8420306a:	05 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_8;

8420306c <Lc_aec_reference_spkr_ttp_setup_timed_playback_7>:
        {
            /* if we have SW rate adjust, then set it to pass-through mode */
            cbops_rateadjust_passthrough_mode(op_extra_data->spkr_sw_rateadj_op, TRUE);
8420306c:	43 20       	r1 = Null + 1;
8420306e:	ff fd b6 f0 	call (m) 0x19d0a;
84203072:	3d e4 

84203074 <Lc_aec_reference_spkr_ttp_setup_timed_playback_8>:
        }

        /* fresh start from 0 warp value */
        opmgr_override_set_ratematch_adjustment(op_extra_data->spkr_endpoint, 0);
84203074:	62 f0 a3 88 	r0 = M[r4 + 652];
84203078:	03 00       	r1 = Null + Null;
8420307a:	ff fd 12 f0 	call (m) 0x54b4;
8420307e:	3b e1 
84203080:	30 6e       	jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_14;

84203082 <Lc_aec_reference_spkr_ttp_setup_timed_playback_9>:
    }
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
    else if(0 != op_extra_data->spkr_ext_rate_adjust_op)
84203082:	62 f0 a1 88 	r0 = M[r4 + 644];
84203086:	1b 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_12;

84203088 <Lc_aec_reference_spkr_ttp_setup_timed_playback_10>:
    {
        /* we will do software TTP using a standalone rate adjust operator */
        op_extra_data->spkr_ttp_adjust_type = RATEMATCHING_SUPPORT_SW;
84203088:	41 20       	rMAC = Null + 1;
8420308a:	61 f0 c1 8e 	M[r4 + 772] = rMAC;
        op_extra_data->spkr_rate_adjustment = 0;
8420308e:	60 f0 7d 8e 	M[r4 + 500] = Null;

        /* reset the current rate */
        stream_delegate_rate_adjust_set_current_rate(op_extra_data->spkr_ext_rate_adjust_op, 0);
84203092:	03 00       	r1 = Null + Null;
84203094:	ff fd 86 f0 	call (m) 0x13d6c;
84203098:	39 e6 

        /* not in passthrough mode */
        stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->spkr_ext_rate_adjust_op, FALSE);
8420309a:	62 f0 a1 88 	r0 = M[r4 + 644];
8420309e:	03 00       	r1 = Null + Null;
842030a0:	ff fd 86 f0 	call (m) 0x13d48;
842030a4:	29 e5 

        /* we shouldn't have created built-in rate adjust operator */
        PL_ASSERT(op_extra_data->spkr_sw_rateadj_op == NULL);
842030a6:	61 f0 9f 88 	rMAC = M[r4 + 636];
842030aa:	1b 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_14;

842030ac <Lc_aec_reference_spkr_ttp_setup_timed_playback_11>:
842030ac:	03 f0 01 42 	r1 = Null + 513;
842030b0:	02 f0 13 60 	r0 = Null + 4115;
842030b4:	ff fd 9f f0 	call (m) 0x16ff0;
842030b8:	3d e9 
842030ba:	18 6e       	jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_15;

842030bc <Lc_aec_reference_spkr_ttp_setup_timed_playback_12>:
    }
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */
    else if(op_extra_data->spkr_sw_rateadj_op != NULL)
842030bc:	62 f0 9f 88 	r0 = M[r4 + 636];
842030c0:	c5 61       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_3;

842030c2 <Lc_aec_reference_spkr_ttp_setup_timed_playback_13>:
    {
        /* We have a rate adjust operator, so we can do software TTP */
        op_extra_data->spkr_ttp_adjust_type = RATEMATCHING_SUPPORT_SW;
842030c2:	41 20       	rMAC = Null + 1;
842030c4:	61 f0 c1 8e 	M[r4 + 772] = rMAC;
        op_extra_data->spkr_rate_adjustment=0;
842030c8:	60 f0 7d 8e 	M[r4 + 500] = Null;
        cbops_sra_set_rate_adjust(op_extra_data->spkr_sw_rateadj_op, 0);
842030cc:	03 00       	r1 = Null + Null;
842030ce:	ff fd b6 f0 	call (m) 0x19d10;
842030d2:	23 e2 
		/* force coming out of pass-through mode */
        cbops_rateadjust_passthrough_mode(op_extra_data->spkr_sw_rateadj_op, FALSE);
842030d4:	62 f0 9f 88 	r0 = M[r4 + 636];
842030d8:	03 00       	r1 = Null + Null;
842030da:	ff fd b6 f0 	call (m) 0x19d0a;
842030de:	31 e1 

842030e0 <Lc_aec_reference_spkr_ttp_setup_timed_playback_14>:
         */
        return FALSE;
    }

	/* even if we aren't told, speaker graph is enacting */
	op_extra_data->spkr_rate_enactment = op_extra_data->spkr_rate_ability;
842030e0:	61 f0 7c 88 	rMAC = M[r4 + 496];
842030e4:	61 f0 7e 8e 	M[r4 + 504] = rMAC;

    return TRUE;
842030e8:	42 20       	r0 = Null + 1;

842030ea <Lc_aec_reference_spkr_ttp_setup_timed_playback_15>:
}
842030ea:	f1 48       	popm <FP, r4, rLink>;
842030ec:	d8 4c       	rts;

842030ee <Lc_aec_reference_spkr_ttp_reset_1>:
 * \brief reset timed playback mode internal state
 * \param op_extra_data pointer to AEC_REFERENCE_OP_DATA data
 * \param error difference between expected ttp and now
 */
static void aec_reference_spkr_ttp_reset(AEC_REFERENCE_OP_DATA *op_extra_data)
{
842030ee:	c8 1c       	pushm <FP(=SP), rLink>;
    patch_fn_shared(aec_reference);

    op_extra_data->spkr_ttp_error_acc = 0;
842030f0:	20 f0 be 8e 	M[r0 + 760] = Null;
    op_extra_data->spkr_ttp_error_acc_cnt = 0;
842030f4:	20 f0 bf 8e 	M[r0 + 764] = Null;
    op_extra_data->spkr_last_ttp_error = 0;
842030f8:	20 f0 bd 8e 	M[r0 + 756] = Null;
    op_extra_data->spkr_error_threshold = SPKR_TTP_MAX_LATENCY_LOW_THRESHOLD_US;
842030fc:	01 f0 fa 40 	rMAC = Null + 250;
84203100:	21 f0 bb 8e 	M[r0 + 748] = rMAC;
    if(NULL != op_extra_data->spkr_pid)
84203104:	22 f0 bc 88 	r0 = M[r0 + 752];
84203108:	04 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_reset_3;

8420310a <Lc_aec_reference_spkr_ttp_reset_2>:
    {
        ttp_pid_controller_reset(op_extra_data->spkr_pid);
8420310a:	ff fd b1 f0 	call (m) 0x193d2;
8420310e:	29 e6 

84203110 <Lc_aec_reference_spkr_ttp_reset_3>:
    }
}
84203110:	c8 48       	popm <FP, rLink>;
84203112:	d8 4c       	rts;

84203114 <Lc_aec_reference_spkr_ttp_error_control_1>:
 * \brief running PID controller to minimise the ttp error
 * \param pointer to AEC_REFERENCE_OP_DATA data
 * \param error difference between expected and estimated time to play
 */
static void aec_reference_spkr_ttp_error_control(AEC_REFERENCE_OP_DATA *op_extra_data, TIME_INTERVAL error)
{
84203114:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84203116:	16 00       	r4 = r0 + Null;
    int error_diff;
    patch_fn_shared(aec_reference);

    /* ignore the error if we have a big jump in error */
    error_diff = error - op_extra_data->spkr_last_ttp_error;
84203118:	61 f0 bd 88 	rMAC = M[r4 + 756];
8420311c:	5a 04       	r0 = r1 - rMAC;
    op_extra_data->spkr_last_ttp_error = error;
8420311e:	63 f0 bd 8e 	M[r4 + 756] = r1;
    if (pl_abs_i32(error_diff) > SPKR_TTP_MAX_ERROR_JUMP_US)
84203122:	4f f2 42 ce 	r0 = ABS r0;
84203126:	90 3c       	Null = r0 - 50;
84203128:	08 f0 c9 e0 	if HI jump (m) Lc_aec_reference_spkr_ttp_error_control_4;

8420312c <Lc_aec_reference_spkr_ttp_error_control_2>:
    {
        return;
    }

    /* accumulate error for averaging */
    op_extra_data->spkr_ttp_error_acc_cnt++;
8420312c:	61 f0 bf 88 	rMAC = M[r4 + 764];
84203130:	49 20       	rMAC = rMAC + 1;
84203132:	61 f0 bf 8e 	M[r4 + 764] = rMAC;
    op_extra_data->spkr_ttp_error_acc += error;
84203136:	62 f0 be 88 	r0 = M[r4 + 760];
8420313a:	9a 00       	r0 = r1 + r0;
8420313c:	62 f0 be 8e 	M[r4 + 760] = r0;
    if(op_extra_data->spkr_ttp_error_acc_cnt == SPKR_TTP_ERROR_AVERAGING_PERIOD_MS)
84203140:	88 26       	Null = rMAC - 10;
84203142:	17 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_error_control_4;

84203144 <Lc_aec_reference_spkr_ttp_error_control_3>:
    {
        /* calculate average error */
        int error_avg = frac_mult(op_extra_data->spkr_ttp_error_acc,
                                  FRACTIONAL(1.0/SPKR_TTP_ERROR_AVERAGING_PERIOD_MS));
84203144:	cc f0 63 f6 	r1 = Null + 214748364;
84203148:	cc 58 
8420314a:	3f f2 43 c9 	r1 = r0 * r1 (frac);

        /* run controller to minimise the error */
        ttp_pid_controller_run(op_extra_data->spkr_pid, error_avg);
8420314e:	62 f0 bc 88 	r0 = M[r4 + 752];
84203152:	ff fd b0 f0 	call (m) 0x192ce;
84203156:	3d eb 
                    time_get_time(),
                    error_avg,
                    ttp_pid_controller_get_warp(op_extra_data->spkr_pid));
#endif
        /* apply the last calculated warp rate */
        aec_reference_spkr_ttp_adjust_rate(op_extra_data, ttp_pid_controller_get_warp(op_extra_data->spkr_pid));
84203158:	62 f0 bc 88 	r0 = M[r4 + 752];
8420315c:	ff fd b1 f0 	call (m) 0x1945e;
84203160:	23 e8 
84203162:	13 00       	r1 = r0 + Null;
84203164:	32 00       	r0 = r4 + Null;
84203166:	07 4e       	call (m) Lc_aec_reference_spkr_ttp_adjust_rate_1;

        /* reset the averaging accumulator */
        op_extra_data->spkr_ttp_error_acc_cnt = 0;
84203168:	60 f0 bf 8e 	M[r4 + 764] = Null;
        op_extra_data->spkr_ttp_error_acc = 0;
8420316c:	60 f0 be 8e 	M[r4 + 760] = Null;

84203170 <Lc_aec_reference_spkr_ttp_error_control_4>:
    }
}
84203170:	f1 48       	popm <FP, r4, rLink>;
84203172:	d8 4c       	rts;

84203174 <Lc_aec_reference_spkr_ttp_adjust_rate_1>:
 * \brief applies warp rate to enacting sra
 * \param pointer to AEC_REFERENCE_OP_DATA data
 * \param warp warp value
 */
static void aec_reference_spkr_ttp_adjust_rate(AEC_REFERENCE_OP_DATA *op_extra_data, int warp)
{
84203174:	c8 1c       	pushm <FP(=SP), rLink>;
    patch_fn_shared(aec_reference);

    /* expect to come here only in timed playback mode */
    PL_ASSERT(op_extra_data->spkr_timed_playback_mode);
84203176:	20 f0 b6 88 	Null = M[r0 + 728];
8420317a:	09 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_3;

8420317c <Lc_aec_reference_spkr_ttp_adjust_rate_2>:
8420317c:	03 f0 67 42 	r1 = Null + 615;
84203180:	02 f0 13 60 	r0 = Null + 4115;
84203184:	ff fd 9f f0 	call (m) 0x16ff0;
84203188:	2d e3 
8420318a:	1a 6e       	jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

8420318c <Lc_aec_reference_spkr_ttp_adjust_rate_3>:

    if(op_extra_data->spkr_ttp_adjust_type == RATEMATCHING_SUPPORT_HW)
8420318c:	21 f0 c1 88 	rMAC = M[r0 + 772];
84203190:	88 24       	Null = rMAC - 2;
84203192:	07 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_5;

84203194 <Lc_aec_reference_spkr_ttp_adjust_rate_4>:
    {
        /* set the HW warp value by sending that to real audio ep
         * NOTE TODO_AEC_REFERENCE_TTP: HW warp hasn't been tested */
        opmgr_override_set_ratematch_adjustment(op_extra_data->spkr_endpoint, warp);
84203194:	22 f0 a3 88 	r0 = M[r0 + 652];
84203198:	ff fd 11 f0 	call (m) 0x54b4;
8420319c:	3d e8 
8420319e:	10 6e       	jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

842031a0 <Lc_aec_reference_spkr_ttp_adjust_rate_5>:
    }
    else if(op_extra_data->spkr_ttp_adjust_type == RATEMATCHING_SUPPORT_SW)
842031a0:	48 24       	Null = rMAC - 1;
842031a2:	0e 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

842031a4 <Lc_aec_reference_spkr_ttp_adjust_rate_6>:
    {
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
        if(0 != op_extra_data->spkr_ext_rate_adjust_op)
842031a4:	21 f0 a1 88 	rMAC = M[r0 + 644];
842031a8:	06 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_8;

842031aa <Lc_aec_reference_spkr_ttp_adjust_rate_7>:
        {
            /* rate adjust using external rate adjust operator */
            stream_delegate_rate_adjust_set_current_rate(op_extra_data->spkr_ext_rate_adjust_op, warp);
842031aa:	0a 00       	r0 = rMAC + Null;
842031ac:	ff fd 85 f0 	call (m) 0x13d6c;
842031b0:	21 ee 
842031b2:	06 6e       	jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

842031b4 <Lc_aec_reference_spkr_ttp_adjust_rate_8>:
        }
        else
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */
        {
            /* set the SW rate adjust warp value */
            cbops_sra_set_rate_adjust(op_extra_data->spkr_sw_rateadj_op, warp);
842031b4:	22 f0 9f 88 	r0 = M[r0 + 636];
842031b8:	ff fd b5 f0 	call (m) 0x19d10;
842031bc:	39 ea 

842031be <Lc_aec_reference_spkr_ttp_adjust_rate_9>:
        }
    }
}
842031be:	c8 48       	popm <FP, rLink>;
842031c0:	d8 4c       	rts;

842031c2 <$_create_aec_ref_sidetone_op>:
842031c2:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
                                     unsigned nr_spkrs,
                                     unsigned *sidetone_idx,
                                     unsigned spkr_threshold,
                                     unsigned safety_threshold)

{
842031c4:	13 09       	r9 = r0 + Null;
842031c6:	1a 09       	r8 = r1 + Null;
842031c8:	21 09       	r7 = r2 + Null;
842031ca:	2f 00       	r5 = r3 + Null;
842031cc:	ee d9       	r4 = M[FP + -12];
    cbops_op *op = NULL;
842031ce:	02 00       	r0 = Null + Null;

    patch_fn_shared(aec_reference);

    /* sidetone can be mixed to 1 or 2 speakers only */
    if(nr_spkrs > 2)
842031d0:	b8 24       	Null = r5 - 2;
842031d2:	09 f0 87 e0 	if LS jump (m) Lc_create_aec_ref_sidetone_op_3;

842031d6 <Lc_create_aec_ref_sidetone_op_2>:
    {
        return op;
842031d6:	2c 6e       	jump (m) Lc_create_aec_ref_sidetone_op_6;

842031d8 <Lc_create_aec_ref_sidetone_op_3>:
    }

    // cbop param struct size (header plus cbop-specific parameters)
    op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_aec_ref_sidetone_op, 1, nr_spkrs));
842031d8:	c3 20       	r1 = Null + 3;
842031da:	7a 20       	r0 = r5 + 1;
842031dc:	52 54       	r0 = r0 LSHIFT 2;
842031de:	02 f0 58 44 	r0 = r0 + 88;
842031e2:	ff fd 1b f0 	call (m) 0x68a6;
842031e6:	25 e6 
842031e8:	10 09       	r6 = r0 + Null;
    if(op)
842031ea:	21 60       	if EQ jump (m) Lc_create_aec_ref_sidetone_op_5;

842031ec <Lc_create_aec_ref_sidetone_op_4>:
    {
        cbops_aec_ref_sidetone_op *params;

        /* Setup Operator func table */
        op->function_vector    = cbops_aec_ref_sidetone_table;
842031ec:	07 f0 01 f0 	rMAC = Null + 7340392;
842031f0:	68 41 
842031f2:	81 f0 02 8e 	M[r6 + 8] = rMAC;
        /* Setup cbop param struct header info */
        params = (cbops_aec_ref_sidetone_op*)cbops_populate_param_hdr(op,
                                                                      1,
                                                                      0,
                                                                      sidetone_idx,
                                                                      NULL);
842031f6:	00 f0 30 cf 	push Null;
842031fa:	fd d9       	r3 = M[FP + -4];
842031fc:	43 20       	r1 = Null + 1;
842031fe:	04 00       	r2 = Null + Null;
84203200:	ff fd b7 f0 	call (m) 0x1a00e;
84203204:	2f e0 
84203206:	7f 4c       	SP = SP + -4;

        /* Setup cbop-specific parameters */
        params->spkr_threshold  = spkr_threshold;
84203208:	f1 d9       	rMAC = M[FP + -8];
8420320a:	51 9e       	M[r0 + 36] = rMAC;
        params->safety_threshold_low = safety_threshold;
8420320c:	96 8f       	M[r0 + 24] = r4;
        params->safety_threshold_high = safety_threshold*2;
8420320e:	33 54       	r1 = r4 LSHIFT 1;
84203210:	d3 8f       	M[r0 + 28] = r1;
        params->safety_set_threshold = (params->safety_threshold_low + params->safety_threshold_high)/2;
84203212:	f3 00       	r1 = r4 + r1;
84203214:	1b 50       	r1 = r1 LSHIFT -1;
84203216:	13 9e       	M[r0 + 32] = r1;
        params->mic_buf = mic_buf;
84203218:	2b f0 01 8e 	M[r0 + 4] = r9;
        params->spkr_bufs = spkr_bufs;
8420321c:	29 f0 00 ee 	M[r0 + Null] = r7;
        params->mic_idx = mic_idx;
84203220:	2a f0 05 8e 	M[r0 + 20] = r8;
        params->nr_spkrs = nr_spkrs;
84203224:	97 8e       	M[r0 + 8] = r5;

        /* initialise the operator */
        aec_ref_sidetone_initialise(op);
84203226:	42 08       	r0 = r6 + Null;
84203228:	04 f0 2d e5 	call (m) $_aec_ref_sidetone_initialise;

8420322c <Lc_create_aec_ref_sidetone_op_5>:
    }

    return(op);
8420322c:	42 08       	r0 = r6 + Null;

8420322e <Lc_create_aec_ref_sidetone_op_6>:
}
8420322e:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84203230:	d8 4c       	rts;

84203232 <$_AEC_REFERENCE_GetDefaults>:
84203232:	20 f0 43 24 	Null = r0 - 67;
   0x00000001u,			// ST_PEQ_SCALE2
   0x00000001u			// ST_PEQ_SCALE3
};

unsigned *AEC_REFERENCE_GetDefaults(unsigned capid){
	switch(capid){
84203236:	05 60       	if EQ jump (m) Lc_AEC_REFERENCE_GetDefaults_3;

84203238 <Lc_AEC_REFERENCE_GetDefaults_2>:
84203238:	01 f0 20 f0 	Null = r0 - 16391;
8420323c:	07 24 
8420323e:	05 62       	if NE jump (m) Lc_AEC_REFERENCE_GetDefaults_4;

84203240 <Lc_AEC_REFERENCE_GetDefaults_3>:
		case 0x0043: return defaults_aec_referenceAECREF;
84203240:	f8 ff 02 f0 	r0 = Null + -8388604;
84203244:	04 40 
84203246:	02 6e       	jump (m) Lc_AEC_REFERENCE_GetDefaults_5;

84203248 <Lc_AEC_REFERENCE_GetDefaults_4>:
		case 0x4007: return defaults_aec_referenceAECREF;
	}
	return((unsigned *)0);
84203248:	02 00       	r0 = Null + Null;

8420324a <Lc_AEC_REFERENCE_GetDefaults_5>:
8420324a:	d8 4c       	rts;

8420324c <$_create_multichan_sidetone_mix_op_base>:
8420324c:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
                                                unsigned *input_idxs,
                                                unsigned *output_idxs,
                                                unsigned nr_st_channels,
                                                unsigned *st_in_idxs,
                                                unsigned threshold)
{
8420324e:	17 00       	r5 = r0 + Null;
84203250:	1a 09       	r8 = r1 + Null;
84203252:	20 09       	r6 = r2 + Null;
84203254:	2e 00       	r4 = r3 + Null;
    /* Expect at least one sidetone channel*/
    if(nr_st_channels == 0 || /* At least one sidetone input channel */
       nr_channels == 0    || /* At least one main channel */
       nr_st_channels > CBOPS_SIDETONE_MIX_MAX_ST_CHANNELS)
84203256:	06 60       	if EQ jump (m) Lc_create_multichan_sidetone_mix_op_base_4;

84203258 <Lc_create_multichan_sidetone_mix_op_base_2>:
84203258:	38 04       	Null = r5 - Null;
8420325a:	04 60       	if EQ jump (m) Lc_create_multichan_sidetone_mix_op_base_4;

8420325c <Lc_create_multichan_sidetone_mix_op_base_3>:
8420325c:	30 26       	Null = r4 - 8;
8420325e:	09 f0 89 e0 	if LS jump (m) Lc_create_multichan_sidetone_mix_op_base_5;

84203262 <Lc_create_multichan_sidetone_mix_op_base_4>:
    {
        /* something is wrong with the caller */
        return NULL;
84203262:	02 00       	r0 = Null + Null;
84203264:	32 6e       	jump (m) Lc_create_multichan_sidetone_mix_op_base_10;

84203266 <Lc_create_multichan_sidetone_mix_op_base_5>:
    }

    cbops_op *op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_multichan_sidetone_mix_op, nr_channels, nr_channels)
                                        + (nr_channels + nr_st_channels - 1)*sizeof(unsigned));
84203266:	c3 20       	r1 = Null + 3;
84203268:	f9 40       	rMAC = r5 * 3 (int);
8420326a:	71 00       	rMAC = r4 + rMAC;
8420326c:	4a 24       	r0 = rMAC - 1;
8420326e:	52 54       	r0 = r0 LSHIFT 2;
84203270:	12 38       	r0 = r0 + 48;
84203272:	ff fd 1b f0 	call (m) 0x68a6;
84203276:	35 e1 
84203278:	11 09       	r7 = r0 + Null;
    if(op != NULL)
8420327a:	26 60       	if EQ jump (m) Lc__loop0;

8420327c <Lc_create_multichan_sidetone_mix_op_base_6>:
    {
        cbops_multichan_sidetone_mix_op  *params;

        op->function_vector    = cbops_multichan_sidetone_mix_table;
8420327c:	07 f0 01 f0 	rMAC = Null + 7340404;
84203280:	74 41 
84203282:	91 f0 02 8e 	M[r7 + 8] = rMAC;

        /* Setup cbops param struct header info */
        params = (cbops_multichan_sidetone_mix_op*)cbops_populate_param_hdr(op, nr_channels, nr_channels, input_idxs, output_idxs);
84203286:	10 1c       	pushm <r6>;
84203288:	55 08       	r3 = r8 + Null;
8420328a:	3c 00       	r2 = r5 + Null;
8420328c:	3b 00       	r1 = r5 + Null;
8420328e:	ff fd b6 f0 	call (m) 0x1a00e;
84203292:	21 ec 
84203294:	7f 4c       	SP = SP + -4;
84203296:	10 09       	r6 = r0 + Null;

        /* Only config param which is threshold which is for all of the
         * sidetone channels
         */
        params->max_samples = threshold;
84203298:	f1 d9       	rMAC = M[FP + -8];
8420329a:	81 f0 00 ee 	M[r6 + Null] = rMAC;

        /* number of main channels */
        params->nr_channels = nr_channels;
8420329e:	87 f0 03 8e 	M[r6 + 12] = r5;

        /* number of sidetone channels */
        params->nr_st_channels = nr_st_channels;
842032a2:	86 f0 04 8e 	M[r6 + 16] = r4;

        /* write cbops buffer indexes for sidetone buffers */
        unsigned *params_st_in_idxs = &params->st_idxs[0];
842032a6:	82 f0 14 20 	r0 = r6 + 20;
        memcpy(params_st_in_idxs, st_in_idxs, sizeof(unsigned)*nr_st_channels);
842032aa:	74 54       	r2 = r4 LSHIFT 2;
842032ac:	fb d9       	r1 = M[FP + -4];
842032ae:	ff fd b7 f0 	call (m) 0x1a192;
842032b2:	25 e7 

        /* initialise sidetone mixing mapping */
        unsigned i;
        unsigned *params_st_map_idxs = &params->st_idxs[nr_st_channels];
842032b4:	72 54       	r0 = r4 LSHIFT 2;
842032b6:	10 0d       	r6 = r0 + r6;
842032b8:	82 f0 14 20 	r0 = r6 + 20;
        for(i = 0; i < nr_channels; ++i)
842032bc:	41 24       	rMAC = Null - 1;
842032be:	3c 09       	r10 = r5 + Null;
842032c0:	03 4c       	do (m) Lc__loop0;

842032c2 <Lc_create_multichan_sidetone_mix_op_base_7>:
        {
            /* initialise to no sidetone mixing, this needs to be
             * configured later to do any sidetone mixing
             */
            params_st_map_idxs[i] = CBOPS_BUFFER_NOT_SUPPLIED;
842032c2:	11 ee       	M[r0 + Null] = rMAC;
842032c4:	12 21       	r0 = r0 + 4;

842032c6 <Lc__loop0>:
        memcpy(params_st_in_idxs, st_in_idxs, sizeof(unsigned)*nr_st_channels);

        /* initialise sidetone mixing mapping */
        unsigned i;
        unsigned *params_st_map_idxs = &params->st_idxs[nr_st_channels];
        for(i = 0; i < nr_channels; ++i)
842032c6:	4a 08       	r0 = r7 + Null;

842032c8 <Lc_create_multichan_sidetone_mix_op_base_10>:
            params_st_map_idxs[i] = CBOPS_BUFFER_NOT_SUPPLIED;
        }
    }

    return(op);
}
842032c8:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842032ca:	d8 4c       	rts;

842032cc <$_cbops_sidetone_mix_map_channel>:
 * \param op cbops multichannel sidetone mix operator (input)
 * \param input_channel main channel number (0 to (nr_channels-1))
 * \param use_st_channel use this sidetone channel (0 to (nr_st_channels-1))
 */
void cbops_sidetone_mix_map_channel(cbops_op *op, unsigned input_channel, unsigned use_st_channel)
{
842032cc:	c8 1c       	pushm <FP(=SP), rLink>;
    if(NULL != op)
842032ce:	10 04       	Null = r0 - Null;
842032d0:	20 60       	if EQ jump (m) Lc_cbops_sidetone_mix_map_channel_7;

842032d2 <Lc_cbops_sidetone_mix_map_channel_2>:
    {
        cbops_multichan_sidetone_mix_op  *params = CBOPS_PARAM_PTR(op, cbops_multichan_sidetone_mix_op);
842032d2:	d1 88       	rMAC = M[r0 + 12];
        PL_ASSERT(use_st_channel < params->nr_st_channels);
842032d4:	0d 89       	r3 = M[rMAC + 16];
842032d6:	60 05       	Null = r2 - r3;
842032d8:	09 64       	if NC jump (m) Lc_cbops_sidetone_mix_map_channel_4;

842032da <Lc_cbops_sidetone_mix_map_channel_3>:
842032da:	03 f0 9a 40 	r1 = Null + 154;
842032de:	02 f0 13 60 	r0 = Null + 4115;
842032e2:	ff fd 9e f0 	call (m) 0x16ff0;
842032e6:	2f e8 
842032e8:	14 6e       	jump (m) Lc_cbops_sidetone_mix_map_channel_7;

842032ea <Lc_cbops_sidetone_mix_map_channel_4>:
        PL_ASSERT(input_channel < params->nr_channels);
842032ea:	ca 88       	r0 = M[rMAC + 12];
842032ec:	98 04       	Null = r1 - r0;
842032ee:	09 64       	if NC jump (m) Lc_cbops_sidetone_mix_map_channel_6;

842032f0 <Lc_cbops_sidetone_mix_map_channel_5>:
842032f0:	03 f0 9b 40 	r1 = Null + 155;
842032f4:	02 f0 13 60 	r0 = Null + 4115;
842032f8:	ff fd 9e f0 	call (m) 0x16ff0;
842032fc:	39 e7 
842032fe:	09 6e       	jump (m) Lc_cbops_sidetone_mix_map_channel_7;

84203300 <Lc_cbops_sidetone_mix_map_channel_6>:

        /* get sidetone indexes */
        unsigned *st_in_idxs = &params->st_idxs[0];
84203300:	0a 29       	r0 = rMAC + 20;

        /* get mapping table indexes */
        unsigned *st_map_idxs = &params->st_idxs[params->nr_st_channels];
84203302:	6d 54       	r3 = r3 LSHIFT 2;
84203304:	69 00       	rMAC = r3 + rMAC;
84203306:	09 29       	rMAC = rMAC + 20;

        /* configure this channel to use sidetone mixing from use_st_channel */
        st_map_idxs[input_channel] = st_in_idxs[use_st_channel];
84203308:	64 54       	r2 = r2 LSHIFT 2;
8420330a:	5b 54       	r1 = r1 LSHIFT 2;
8420330c:	12 e9       	r0 = M[r0 + r2];
8420330e:	ca ee       	M[rMAC + r1] = r0;

84203310 <Lc_cbops_sidetone_mix_map_channel_7>:
    }
}
84203310:	c8 48       	popm <FP, rLink>;
84203312:	d8 4c       	rts;

84203314 <$_cbops_sidetone_mix_map_one_to_all>:
 * \brief configures a sidetone channel to be mixed into all main channels
 * \param op cbops multichannel sidetone mix operator (input)
 * \param use_st_channel use this sidetone channel to mix into all channels
 */
void cbops_sidetone_mix_map_one_to_all(cbops_op *op, unsigned use_st_channel)
{
84203314:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84203316:	18 09       	r6 = r1 + Null;
84203318:	16 00       	r4 = r0 + Null;
    if(NULL != op)
8420331a:	1a 60       	if EQ jump (m) Lc_cbops_sidetone_mix_map_one_to_all_7;

8420331c <Lc_cbops_sidetone_mix_map_one_to_all_2>:
    {
        unsigned i;
        cbops_multichan_sidetone_mix_op  *params = CBOPS_PARAM_PTR(op, cbops_multichan_sidetone_mix_op);
8420331c:	f7 88       	r5 = M[r4 + 12];
        PL_ASSERT(use_st_channel < params->nr_st_channels);
8420331e:	39 89       	rMAC = M[r5 + 16];
84203320:	1f f8 00 c2 	Null = r6 - rMAC;
84203324:	09 64       	if NC jump (m) Lc_cbops_sidetone_mix_map_one_to_all_4;

84203326 <Lc_cbops_sidetone_mix_map_one_to_all_3>:
84203326:	03 f0 b3 40 	r1 = Null + 179;
8420332a:	02 f0 13 60 	r0 = Null + 4115;
8420332e:	ff fd 9e f0 	call (m) 0x16ff0;
84203332:	23 e6 
84203334:	0d 6e       	jump (m) Lc_cbops_sidetone_mix_map_one_to_all_7;

84203336 <Lc_cbops_sidetone_mix_map_one_to_all_4>:
        for(i = 0; i < params->nr_channels; ++i)
84203336:	01 09       	r7 = Null + Null;

84203338 <Lc_cbops_sidetone_mix_map_one_to_all_5>:
84203338:	f9 88       	rMAC = M[r5 + 12];
8420333a:	1f f9 00 c2 	Null = r7 - rMAC;
8420333e:	02 f0 91 e0 	if C jump (m) Lc_cbops_sidetone_mix_map_one_to_all_7;

84203342 <Lc_cbops_sidetone_mix_map_one_to_all_6>:
        {
            cbops_sidetone_mix_map_channel(op, i, use_st_channel);
84203342:	44 08       	r2 = r6 + Null;
84203344:	4b 08       	r1 = r7 + Null;
84203346:	32 00       	r0 = r4 + Null;
84203348:	c2 4f       	call (m) $_cbops_sidetone_mix_map_channel;
    if(NULL != op)
    {
        unsigned i;
        cbops_multichan_sidetone_mix_op  *params = CBOPS_PARAM_PTR(op, cbops_multichan_sidetone_mix_op);
        PL_ASSERT(use_st_channel < params->nr_st_channels);
        for(i = 0; i < params->nr_channels; ++i)
8420334a:	09 75       	r7 = r7 + 1;
8420334c:	f6 6f       	jump (m) Lc_cbops_sidetone_mix_map_one_to_all_5;

8420334e <Lc_cbops_sidetone_mix_map_one_to_all_7>:
        {
            cbops_sidetone_mix_map_channel(op, i, use_st_channel);
        }
    }
}
8420334e:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84203350:	d8 4c       	rts;

84203352 <$_create_multichan_sidetone_mix_op>:
                                           unsigned first_output_idx,
                                           unsigned nr_st_channels,
                                           unsigned first_st_in_idx,
                                           unsigned threshold
                                           )
{
84203352:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84203354:	13 09       	r9 = r0 + Null;
84203356:	1a 09       	r8 = r1 + Null;
84203358:	20 09       	r6 = r2 + Null;
8420335a:	2f 00       	r5 = r3 + Null;
8420335c:	e9 f3 ff b9 	r7 = M[FP + -4];
    /* We have first index only, to create we need an array of indexes,
     * create buffer indexes using maximum index.
     */
    unsigned max_idx = pl_max(first_input_idx, first_output_idx)+nr_channels;
84203360:	52 08       	r0 = r8 + Null;
84203362:	43 08       	r1 = r6 + Null;
84203364:	6f f3 42 ce 	r0 = MAX r1;
84203368:	5a 0c       	r0 = r9 + r0;
    max_idx = pl_max(max_idx, nr_st_channels + first_st_in_idx);
8420336a:	7f f9 03 c0 	r1 = r7 + r5;
8420336e:	6f f3 42 ce 	r0 = MAX r1;
    unsigned *idxs = create_default_indexes(max_idx);
84203372:	ff fd b6 f0 	call (m) 0x19fe6;
84203376:	35 e3 
84203378:	16 00       	r4 = r0 + Null;
    if(NULL == idxs)
8420337a:	03 62       	if NE jump (m) Lc_create_multichan_sidetone_mix_op_3;

8420337c <Lc_create_multichan_sidetone_mix_op_2>:
    {
        return NULL;
8420337c:	02 00       	r0 = Null + Null;
8420337e:	1a 6e       	jump (m) Lc_create_multichan_sidetone_mix_op_4;

84203380 <Lc_create_multichan_sidetone_mix_op_3>:
    cbops_op* op = create_multichan_sidetone_mix_op_base(nr_channels,
                                                         &idxs[first_input_idx],
                                                         &idxs[first_output_idx],
                                                         nr_st_channels,
                                                         &idxs[first_st_in_idx],
                                                         threshold);
84203380:	f1 d9       	rMAC = M[FP + -8];
84203382:	09 1c       	pushm <rMAC>;
84203384:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
84203388:	31 00       	rMAC = r4 + Null;
8420338a:	51 00       	rMAC = r0 + rMAC;
8420338c:	09 1c       	pushm <rMAC>;
8420338e:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
84203392:	34 00       	r2 = r4 + Null;
84203394:	33 00       	r1 = r4 + Null;
84203396:	3d 00       	r3 = r5 + Null;
84203398:	14 01       	r2 = r0 + r2;
8420339a:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
8420339e:	d3 00       	r1 = r0 + r1;
842033a0:	5a 08       	r0 = r9 + Null;
842033a2:	55 4f       	call (m) $_create_multichan_sidetone_mix_op_base;
842033a4:	7e 4c       	SP = SP + -8;
842033a6:	17 00       	r5 = r0 + Null;
    pfree(idxs);
842033a8:	32 00       	r0 = r4 + Null;
842033aa:	ff fd 1a f0 	call (m) 0x68d8;
842033ae:	2f e9 
    return op;
842033b0:	3a 00       	r0 = r5 + Null;

842033b2 <Lc_create_multichan_sidetone_mix_op_4>:
}
842033b2:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842033b4:	d8 4c       	rts;

842033b6 <$_cbops_mute_enable>:
842033b6:	d1 88       	rMAC = M[r0 + 12];
 *   else a ramping will apply during first processed block of samples.
 */
void cbops_mute_enable(cbops_op *op, bool enable, bool no_ramp)
{
    cbops_mute *params = CBOPS_PARAM_PTR(op, cbops_mute);
    params->mute_enable = enable;
842033b8:	0b ee       	M[rMAC + Null] = r1;
    if(no_ramp)
842033ba:	20 04       	Null = r2 - Null;
842033bc:	02 60       	if EQ jump (m) Lc_cbops_mute_enable_3;

842033be <Lc_cbops_mute_enable_2>:
    {
        /* no ramping, apply mute config immediately */
        params->mute_state = enable;
842033be:	4b 8e       	M[rMAC + 4] = r1;

842033c0 <Lc_cbops_mute_enable_3>:
842033c0:	d8 4c       	rts;

842033c2 <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_aec_reference_cap_data;
842033c2:	07 f0 02 f0 	r0 = Null + 7340032;
842033c6:	00 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
842033c8:	20 f0 f8 42 	Null = Null + 17144;

842033cc <$cbops.aec_ref_spkr_op.amount_to_use>:
// Called before amount_to_use of graph
$cbops.aec_ref_spkr_op.amount_to_use:

    LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_spkr_op.amount_to_use.PATCH_ID_0, r7)

   push rlink;
842033cc:	00 f0 3d cf 	push rLink;

   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
842033d0:	a9 f0 00 88 	r7 = M[r8 + 0];
   // Get amount of input
   r0 = M[r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD];
842033d4:	a2 f0 03 88 	r0 = M[r8 + 12];
   call $cbops.get_amount_ptr;
842033d8:	ff fd 91 f3 	call 0x7573c;
842033dc:	24 eb 
   r5 = M[r0];
842033de:	17 e8       	r5 = M[r0 + Null];
   // Save data at input and make input large, will re-adjust for insertion
   M[r7 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.AMOUNT_DATA_FIELD] = r5;
842033e0:	97 f0 03 8e 	M[r7 + 12] = r5;
   r5 = 0x7FFF;
842033e4:	37 f0 ff 7b 	r5 = Null + 32767;
   M[r0] = r5;
842033e8:	87 ee       	M[Null + r0] = r5;

   // Get first output index
   r9 = M[r8 + $cbops.param_hdr.NR_INPUT_CHANNELS_FIELD];
842033ea:	ab f0 01 88 	r9 = M[r8 + 4];
   Words2Addr(r9);
842033ee:	01 fb 1b c9 	r9 = r9 ASHIFT 2;
   r9 = r9 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD;
842033f2:	63 75       	r9 = r9 + 12;
   r0 = M[r8 + r9];
842033f4:	a2 f0 0b e8 	r0 = M[r8 + r9];
   call $cbops.get_cbuffer;
842033f8:	ff fd 91 f3 	call 0x7572c;
842033fc:	34 e9 
   NULL = r0;
842033fe:	10 00       	Null = r0 + Null;
   if Z jump aec_ref_spkr_op.amount_to_use_done;
84203400:	16 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.amount_to_use_done;

   // First Port (r0);
   r5 = NULL;
84203402:	07 00       	r5 = Null + Null;
   r6 = M[r7 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.MAX_ADVANCE_FIELD];
84203404:	98 f0 01 88 	r6 = M[r7 + 4];
   r1 = M[r7 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.MAX_JITTER_FIELD];
84203408:	93 f0 06 88 	r1 = M[r7 + 24];
   r6 = r6 + r1;
8420340c:	18 0d       	r6 = r1 + r6;
   call calc_dac_amount_of_data;
8420340e:	d4 4e       	call (m) $M.cbops.aec_ref_spkr_op.calc_dac_amount_of_data;

   // r2 is data in port (negative if wrap), r10 is max advance, r0 is adjustment
   // Limit amount of data after transfer to two times maximum advance
   NULL = r2 + r0;
84203410:	a0 00       	Null = r2 + r0;
   if POS r1 = r6 - r2;
84203412:	45 f8 03 c2 	if POS r1 = r6 - r2;
   if NEG r1 = Null;
84203416:	04 f0 03 c0 	if NEG r1 = Null + Null;

   // Setup the limited transfer at output
   r0 = M[r8 + r9];
8420341a:	a2 f0 0b e8 	r0 = M[r8 + r9];
   call $cbops.get_amount_ptr;
8420341e:	ff fd 91 f3 	call 0x7573c;
84203422:	3e e8 
   M[r0]=r1;
84203424:	83 ee       	M[Null + r0] = r1;
   if Z call $cbops.force_processing;
84203426:	f0 fd 91 f3 	if EQ call 0x7574c;
8420342a:	26 e9 

8420342c <$M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.amount_to_use_done>:

aec_ref_spkr_op.amount_to_use_done:
   pop rlink;
8420342c:	00 f4 3d cf 	pop rLink;
   rts;
84203430:	d8 4c       	rts;

84203432 <$cbops.aec_ref_spkr_op.pre_main>:

// Called after amount to use of graph but before main processing of graph
$cbops.aec_ref_spkr_op.pre_main:
   push rLink;
84203432:	00 f0 3d cf 	push rLink;
    *                       |
    *                       |
    *                Possible Silence Insert
    *-----------------------------------------------------------------------*/
   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
84203436:	a9 f0 00 88 	r7 = M[r8 + 0];

   // Get intermediate buffer indexes
   I7 = r7 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.INTERM_IDXS_FIELD;
8420343a:	97 f8 1c 20 	I7 = r7 + 28;

   // Get input buffer indexes
   I2 = r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD;
8420343e:	a2 f8 0c 20 	I2 = r8 + 12;

   // Get number of input channels
   r0 = M[r8 + $cbops.param_hdr.NR_INPUT_CHANNELS_FIELD];
84203442:	a2 f0 01 88 	r0 = M[r8 + 4];
   M2 = r0;
84203446:	12 0b       	M2 = r0 + Null;

   // r5 will hold the amount of silence needed
   // to insert this run
   r5 = 0;
84203448:	07 00       	r5 = Null + Null;

   // transfer amount from input
   r0 = M[I2, 0];
8420344a:	28 f0 30 c0 	Null = Null + Null, r0 = M[I2,0];
   call $cbops.get_amount_ptr;
8420344e:	ff fd 91 f3 	call 0x7573c;
84203452:	2e e7 
   r10 = r0;
84203454:	14 09       	r10 = r0 + Null;

   // transfer amount to interm stage
   r0 = M[I7, 0];
84203456:	2c f0 30 d0 	Null = Null + Null, r0 = M[I7,0];
   call $cbops.get_amount_ptr;
8420345a:	ff fd 91 f3 	call 0x7573c;
8420345e:	22 e7 
   r6 = M[r0];
84203460:	28 f0 00 e8 	r6 = M[r0 + Null];

   // optimisation, early exit if nothing can transfer
   // to interm stage.
   if Z M[r10] = r6;
84203464:	00 f8 8c c1 	if EQ M[r10] = r6 + Null;
   if Z jump aec_ref_spkr_op.pre_main_done;
84203468:	4f 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_done;

   // Get amount of data and threshold. Determine if need to insert.
   r3 = M[r7 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.AMOUNT_DATA_FIELD];
8420346a:	95 f0 03 88 	r3 = M[r7 + 12];
   NULL = r6 - r3;
8420346e:	5f f8 00 c2 	Null = r6 - r3;
   if LE jump aec_ref_spkr_op.pre_main_transfer;
84203472:	0f 6c       	if LE jump (m) $M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_transfer;

   // Insufficient data, limit transfer to threshold.
   r2 = M[r7 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.IN_THRESHOLD_FIELD];
84203474:	94 f0 00 88 	r2 = M[r7 + 0];
   r6 = MIN r2;
84203478:	5f f4 48 ce 	r6 = MIN r2;
   // r3: amount of data in the input buffer
   // r6: amount of data that "must" be pushed into next stage
   //  if input has enough data then transfer needed samples from
   //  input buffer otherwise silence will be inserted to make sure
   //  exactly r6 samples will be pushed into next stage.
   r5 = r6 - r3;
8420347c:	5f f8 07 c2 	r5 = r6 - r3;
   if LE r5 = 0;
84203480:	0d f0 07 c0 	if LE r5 = Null + Null;
   if Z jump aec_ref_spkr_op.pre_main_transfer;
84203484:	06 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_transfer;
   // Insert (r5) zeroes with this transfer, update counter
   r1 = M[r7 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.NUM_INSERTS_FIELD];
84203486:	93 f0 05 88 	r1 = M[r7 + 20];
   r1 = r1 + r5;
8420348a:	fb 00       	r1 = r5 + r1;
   M[r7 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.NUM_INSERTS_FIELD]=r1;
8420348c:	93 f0 05 8e 	M[r7 + 20] = r1;

84203490 <$M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_transfer>:
   //  r7: data pointer of the operator
   //  r0: transfer amount ptr for intermediate buffer
   //  r10: transfer amount ptr for input buffer

   // update transfer amount for interm bufs
   M[r0] = r6;
84203490:	08 f0 02 ee 	M[Null + r0] = r6;

   // amount that should be transferred from input
   r6 = r6 - r5;
84203494:	00 f7 38 c2 	r6 = r6 - r5;

   // update transfer amount for input bufs
   M[r10] = r6;
84203498:	08 f0 0c ee 	M[Null + r10] = r6;

8420349c <$M.cbops.aec_ref_spkr_op.transfer_and_silence_insert_channel>:

   // r5: amount of silence to insert
   // r6: amount of transfer from input buffer
   transfer_and_silence_insert_channel:
      // Setup Input Buffer
      r0 = M[I2,0];
8420349c:	28 f0 30 c0 	Null = Null + Null, r0 = M[I2,0];
      call $cbops.get_buffer_address_and_length;
842034a0:	ff fd 91 f3 	call 0x756c0;
842034a4:	20 e1 
      I0 = r0;
842034a6:	10 0a       	I0 = r0 + Null;
      if Z jump next_transfer_and_silence_insert_channel;
842034a8:	1d 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.next_transfer_and_silence_insert_channel;
      L0 = r1;
842034aa:	1c 0b       	L0 = r1 + Null;
      push r2;
842034ac:	00 f0 34 cf 	push r2;
      pop B0;
842034b0:	00 f6 3a cf 	pop B0;

      // Setup Interm Buffer
      r0 = M[I7,0];
842034b4:	2c f0 30 d0 	Null = Null + Null, r0 = M[I7,0];
      call $cbops.get_buffer_address_and_length;
842034b8:	ff fd 91 f3 	call 0x756c0;
842034bc:	28 e0 
      I4 = r0;
842034be:	14 0a       	I4 = r0 + Null;
      if Z jump next_transfer_and_silence_insert_channel;
842034c0:	11 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.next_transfer_and_silence_insert_channel;
      L4 = r1;
842034c2:	1e 0b       	L4 = r1 + Null;
      push r2;
842034c4:	00 f0 34 cf 	push r2;
      pop B4;
842034c8:	00 f6 3c cf 	pop B4;

      // first silence insertion if needed
      r10 = r5;
842034cc:	3c 09       	r10 = r5 + Null;
      r0 = 0;
842034ce:	02 00       	r0 = Null + Null;
      do silence_insert_loop;
842034d0:	03 4c       	do (m) $M.cbops.aec_ref_spkr_op.silence_insert_loop;
         M[I4, MK1] = r0;
842034d2:	a1 f0 30 d0 	Null = Null + Null, M[I4,4] = r0;

842034d6 <$M.cbops.aec_ref_spkr_op.silence_insert_loop>:
      silence_insert_loop:

      // then transfer real audio from input
      r10 = r6;
842034d6:	44 09       	r10 = r6 + Null;
      do transfer_loop;
842034d8:	05 4c       	do (m) $M.cbops.aec_ref_spkr_op.next_transfer_and_silence_insert_channel;
         r0 = M[I0, MK1];
842034da:	21 f0 30 c0 	Null = Null + Null, r0 = M[I0,4];
         M[I4, MK1] = r0;
842034de:	a1 f0 30 d0 	Null = Null + Null, M[I4,4] = r0;

842034e2 <$M.cbops.aec_ref_spkr_op.next_transfer_and_silence_insert_channel>:
      transfer_loop:

      next_transfer_and_silence_insert_channel:
      r0 = M[I2, MK1], r1 = M[I7, MK1];
842034e2:	3d f9 32 d0 	Null = Null + Null, r0 = M[I2,4], r1 = M[I7,4];
      M2 = M2 - 1;
842034e6:	aa fc 01 24 	M2 = M2 - 1;
   if GT jump transfer_and_silence_insert_channel;
842034ea:	d9 6b       	if GT jump (m) $M.cbops.aec_ref_spkr_op.transfer_and_silence_insert_channel;

   // Reset Buffering control
   L0 = 0;
842034ec:	04 0b       	L0 = Null + Null;
   L4 = 0;
842034ee:	06 0b       	L4 = Null + Null;
   push NULL;
842034f0:	00 f0 30 cf 	push Null;
   pop B0;
842034f4:	00 f6 3a cf 	pop B0;
   push NULL;
842034f8:	00 f0 30 cf 	push Null;
   pop B4;
842034fc:	00 f6 3c cf 	pop B4;

   /* Something written at the interim stage
    * force going ahead
    */
   call $cbops.force_processing;
84203500:	ff fd 91 f3 	call 0x7574c;
84203504:	2c e2 

84203506 <$M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_done>:

aec_ref_spkr_op.pre_main_done:
   pop rlink;
84203506:	00 f4 3d cf 	pop rLink;
   rts;
8420350a:	d8 4c       	rts;

8420350c <$_get_aec_ref_cbops_inserts_total>:

// unsigned get_aec_ref_cbops_inserts_total(cbops_op *op);
$_get_aec_ref_cbops_inserts_total:
    r0 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
8420350c:	d2 88       	r0 = M[r0 + 12];
    r1 = M[r0 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.WRAP_COUNT_FIELD];
8420350e:	13 89       	r1 = M[r0 + 16];
    r0 = M[r0 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.NUM_INSERTS_FIELD];
84203510:	52 89       	r0 = M[r0 + 20];
    r0 = r0 + r1;
84203512:	9a 00       	r0 = r1 + r0;
    rts;
84203514:	d8 4c       	rts;

84203516 <$_get_aec_ref_cbops_insert_op_insert_total>:

// unsigned get_aec_ref_cbops_insert_op_insert_total(cbops_op *op);
$_get_aec_ref_cbops_insert_op_insert_total:
    r0 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
84203516:	d2 88       	r0 = M[r0 + 12];
    r0 = M[r0 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.NUM_INSERTS_FIELD];
84203518:	52 89       	r0 = M[r0 + 20];
    rts;
8420351a:	d8 4c       	rts;

8420351c <$_get_aec_ref_cbops_wrap_op_insert_total>:

// unsigned get_aec_ref_cbops_wrap_op_insert_total(cbops_op *op);
$_get_aec_ref_cbops_wrap_op_insert_total:
    r0 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
8420351c:	d2 88       	r0 = M[r0 + 12];
    r0 = M[r0 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.WRAP_COUNT_FIELD];
8420351e:	12 89       	r0 = M[r0 + 16];
    rts;
84203520:	d8 4c       	rts;

84203522 <$cbops.aec_ref_spkr_op.post_main>:

// Called after main processing of graph before buffer update
$cbops.aec_ref_spkr_op.post_main:

   // Check for Buffer Wrapping
    push rLink;
84203522:	00 f0 3d cf 	push rLink;

    LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_spkr_op.post_main.PATCH_ID_0, r9)

    // Get first output index
    r9 = M[r8 + $cbops.param_hdr.NR_INPUT_CHANNELS_FIELD];
84203526:	ab f0 01 88 	r9 = M[r8 + 4];
    Words2Addr(r9);
8420352a:	01 fb 1b c9 	r9 = r9 ASHIFT 2;
    r9 = r9 + r8;
8420352e:	53 0d       	r9 = r8 + r9;
    I4 = r9 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD;
84203530:	b4 f8 0c 20 	I4 = r9 + 12;

    // Get first buffer entry
    r0 = M[I4,0];
84203534:	20 f0 30 d0 	Null = Null + Null, r0 = M[I4,0];
    r3 = r0 * $CBOP_BUFTAB_ENTRY_SIZE_IN_ADDR (int);
84203538:	15 47       	r3 = r0 * 28 (int);
    r3 = r3 + r4;
8420353a:	75 01       	r3 = r4 + r3;

    // Get Cbuffer Ptr
    r0 = M[r3 + $cbops_c.cbops_buffer_struct.BUFFER_FIELD];
8420353c:	6a 88       	r0 = M[r3 + 4];
    if Z jump $pop_rLink_and_rts;
8420353e:	7c ff f0 f6 	if EQ jump (m) 0x3b020;
84203542:	e3 e5 

#if !defined(CHIP_BASE_BC7)
    // Get transfer amount (r5)
    r1 = M[r3 + $cbops_c.cbops_buffer_struct.TRANSFER_PTR_FIELD];
84203544:	6b 89       	r1 = M[r3 + 20];
    r5 = M[r1];
84203546:	1f e8       	r5 = M[r1 + Null];
#else
    r5 = NULL;
#endif

    // Compute amount of data in source
    r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
84203548:	a9 f0 00 88 	r7 = M[r8 + 0];
    r6 = M[r7 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.MAX_JITTER_FIELD];
8420354c:	98 f0 06 88 	r6 = M[r7 + 24];
    call calc_dac_amount_of_data;
84203550:	33 4e       	call (m) $M.cbops.aec_ref_spkr_op.calc_dac_amount_of_data;

    r6 = M[r7 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.MAX_ADVANCE_FIELD];
84203552:	98 f0 01 88 	r6 = M[r7 + 4];

    // r2 is number of samples in port, negative if overflow
    r10 = r6 - r2;
84203556:	4f f8 0c c2 	r10 = r6 - r2;
    if LE jump $pop_rLink_and_rts;
8420355a:	7c ff fd f6 	if LE jump (m) 0x3b020;
8420355e:	c7 e5 

    // Increment Wrap count
    r1 = M[r7 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.WRAP_COUNT_FIELD];
84203560:	93 f0 04 88 	r1 = M[r7 + 16];
    r1 = r1 + r10;
84203564:	63 0c       	r1 = r10 + r1;
    M[r7 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.WRAP_COUNT_FIELD]=r1;
84203566:	93 f0 04 8e 	M[r7 + 16] = r1;

    // setup amounts for insertions
    r5 = r5 + r10;
8420356a:	67 0c       	r5 = r10 + r5;
    r6 = r10;
8420356c:	60 09       	r6 = r10 + Null;

    // Number of Ports
    r9 = M[r8 + $cbops.param_hdr.NR_OUTPUT_CHANNELS_FIELD];
8420356e:	ab f0 02 88 	r9 = M[r8 + 8];

84203572 <$M.cbops.aec_ref_spkr_op.process_channel>:

    // Perform insertion
 process_channel:
    r0 = M[I4,0];
84203572:	20 f0 30 d0 	Null = Null + Null, r0 = M[I4,0];
    call $cbops.get_buffer_address_and_length;
84203576:	ff fd 90 f3 	call 0x756c0;
8420357a:	2a ea 
    I0 = r0;
8420357c:	10 0a       	I0 = r0 + Null;
    if Z jump process_channel_next;
8420357e:	11 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.process_channel_next;
      // Insert r6 zeros
      r10 = r6;
84203580:	44 09       	r10 = r6 + Null;
      L0 = r1;
84203582:	1c 0b       	L0 = r1 + Null;
      push r2;
84203584:	00 f0 34 cf 	push r2;
      pop B0;
84203588:	00 f6 3a cf 	pop B0;
      r1  = Null;
8420358c:	03 00       	r1 = Null + Null;
      do lp_insert_loop;
8420358e:	03 4c       	do (m) $M.cbops.aec_ref_spkr_op.lp_insert_loop;
         M[I0, MK1] = r1;
84203590:	b1 f0 30 c0 	Null = Null + Null, M[I0,4] = r1;

84203594 <$M.cbops.aec_ref_spkr_op.lp_insert_loop>:
      lp_insert_loop:
      // Update amount (r5)
      r0 = M[I4,MK1];
84203594:	21 f0 30 d0 	Null = Null + Null, r0 = M[I4,4];
      call $cbops.get_amount_ptr;
84203598:	ff fd 90 f3 	call 0x7573c;
8420359c:	24 ed 
      M[r0]=r5;
8420359e:	87 ee       	M[Null + r0] = r5;

842035a0 <$M.cbops.aec_ref_spkr_op.process_channel_next>:
    process_channel_next:
    r9 = r9 - 1;
842035a0:	bb f0 01 24 	r9 = r9 - 1;
    if GT jump process_channel;
842035a4:	e7 6b       	if GT jump (m) $M.cbops.aec_ref_spkr_op.process_channel;

    // Clear circular buffer
    L0=NULL;
842035a6:	04 0b       	L0 = Null + Null;
    push NULL;
842035a8:	00 f0 30 cf 	push Null;
    pop B0;
842035ac:	00 f6 3a cf 	pop B0;

    pop rlink;
842035b0:	00 f4 3d cf 	pop rLink;
    rts;
842035b4:	d8 4c       	rts;

842035b6 <$M.cbops.aec_ref_spkr_op.calc_dac_amount_of_data>:
// TRASHED REGISTERS:
//    r0,r1,r2
//
// *****************************************************************************
calc_dac_amount_of_data:
    push rLink;
842035b6:	00 f0 3d cf 	push rLink;
    call $cbuffer.calc_amount_space_in_words;
842035ba:	ff fd b3 f1 	call (m) 0x39d88;
842035be:	2f ee 

#if defined(CHIP_BASE_HYDRA)
    // Hydra: r2 is local buffer size in addr
    Addr2Words(r2);
842035c0:	64 58       	r2 = r2 ASHIFT -2;
    // Adjust space for amount written, buffer not port
    r0 = r0 - r5;
842035c2:	d2 05       	r0 = r0 - r5;
#endif

    // r0 is space in port minus one
    // r2 = amount data in port
    // r6 min required space
    r2  = r2 - r0;
842035c4:	a4 04       	r2 = r2 - r0;

    // check minimum space, if less than that
    // wrap has happened
    Null = r0 - r6;
842035c6:	8f f2 00 c2 	Null = r0 - r6;
    if NEG r2 = NULL - r0;
842035ca:	24 f0 04 c2 	if NEG r2 = Null - r0;

    r0 = M[r7 + $cbops_aec_ref_spkr_op.aec_ref_op_struct.BUFFER_ADJ_FIELD];
842035ce:	92 f0 02 88 	r0 = M[r7 + 8];
    r2 = r2 - r0;
842035d2:	a4 04       	r2 = r2 - r0;
    // r2 is number of samples in port, negative if overflow
    pop rLink;
842035d4:	00 f4 3d cf 	pop rLink;
    rts;
842035d8:	d8 4c       	rts;

842035da <$cbops.aec_ref_latency_mic.amount_to_use>:

$cbops.aec_ref_latency_mic.amount_to_use:
    LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_latency_mic.amount_to_use.PATCH_ID_0, r5)

   // Get I/O row entry for index (r5)
   r5 = M[r8 + CBOPS_AEC_REFERENCE_LATENCY_FIELD($aec_reference_latency.latency_op_struct.INDEX_FIELD)];
842035da:	a7 f0 03 88 	r5 = M[r8 + 12];
   r5 = r5 * $CBOP_BUFTAB_ENTRY_SIZE_IN_ADDR(int);
842035de:	3f 47       	r5 = r5 * 28 (int);
   r5 = r5 + r4;
842035e0:	f7 01       	r5 = r4 + r5;
   // Save transfer (space in buffer)
   r0 = M[r5 + $cbops_c.cbops_buffer_struct.TRANSFER_PTR_FIELD];
842035e2:	7a 89       	r0 = M[r5 + 20];
   r0 = M[r0];
842035e4:	12 e8       	r0 = M[r0 + Null];
   M[r8 + CBOPS_AEC_REFERENCE_LATENCY_FIELD($aec_reference_latency.latency_op_struct.AVAILABLE_FIELD)] = r0;
842035e6:	a2 f0 04 8e 	M[r8 + 16] = r0;
   rts;
842035ea:	d8 4c       	rts;

842035ec <$cbops.aec_ref_latency_mic.main>:
// *****************************************************************************
$cbops.aec_ref_latency_mic.main:
    LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_latency_mic.main.PATCH_ID_0, r6)

   // pointer to common (r6)
   r6 = M[r8 + CBOPS_AEC_REFERENCE_LATENCY_FIELD($aec_reference_latency.latency_op_struct.COMMON_FIELD)];
842035ec:	a8 f0 05 88 	r6 = M[r8 + 20];
   // Get I/O row entry for index (r5)
   r5 = M[r8 + CBOPS_AEC_REFERENCE_LATENCY_FIELD($aec_reference_latency.latency_op_struct.INDEX_FIELD)];
842035f0:	a7 f0 03 88 	r5 = M[r8 + 12];
   r5 = r5 * $CBOP_BUFTAB_ENTRY_SIZE_IN_ADDR(int);
842035f4:	3f 47       	r5 = r5 * 28 (int);
   r5 = r5 + r4;
842035f6:	f7 01       	r5 = r4 + r5;
   // get transfer amount (r0) and pointer (r7)
   r7 = M[r5 + $cbops_c.cbops_buffer_struct.TRANSFER_PTR_FIELD];
842035f8:	79 f0 05 88 	r7 = M[r5 + 20];
   r0 = M[r7];
842035fc:	92 f0 00 e8 	r0 = M[r7 + Null];
   // Purge transfer >= jitter
   r2 = M[r6 + $aec_reference_latency.aec_latency_common_struct.JITTER_FIELD];
84203600:	84 f0 00 88 	r2 = M[r6 + 0];
   r1 = M[r6 + $aec_reference_latency.aec_latency_common_struct.MIC_DATA_FIELD];
84203604:	83 f0 03 88 	r1 = M[r6 + 12];

   // Advance mic_data (r1)
   r1 = r1 + r0;
84203608:	d3 00       	r1 = r0 + r1;

   // if mic_data >= block_size
   r2 = M[r6 + $aec_reference_latency.aec_latency_common_struct.BLOCK_SIZE_FIELD];
8420360a:	84 f0 01 88 	r2 = M[r6 + 4];
   Null = r1 - r2;
8420360e:	18 05       	Null = r1 - r2;
   if NEG jump cbops.aec_ref_latency_mic.main.done;
84203610:	04 f0 b7 e0 	if NEG jump (m) $M.cbops.aec_ref_latency.cbops.aec_ref_latency_mic.main.done;
      // have a block, calc data in buffer = (size - space - 1)
      r4 = M[r5 + $cbops_c.cbops_buffer_struct.SIZE_FIELD];
84203614:	fe 88       	r4 = M[r5 + 12];
      Addr2Words(r4);
84203616:	76 58       	r4 = r4 ASHIFT -2;
      r3 = M[r8 + CBOPS_AEC_REFERENCE_LATENCY_FIELD($aec_reference_latency.latency_op_struct.AVAILABLE_FIELD)];
84203618:	a5 f0 04 88 	r3 = M[r8 + 16];
      r4 = r4 - r3;
8420361c:	76 05       	r4 = r4 - r3;
      r4 = r4 - 1;
8420361e:	76 24       	r4 = r4 - 1;
      // add transfer , subtract block
      r4 = r4 + r0;
84203620:	96 01       	r4 = r0 + r4;
      r1 = r4 - r2;
84203622:	33 05       	r1 = r4 - r2;
      if NEG jump cbops.aec_ref_latency_mic.main.error;
84203624:	04 f0 a9 e0 	if NEG jump (m) $M.cbops.aec_ref_latency.cbops.aec_ref_latency_mic.main.error;

     // have verified good block, signal reference
      M[r6 + $aec_reference_latency.aec_latency_common_struct.BLOCK_SYNC_FIELD] = r6;
84203628:	88 f0 02 8e 	M[r6 + 8] = r6;

      // Verify Block size is valid
      NULL = r2 - 1;
8420362c:	60 24       	Null = r2 - 1;
     if LE jump cbops.aec_ref_latency_mic.main.done;
8420362e:	0c 6c       	if LE jump (m) $M.cbops.aec_ref_latency.cbops.aec_ref_latency_mic.main.done;

      // mic_data (r1) > jitter (r4), drop data
      r4 = M[r6 + $aec_reference_latency.aec_latency_common_struct.JITTER_FIELD];
84203630:	86 f0 00 88 	r4 = M[r6 + 0];
      NULL = r1 - r4;
84203634:	98 05       	Null = r1 - r4;
      if LE jump cbops.aec_ref_latency_mic.main.done;
84203636:	08 6c       	if LE jump (m) $M.cbops.aec_ref_latency.cbops.aec_ref_latency_mic.main.done;
     // drop as much as possible, MIN(mic_data,transfer)
     r4 = r1;
84203638:	1e 00       	r4 = r1 + Null;
      r4 = MIN r0;
8420363a:	5f f2 46 ce 	r4 = MIN r0;
      r0 = r0 - r4;
8420363e:	92 05       	r0 = r0 - r4;
      r1 = r1 - r4;
84203640:	9b 05       	r1 = r1 - r4;
     // Update Transfer, and record drop
      M[r7] = r0;
84203642:	02 f0 09 ee 	M[Null + r7] = r0;

84203646 <$M.cbops.aec_ref_latency.cbops.aec_ref_latency_mic.main.done>:
cbops.aec_ref_latency_mic.main.done:
   // Update Mic Data
   M[r6 + $aec_reference_latency.aec_latency_common_struct.MIC_DATA_FIELD] = r1;
84203646:	83 f0 03 8e 	M[r6 + 12] = r1;
   rts;
8420364a:	d8 4c       	rts;

8420364c <$M.cbops.aec_ref_latency.cbops.aec_ref_latency_mic.main.error>:

cbops.aec_ref_latency_mic.main.error:
   // Buffer out of sync with mic_data.    Should never happen
   M[r6 + $aec_reference_latency.aec_latency_common_struct.MIC_DATA_FIELD] = r4;
8420364c:	86 f0 03 8e 	M[r6 + 12] = r4;
   rts;
84203650:	d8 4c       	rts;

84203652 <$cbops.aec_ref_latency_speaker.amount_to_use>:
// *****************************************************************************
$cbops.aec_ref_latency_speaker.amount_to_use:
    LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_latency_speaker.amount_to_use.PATCH_ID_0, r5)

   // Get I/O row entry for index (r5)
   r5 = M[r8 + CBOPS_AEC_REFERENCE_LATENCY_FIELD($aec_reference_latency.latency_op_struct.INDEX_FIELD)];
84203652:	a7 f0 03 88 	r5 = M[r8 + 12];
   r5 = r5 * $CBOP_BUFTAB_ENTRY_SIZE_IN_ADDR(int);
84203656:	3f 47       	r5 = r5 * 28 (int);
   r5 = r5 + r4;
84203658:	f7 01       	r5 = r4 + r5;
   // Get transfer (r1) and ptr (r0)
   r0 = M[r5 + $cbops_c.cbops_buffer_struct.TRANSFER_PTR_FIELD];
8420365a:	7a 89       	r0 = M[r5 + 20];
   r1 = M[r0];
8420365c:	13 e8       	r1 = M[r0 + Null];
   // ensure space (r1) is >= jitter (r6) to prevent stall
   r6 = M[r8 + CBOPS_AEC_REFERENCE_LATENCY_FIELD($aec_reference_latency.latency_op_struct.COMMON_FIELD)];
8420365e:	a8 f0 05 88 	r6 = M[r8 + 20];
   r2 = M[r6 + $aec_reference_latency.aec_latency_common_struct.JITTER_FIELD];
84203662:	84 f0 00 88 	r2 = M[r6 + 0];
   r3 = r1 - r2;
84203666:	1d 05       	r3 = r1 - r2;
   if POS jump cbops.aec_ref_latency_speaker.amount_to_use.done;
84203668:	05 f0 b9 e0 	if POS jump (m) $M.cbops.aec_ref_latency.cbops.aec_ref_latency_speaker.amount_to_use.done;
         M[r0]=r2;
8420366c:	84 ee       	M[Null + r0] = r2;

     // update counter for number of dropped samples
     r0 = M[r6 + $aec_reference_latency.aec_latency_common_struct.SPEAKER_DROPS_FIELD];
8420366e:	82 f0 08 88 	r0 = M[r6 + 32];
     r0 = r0 - r3;
84203672:	52 05       	r0 = r0 - r3;
     M[r6 + $aec_reference_latency.aec_latency_common_struct.SPEAKER_DROPS_FIELD] = r0;
84203674:	82 f0 08 8e 	M[r6 + 32] = r0;


         Words2Addr(r3);
84203678:	6d 5c       	r3 = r3 ASHIFT 2;
         M1 = r3;
8420367a:	29 0b       	M1 = r3 + Null;
         // Get Buffer
      r0 = M[r5 + $cbops_c.cbops_buffer_struct.RW_PTR_FIELD];
8420367c:	3a 89       	r0 = M[r5 + 16];
      I0 = r0;
8420367e:	10 0a       	I0 = r0 + Null;
      r0 = M[r5 + $cbops_c.cbops_buffer_struct.SIZE_FIELD];
84203680:	fa 88       	r0 = M[r5 + 12];
      L0 = r0;
84203682:	14 0b       	L0 = r0 + Null;
      r2 = M[r5 + $cbops_c.cbops_buffer_struct.BASE_FIELD];
84203684:	bc 88       	r2 = M[r5 + 8];
      push r2;
84203686:	00 f0 34 cf 	push r2;
      pop B0;
8420368a:	00 f6 3a cf 	pop B0;
      // Back up buffer
      r0 = M[I0,M1];
8420368e:	21 f0 20 c0 	Null = Null + Null, r0 = M[I0,M1];
      // Update Buffer
      r0 = I0;
84203692:	82 08       	r0 = I0 + Null;
      M[r5 + $cbops_c.cbops_buffer_struct.RW_PTR_FIELD]=r0;
84203694:	3a 8f       	M[r5 + 16] = r0;

      // restore circular
      L0 = 0;
84203696:	04 0b       	L0 = Null + Null;
      push NULL;
84203698:	00 f0 30 cf 	push Null;
      pop B0;
8420369c:	00 f6 3a cf 	pop B0;

842036a0 <$M.cbops.aec_ref_latency.cbops.aec_ref_latency_speaker.amount_to_use.done>:

    cbops.aec_ref_latency_speaker.amount_to_use.done:

   M[r8 + CBOPS_AEC_REFERENCE_LATENCY_FIELD($aec_reference_latency.latency_op_struct.AVAILABLE_FIELD)] = r1;
842036a0:	a3 f0 04 8e 	M[r8 + 16] = r1;

   rts;
842036a4:	d8 4c       	rts;

842036a6 <$cbops.aec_ref_latency_speaker.main>:
*/
$cbops.aec_ref_latency_speaker.main:
    LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_latency_speaker.main.PATCH_ID_0, r5)

   // Get I/O row entry for index (r5)
   r5 = M[r8 + CBOPS_AEC_REFERENCE_LATENCY_FIELD($aec_reference_latency.latency_op_struct.INDEX_FIELD)];
842036a6:	a7 f0 03 88 	r5 = M[r8 + 12];
   r5 = r5 * $CBOP_BUFTAB_ENTRY_SIZE_IN_ADDR(int);
842036aa:	3f 47       	r5 = r5 * 28 (int);
   r5 = r5 + r4;
842036ac:	f7 01       	r5 = r4 + r5;
   // get transfer amount (r0) and pointer (r7)
   r7 = M[r5 + $cbops_c.cbops_buffer_struct.TRANSFER_PTR_FIELD];
842036ae:	79 f0 05 88 	r7 = M[r5 + 20];
   r0 = M[r7];
842036b2:	92 f0 00 e8 	r0 = M[r7 + Null];
   if Z rts;
842036b6:	00 fd c0 cd 	if EQ rts;
   // pointer to common (r6)
   r6 = M[r8 + CBOPS_AEC_REFERENCE_LATENCY_FIELD($aec_reference_latency.latency_op_struct.COMMON_FIELD)];
842036ba:	a8 f0 05 88 	r6 = M[r8 + 20];

   // get frame size (r4).  If <=1 then disable latency control
   r4 = M[r6 + $aec_reference_latency.aec_latency_common_struct.BLOCK_SIZE_FIELD];
842036be:	86 f0 01 88 	r4 = M[r6 + 4];
   NULL = r4 - 1;
842036c2:	70 24       	Null = r4 - 1;
   if LE rts;
842036c4:	0d fd c0 cd 	if LE rts;

   // advance speaker_data (r1)
   r1 = M[r6 + $aec_reference_latency.aec_latency_common_struct.SPEAKER_DATA_FIELD];
842036c8:	83 f0 04 88 	r1 = M[r6 + 16];
   r1 = r1 + r0;
842036cc:	d3 00       	r1 = r0 + r1;

   // remainder (r3) = Delay + mic_data
   r2 = M[r6 + $aec_reference_latency.aec_latency_common_struct.REF_DELAY_FIELD];
842036ce:	84 f0 05 88 	r2 = M[r6 + 20];
   r3 = M[r6 + $aec_reference_latency.aec_latency_common_struct.MIC_DATA_FIELD];
842036d2:	85 f0 03 88 	r3 = M[r6 + 12];
   r3 = r3 + r2;
842036d6:	65 01       	r3 = r2 + r3;
   r9 = M[r6 + $aec_reference_latency.aec_latency_common_struct.JITTER_FIELD];
842036d8:	8b f0 00 88 	r9 = M[r6 + 0];


   // Did mic report a frame of data
   NULL = M[r6 + $aec_reference_latency.aec_latency_common_struct.BLOCK_SYNC_FIELD];
842036dc:	80 f0 02 88 	Null = M[r6 + 8];
   if Z jump cbops.aec_ref_latency_speaker.main.drop;
842036e0:	14 60       	if EQ jump (m) $M.cbops.aec_ref_latency.cbops.aec_ref_latency_speaker.main.drop;
      // Increment Frame count
      r1 = M[r6 + $aec_reference_latency.aec_latency_common_struct.FRM_COUNT_FIELD];
842036e2:	83 f0 06 88 	r1 = M[r6 + 24];
      r2 = r1 + 1;
842036e6:	5c 20       	r2 = r1 + 1;
      if C r2=r1;
842036e8:	02 f3 04 c0 	if C r2 = r1 + Null;
      M[r6 + $aec_reference_latency.aec_latency_common_struct.FRM_COUNT_FIELD]=r2;
842036ec:	84 f0 06 8e 	M[r6 + 24] = r2;

      // Get data actually in Buffer (r1) = (size - space - 1)
      r1 = M[r5 + $cbops_c.cbops_buffer_struct.SIZE_FIELD];
842036f0:	fb 88       	r1 = M[r5 + 12];
      Addr2Words(r1);
842036f2:	5b 58       	r1 = r1 ASHIFT -2;
      r2 = M[r8 + CBOPS_AEC_REFERENCE_LATENCY_FIELD($aec_reference_latency.latency_op_struct.AVAILABLE_FIELD)];
842036f4:	a4 f0 04 88 	r2 = M[r8 + 16];
      r1 = r1 - r2;
842036f8:	1b 05       	r1 = r1 - r2;
      r1 = r1 - 1;
842036fa:	5b 24       	r1 = r1 - 1;

      // add transfer (r0)
       r1 = r1 + r0;
842036fc:	d3 00       	r1 = r0 + r1;

      // limit (r2) = block_size (r4) + delay (r3)
      r2 = r3 + r4;
842036fe:	ac 01       	r2 = r3 + r4;

      // if speaker_data < limit , Insert
      Null = r1 - r2;
84203700:	18 05       	Null = r1 - r2;
      if NEG jump cbops.aec_ref_latency_speaker.main.insert;
84203702:	04 f0 81 e1 	if NEG jump (m) $M.cbops.aec_ref_latency.cbops.aec_ref_latency_speaker.main.insert;

      // speaker_data (r1) = speaker_data - block_size
      r1 = r1 - r4;
84203706:	9b 05       	r1 = r1 - r4;

84203708 <$M.cbops.aec_ref_latency.cbops.aec_ref_latency_speaker.main.drop>:

 cbops.aec_ref_latency_speaker.main.drop:

   // r4 = speaker_data - remainder, r0=transfer, r1=speaker_data
   r4 = r1 - r3;
84203708:	5e 05       	r4 = r1 - r3;
   // if (speaker_data - remainder) >= jitter, drop data
   NULL = r4 - r9;
8420370a:	bf f6 00 c2 	Null = r4 - r9;
   if NEG jump cbops.aec_ref_latency_speaker.main.done;
8420370e:	04 f0 e5 e0 	if NEG jump (m) $M.cbops.aec_ref_latency.cbops.aec_ref_latency_speaker.main.done;
   // Target speaker_data = mic_data + delay + jitter/2
   r2 = r9 ASHIFT -1;
84203712:	7f fb 14 d9 	r2 = r9 ASHIFT -1;
   r3 = r3 + r2;
84203716:	65 01       	r3 = r2 + r3;
   r3 = r1 - r3;
84203718:	5d 05       	r3 = r1 - r3;
   r3 = MIN r0;
8420371a:	5f f2 45 ce 	r3 = MIN r0;
   // drop speaker_data (r1) and transfer (r0) by MIN(transfer, r3)
   r0 = r0 - r3;
8420371e:	52 05       	r0 = r0 - r3;
   r1 = r1 - r3;
84203720:	5b 05       	r1 = r1 - r3;
   M[r7] = r0;
84203722:	02 f0 09 ee 	M[Null + r7] = r0;

   // update counter for number of dropped samples
   r0 = M[r6 + $aec_reference_latency.aec_latency_common_struct.SPEAKER_DROPS_FIELD];
84203726:	82 f0 08 88 	r0 = M[r6 + 32];
   r0 = r0 + r3;
8420372a:	aa 00       	r0 = r3 + r0;
   M[r6 + $aec_reference_latency.aec_latency_common_struct.SPEAKER_DROPS_FIELD] = r0;
8420372c:	82 f0 08 8e 	M[r6 + 32] = r0;

84203730 <$M.cbops.aec_ref_latency.cbops.aec_ref_latency_speaker.main.rm_update>:

cbops.aec_ref_latency_speaker.main.rm_update:
   // r1=speaker count, r3 = drop/insert, (<0 for inserts)

   // Compute demominator (frm_count * frm_size).  Reset frame counter
   r2 = M[r6 + $aec_reference_latency.aec_latency_common_struct.BLOCK_SIZE_FIELD];
84203730:	84 f0 01 88 	r2 = M[r6 + 4];
   r4 = M[r6 + $aec_reference_latency.aec_latency_common_struct.FRM_COUNT_FIELD];
84203734:	86 f0 06 88 	r4 = M[r6 + 24];
   M[r6 + $aec_reference_latency.aec_latency_common_struct.FRM_COUNT_FIELD]=NULL;
84203738:	80 f0 06 8e 	M[r6 + 24] = Null;
   rMAC = r4*r2;     // Note: frac mult is x2
8420373c:	4f f6 c1 cc 	rMAC = r4 * r2 (SS);
   r4 = SIGNDET rMAC;
84203740:	0f f1 86 cd 	r4 = SIGNDET rMAC;
   rMAC = rMAC ASHIFT r4 (56bit);
84203744:	89 19       	rMAC = rMAC ASHIFT r4 (56bit);
   r2 = rMAC;
84203746:	0c 00       	r2 = rMAC + Null;

   // Compute numerator (drift)
   r0 = SIGNDET r3;
84203748:	0f f5 82 cd 	r0 = SIGNDET r3;
   r0 = r0 - 2;
8420374c:	92 24       	r0 = r0 - 2;
   rMAC = r3 ASHIFT r0;
8420374e:	2f f5 0e c9 	rMAC = r3 ASHIFT r0;

   // drift  / (frm_count * frm_size)
   Div = rMAC / r2;
84203752:	a1 4c       	Div = rMAC / r2;

   // Get and clear rate adjustment
   r7 = M[r6 + $aec_reference_latency.aec_latency_common_struct.RM_ADJUSTMENT_FIELD];
84203754:	89 f0 07 88 	r7 = M[r6 + 28];
   M[r6 + $aec_reference_latency.aec_latency_common_struct.RM_ADJUSTMENT_FIELD]=NULL;
84203758:	80 f0 07 8e 	M[r6 + 28] = Null;

   // Compute exponent
   r4 = r4 - DAWTH;
8420375c:	36 34       	r4 = r4 - 32;
   r4 = r4 - r0;
8420375e:	b6 04       	r4 = r4 - r0;

   // Validate result (exp < -9 )
   NULL = r4 + 9;
84203760:	70 22       	Null = r4 + 9;
   if POS jump cbops.aec_ref_latency_speaker.main.done;
84203762:	05 f0 91 e0 	if POS jump (m) $M.cbops.aec_ref_latency.cbops.aec_ref_latency_speaker.main.done;
      // Update rate adjustment
      rMAC = DivResult;
84203766:	c1 4c       	rMAC = DivResult;
      rMAC = rMAC ASHIFT r4 (56bit);
84203768:	89 19       	rMAC = rMAC ASHIFT r4 (56bit);
      r7 = r7 - rMAC;
8420376a:	00 f1 39 c2 	r7 = r7 - rMAC;
      M[r6 + $aec_reference_latency.aec_latency_common_struct.RM_ADJUSTMENT_FIELD]=r7;
8420376e:	89 f0 07 8e 	M[r6 + 28] = r7;

84203772 <$M.cbops.aec_ref_latency.cbops.aec_ref_latency_speaker.main.done>:

cbops.aec_ref_latency_speaker.main.done:
   // Update speaker_data and clear signal from MIC
   M[r6 + $aec_reference_latency.aec_latency_common_struct.SPEAKER_DATA_FIELD] = r1;
84203772:	83 f0 04 8e 	M[r6 + 16] = r1;

   // update ref-mic delay
   r2 = M[r6 + $aec_reference_latency.aec_latency_common_struct.MIC_DATA_FIELD];
84203776:	84 f0 03 88 	r2 = M[r6 + 12];
   r1 = r1 - r2;
8420377a:	1b 05       	r1 = r1 - r2;
   M[r6 + $aec_reference_latency.aec_latency_common_struct.SPEAKER_DELAY_FIELD] = r1;
8420377c:	83 f0 0a 8e 	M[r6 + 40] = r1;

   rts;
84203780:	d8 4c       	rts;

84203782 <$M.cbops.aec_ref_latency.cbops.aec_ref_latency_speaker.main.insert>:

cbops.aec_ref_latency_speaker.main.insert:
   // r1=speaker_data, r0=transfer, r2 = block_size + rmainder, r3=rmainder

   // Advance to insertion point (M1)
   r10 = r0*MK1 (int);
84203782:	02 f2 9c c9 	r10 = r0 * 4 (int);
   M1  = r10;
84203786:	61 0b       	M1 = r10 + Null;

   // Compute insertion (r10) and update transfer and remainder
   r4 = r9 ASHIFT -1;
84203788:	7f fb 16 d9 	r4 = r9 ASHIFT -1;

   r2  = r2 + r4;
8420378c:	34 01       	r2 = r4 + r2;
   r10 = r2 - r1;
8420378e:	3f f4 0c c2 	r10 = r2 - r1;
   r0  = r0 + r10;
84203792:	62 0c       	r0 = r10 + r0;
   M[r7] = r0;
84203794:	02 f0 09 ee 	M[Null + r7] = r0;
   r1 = r3 + r4;
84203798:	ab 01       	r1 = r3 + r4;

   // update counter for number of inserted samples
   r0 = M[r6 + $aec_reference_latency.aec_latency_common_struct.SPEAKER_INSERTS_FIELD];
8420379a:	82 f0 09 88 	r0 = M[r6 + 36];
   r0 = r0 + r10;
8420379e:	62 0c       	r0 = r10 + r0;
   M[r6 + $aec_reference_latency.aec_latency_common_struct.SPEAKER_INSERTS_FIELD] = r0;
842037a0:	82 f0 09 8e 	M[r6 + 36] = r0;

   // Number of insertions (negated)
   r3 = NULL - r10;
842037a4:	cf f0 05 c2 	r3 = Null - r10;

   // Get Buffer
   r0 = M[r5 + $cbops_c.cbops_buffer_struct.RW_PTR_FIELD];
842037a8:	3a 89       	r0 = M[r5 + 16];
   I0 = r0;
842037aa:	10 0a       	I0 = r0 + Null;
   r0 = M[r5 + $cbops_c.cbops_buffer_struct.SIZE_FIELD];
842037ac:	fa 88       	r0 = M[r5 + 12];
   L0 = r0;
842037ae:	14 0b       	L0 = r0 + Null;
   r2 = M[r5 + $cbops_c.cbops_buffer_struct.BASE_FIELD];
842037b0:	bc 88       	r2 = M[r5 + 8];
   push r2;
842037b2:	00 f0 34 cf 	push r2;
   pop B0;
842037b6:	00 f6 3a cf 	pop B0;

   // Advance to insertion point
   r2 = M[I0,M1];
842037ba:	41 f0 20 c0 	Null = Null + Null, r2 = M[I0,M1];

   // Insert zeros
   r0 = 0;
842037be:	02 00       	r0 = Null + Null;
   do cbops.aec_ref_latency_speaker.main.insert_loop;
842037c0:	03 4c       	do (m) $M.cbops.aec_ref_latency.cbops.aec_ref_latency_speaker.main.insert_loop;
      M[I0,MK1] = r0;
842037c2:	a1 f0 30 c0 	Null = Null + Null, M[I0,4] = r0;

842037c6 <$M.cbops.aec_ref_latency.cbops.aec_ref_latency_speaker.main.insert_loop>:
   cbops.aec_ref_latency_speaker.main.insert_loop:

   // clear cicular buffer
   L0 = 0;
842037c6:	04 0b       	L0 = Null + Null;
   push Null;
842037c8:	00 f0 30 cf 	push Null;
   pop B0;
842037cc:	00 f6 3a cf 	pop B0;

   // speaker_data (r1) = remainder
   jump cbops.aec_ref_latency_speaker.main.rm_update;
842037d0:	b0 6f       	jump (m) $M.cbops.aec_ref_latency.cbops.aec_ref_latency_speaker.main.rm_update;

842037d2 <$_aec_ref_purge_mics>:

// void aec_ref_purge_mics(cbops_graph *mic_graph,unsigned num_mics);
$_aec_ref_purge_mics:
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($_aec_ref_purge_mics.PATCH_ID_0)
  // Save registers
   push rLink;
842037d2:	00 f0 3d cf 	push rLink;
   pushm <r5,r6,r7,r8,r10>;
842037d6:	78 f1 40 e0 	pushm <r5, r6, r7, r8, r10>;
   pushm <M0,L0>;
842037da:	10 f1 40 e4 	pushm <M0, L0>;
   push I0;
842037de:	00 f1 30 cf 	push I0;
   push B0;
842037e2:	00 f2 3a cf 	push B0;

  // Force cbops to update buffers
  M[r0 + $cbops_c.cbops_graph_struct.FORCE_UPDATE_FIELD]=r0;
842037e6:	12 9e       	M[r0 + 32] = r0;

   // Extra parameters
   r7 = r0 + $cbops_c.cbops_graph_struct.BUFFERS_FIELD;
842037e8:	29 f0 28 20 	r7 = r0 + 40;
   r8 = r1;
842037ec:	1a 09       	r8 = r1 + Null;
   r6 = MAXINT;
842037ee:	ff f7 f8 f7 	r6 = Null + 2147483647;
842037f2:	ff 7b 

   // Get minimum data in mics
   r10 = r8;
842037f4:	54 09       	r10 = r8 + Null;
   r5  = r7;
842037f6:	4f 08       	r5 = r7 + Null;
   do aec_ref_purge_mics.data_loop;
842037f8:	08 4c       	do (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.data_loop;
      // Get amount of data in mic
      r0 = M[r5 + $cbops_c.cbops_buffer_struct.BUFFER_FIELD];
842037fa:	7a 88       	r0 = M[r5 + 4];
      call $cbuffer.calc_amount_data_in_words;
842037fc:	ff fd b2 f1 	call (m) 0x39dd4;
84203800:	39 ee 
      // update minimum
      r6 = MIN r0;
84203802:	5f f2 48 ce 	r6 = MIN r0;
      // Go to next mic
      r5 = r5 + $CBOP_BUFTAB_ENTRY_SIZE_IN_ADDR;
84203806:	3f 2b       	r5 = r5 + 28;

84203808 <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.data_loop>:
   aec_ref_purge_mics.data_loop:

  r0 = r6;
84203808:	42 08       	r0 = r6 + Null;
   Words2Addr(r0);
8420380a:	52 5c       	r0 = r0 ASHIFT 2;
   M0 = r0;
8420380c:	10 0b       	M0 = r0 + Null;
   if Z jump aec_ref_purge_mics_done;
8420380e:	1e 60       	if EQ jump (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics_done;

   // Read Data
   r5  = r7;
84203810:	4f 08       	r5 = r7 + Null;

84203812 <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.advance_loop>:
aec_ref_purge_mics.advance_loop:
      // Get Input buffer (source)
      r0 = M[r5 + $cbops_c.cbops_buffer_struct.BUFFER_FIELD];
84203812:	7a 88       	r0 = M[r5 + 4];
    call $cbuffer.get_read_address_and_size_and_start_address;
84203814:	ff fd b5 f1 	call (m) 0x3a27a;
84203818:	27 e3 
      L0 = r1;
8420381a:	1c 0b       	L0 = r1 + Null;
      push r2;
8420381c:	00 f0 34 cf 	push r2;
      pop B0;
84203820:	00 f6 3a cf 	pop B0;
     I0 = r0;
84203824:	10 0a       	I0 = r0 + Null;
      // Advance buffer
      NULL = r1 - MK1;
84203826:	18 25       	Null = r1 - 4;
      if NZ jump aec_ref_purge_mics.sw_buf;
84203828:	06 62       	if NE jump (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.sw_buf;
         // MMU buffer must be read
         r10 = r6;
8420382a:	44 09       	r10 = r6 + Null;
         do aec_ref_purge_mics.mmu_buf;
8420382c:	03 4c       	do (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.mmu_buf;
            r0 = M[I0,MK1];
8420382e:	21 f0 30 c0 	Null = Null + Null, r0 = M[I0,4];

84203832 <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.mmu_buf>:
         aec_ref_purge_mics.mmu_buf:

         jump aec_ref_purge_mics.next;
84203832:	03 6e       	jump (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.next;

84203834 <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.sw_buf>:

aec_ref_purge_mics.sw_buf:
         r0 = M[I0,M0];
84203834:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];

84203838 <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.next>:
aec_ref_purge_mics.next:
      // Update buffer
      r0 = M[r5 + $cbops_c.cbops_buffer_struct.BUFFER_FIELD];
84203838:	7a 88       	r0 = M[r5 + 4];
      r1 = I0;
8420383a:	83 08       	r1 = I0 + Null;
      call $cbuffer.set_read_address;
8420383c:	ff fd b5 f1 	call (m) 0x3a2e6;
84203840:	2b e5 
      // Go to next mic
      r5 = r5 + $CBOP_BUFTAB_ENTRY_SIZE_IN_ADDR;
84203842:	3f 2b       	r5 = r5 + 28;
      r8 = r8 - 1;
84203844:	aa f0 01 24 	r8 = r8 - 1;
      if GT jump aec_ref_purge_mics.advance_loop;
84203848:	e5 6b       	if GT jump (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.advance_loop;

8420384a <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics_done>:

aec_ref_purge_mics_done:
  // Restore registers
   pop B0;
8420384a:	00 f6 3a cf 	pop B0;
   pop I0;
8420384e:	00 f5 30 cf 	pop I0;
   popm <M0,L0>;
84203852:	10 f1 60 e4 	popm <M0, L0>;
   popm <r5,r6,r7,r8,r10>;
84203856:	78 f1 60 e0 	popm <r5, r6, r7, r8, r10>;
  pop rLink;
8420385a:	00 f4 3d cf 	pop rLink;
   rts;
8420385e:	d8 4c       	rts;

84203860 <$_aecref_calc_ref_rate>:
// *****************************************************************************
.MODULE $M.aecref_calc_ref_rate;
   .CODESEGMENT PM;
$_aecref_calc_ref_rate:
    LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($_aecref_calc_ref_rate.PATCH_ID_0)
    push r4;
84203860:	00 f0 36 cf 	push r4;
    r4 = 0.5;
84203864:	00 f4 06 f0 	r4 = Null + 1073741824;
84203868:	00 40 
    // RateAdjREF = ([( mic_ra + 1.0) x (spkr_ra + 1.0) x mic_rt ] / spkr_rt) - 1.0

    // (mic_ra+1) x (spkr_ra+1.0) x 0.25 =
    //       (mic_ra*0.5 + 0.5) x (spkr_ra*0.5 + 0.5)
    r1 = r1 ASHIFT -1;
8420386a:	1b 58       	r1 = r1 ASHIFT -1;
    r1 = r1 + r4;
8420386c:	f3 00       	r1 = r4 + r1;
    r3 = r3 ASHIFT -1;
8420386e:	2d 58       	r3 = r3 ASHIFT -1;
    r3 = r3 + r4;
84203870:	75 01       	r3 = r4 + r3;
    rMAC = r1*r3;
84203872:	5f f3 c1 cc 	rMAC = r1 * r3 (SS);

    // (mic_ra+1) x (spkr_ra+1.0) x mic_rt x 0.25
    rMAC = rMAC * r0;
84203876:	2f f1 c1 cc 	rMAC = rMAC * r0 (SS);

    //  Note:  Multiplier is 0.25 instead of 0.5 because it is going
    //         into a fractional divide

    // [(mic_ra+1) x (spkr_ra+1.0) x mic_rt x 0.25]/spkr_rt
    DIV = rMAC / r2;
8420387a:	a1 4c       	Div = rMAC / r2;
    r0 = DivResult;
8420387c:	c2 4c       	r0 = DivResult;

    // Result of the divide is [0.0 ... 1.0], 0.5 is unity
    //   Convert to [-1.0 ... +1.0]
    r0 = r0 - r4;
8420387e:	92 05       	r0 = r0 - r4;
    r0 = r0 ASHIFT 1;
84203880:	12 5c       	r0 = r0 ASHIFT 1;
    pop r4;
84203882:	00 f4 36 cf 	pop r4;
    rts;
84203886:	d8 4c       	rts;

84203888 <$_aecref_calc_sync_mic_rate>:
    LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($_aecref_calc_sync_mic_rate.PATCH_ID_0)
    // r0 = spkr_ra
    // r1 = spkr_rt
    // r2 = mic_rt
    // return spkr_rt/(mic_rt*(1+spkr_ra))
    rMAC = -r0;
84203888:	81 04       	rMAC = Null - r0;
    r3 = r0 * r0 (frac);
8420388a:	2f f2 45 c9 	r3 = r0 * r0 (frac);
    rMAC = rMAC + r0 * r0;
8420388e:	2f f2 c1 ca 	rMAC = rMAC + r0 * r0 (SS);
    rMAC = rMAC - r0*r3;   // rMAC = -spkr_ra + spkr_ra^2 - spkr_ra^3
84203892:	5f f2 c1 cb 	rMAC = rMAC - r0 * r3 (SS);
                           // good enough estimation of 1.0/(1.0+spkr_ra) -1.0
    r0 = rMAC;
84203896:	0a 00       	r0 = rMAC + Null;
    rMAC = r1 - r2;
84203898:	19 05       	rMAC = r1 - r2;
    if Z rts;              // all done if mic_rt==spkr_rt
8420389a:	00 fd c0 cd 	if EQ rts;
    // calculate (spkr_rt/mic_rt)-1.0
#if DAWTH>24
   // division & rounding
   rMAC0 = r2;
8420389e:	05 f0 00 f4 	rMAC0 = r2 LSHIFT 0;
842038a2:	de c8 
   r2 = r2 + r2;
842038a4:	24 01       	r2 = r2 + r2;
   Div = rMAC / r2;
842038a6:	a1 4c       	Div = rMAC / r2;
   r1 = DivResult;       // r1 = (spkr_rt/mic_rt)-1.0
842038a8:	c3 4c       	r1 = DivResult;
   r1 = r1 - 0.5;    // r1 = 0.5(spkr_rt/mic_rt-1.0)
   r1 = r1 + r1;     // r1 = (spkr_rt/mic_rt)-1.0
#endif
    // r1 = (spkr_rt/mic_rt)-1.0
    // r0 = 1.0/(1.0+spkr_ra)-1.0
    r2 = r1 * r0 (frac);
842038aa:	2f f3 44 c9 	r2 = r1 * r0 (frac);
    r0 = r1 + r0;
842038ae:	9a 00       	r0 = r1 + r0;
    r0 = r0 + r2;
842038b0:	a2 00       	r0 = r2 + r0;
    // r0 = spkr_rt/mic_rt/(1+spkr_ra) - 1.0
    rts;
842038b2:	d8 4c       	rts;

842038b4 <$cbops.aec_ref_sidetone_op.amount_to_use>:
// Called before amount_to_use of graph
$cbops.aec_ref_sidetone_op.amount_to_use:
#ifdef PATCH_LIBS
   LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_sidetone_op.amount_to_use.PATCH_ID_0, r7)
#endif
   push rlink;
842038b4:	00 f0 3d cf 	push rLink;

   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
842038b8:	a9 f0 00 88 	r7 = M[r8 + 0];

   // update sidetone mic buffer
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.MIC_BUF_FIELD];
842038bc:	92 f0 01 88 	r0 = M[r7 + 4];
   call $cbuffer.get_write_address_and_size_and_start_address;
842038c0:	ff fd b4 f1 	call (m) 0x3a2b0;
842038c4:	31 ef 
   r6 = r0;
842038c6:	10 09       	r6 = r0 + Null;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.MIC_IDX_FIELD];
842038c8:	92 f0 05 88 	r0 = M[r7 + 20];
   call $cbops.get_cbuffer;
842038cc:	ff fd 8f f3 	call 0x7572c;
842038d0:	20 e3 
   r1 = r6;
842038d2:	43 08       	r1 = r6 + Null;
   r6 = r0;
842038d4:	10 09       	r6 = r0 + Null;
   call $cbuffer.set_write_address;
842038d6:	ff fd b5 f1 	call (m) 0x3a320;
842038da:	2b e2 

   // update amount to read from mic
   r0 = r6;
842038dc:	42 08       	r0 = r6 + Null;
   call $cbuffer.calc_amount_data_in_words;
842038de:	ff fd b2 f1 	call (m) 0x39dd4;
842038e2:	37 e7 
   r6 = r0;
842038e4:	10 09       	r6 = r0 + Null;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.MIC_IDX_FIELD];
842038e6:	92 f0 05 88 	r0 = M[r7 + 20];
   call $cbops.get_amount_ptr;
842038ea:	ff fd 8f f3 	call 0x7573c;
842038ee:	32 e2 
   M[r0] = r6;
842038f0:	08 f0 02 ee 	M[Null + r0] = r6;

   /* See how many samples speakr has moved, we will mix the same
    * number of samples from sidetone buffer.
    */
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
842038f4:	92 f0 00 88 	r0 = M[r7 + 0];
   r0 = M[r0];
842038f8:	12 e8       	r0 = M[r0 + Null];
   call $cbuffer.get_read_address_and_size_and_start_address;
842038fa:	ff fd b4 f1 	call (m) 0x3a27a;
842038fe:	21 ec 
   r3 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SPKR_ADDR_FIELD];
84203900:	95 f0 0e 88 	r3 = M[r7 + 56];
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SPKR_ADDR_FIELD] = r0;
84203904:	92 f0 0e 8e 	M[r7 + 56] = r0;
   r3 = r0 - r3;
84203908:	55 05       	r3 = r0 - r3;
   if NEG r3 = r3 + r1;
8420390a:	34 f5 05 c0 	if NEG r3 = r3 + r1;
   BUFFER_ADDRS_TO_WORDS_ASM(r3);
8420390e:	6d 58       	r3 = r3 ASHIFT -2;
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.AMOUNT_TO_MIX_FIELD] = r3;
84203910:	95 f0 0f 8e 	M[r7 + 60] = r3;
   pop rlink;
84203914:	00 f4 3d cf 	pop rLink;
   rts;
84203918:	d8 4c       	rts;

8420391a <$cbops.aec_ref_sidetone_op.pre_main>:
// TRASHED REGISTERS:
//    Assume anything except r4 and r8
//
// *****************************************************************************
$cbops.aec_ref_sidetone_op.pre_main:
   push rLink;
8420391a:	00 f0 3d cf 	push rLink;
   /* Force processing */
#ifdef PATCH_LIBS
   LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_sidetone_op.pre_main.PATCH_ID_0, r6)
#endif
   call $cbops.force_processing;
8420391e:	ff fd 8f f3 	call 0x7574c;
84203922:	2e e1 
   pop rlink;
84203924:	00 f4 3d cf 	pop rLink;
   rts;
84203928:	d8 4c       	rts;

8420392a <$cbops.aec_ref_sidetone_op.post_main>:
// *****************************************************************************
$cbops.aec_ref_sidetone_op.post_main:
#ifdef PATCH_LIBS
   LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_sidetone_op.post_main.PATCH_ID_0, r7)
#endif
   push rlink;
8420392a:	00 f0 3d cf 	push rLink;

   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
8420392e:	a9 f0 00 88 	r7 = M[r8 + 0];

   // get speaker buffer
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
84203932:	92 f0 00 88 	r0 = M[r7 + 0];
   r0 = M[r0];
84203936:	12 e8       	r0 = M[r0 + Null];
   call $cbuffer.get_read_address_and_size_and_start_address;
84203938:	ff fd b4 f1 	call (m) 0x3a27a;
8420393c:	23 ea 
   I0 = r0;
8420393e:	10 0a       	I0 = r0 + Null;
   L0 = r1;
84203940:	1c 0b       	L0 = r1 + Null;
   push r2;
84203942:	00 f0 34 cf 	push r2;
   pop B0;
84203946:	00 f6 3a cf 	pop B0;
   // save read address for later use
   I6 = r0;
8420394a:	16 0a       	I6 = r0 + Null;
   // I6 = read address of first speaker buffer

   // get threshold
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_LOW_FIELD];
8420394c:	92 f0 06 88 	r0 = M[r7 + 24];
   BUFFER_WORDS_TO_ADDRS_ASM(r0);
84203950:	52 5c       	r0 = r0 ASHIFT 2;
   M0 = r0;
84203952:	10 0b       	M0 = r0 + Null;

   // r6 = spkr_rd + threshold_low
   r0 = M[I0, M0];
84203954:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];
   r6 = I0;
84203958:	80 09       	r6 = I0 + Null;

   // r5 = spkr_rd + threshold_high
   I0 = I6;
8420395a:	b0 0a       	I0 = I6 + Null;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_HIGH_FIELD];
8420395c:	92 f0 07 88 	r0 = M[r7 + 28];
   BUFFER_WORDS_TO_ADDRS_ASM(r0);
84203960:	52 5c       	r0 = r0 ASHIFT 2;
   M0 = r0;
84203962:	10 0b       	M0 = r0 + Null;
   r0 = M[I0, M0];
84203964:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];
   r5 = I0;
84203968:	87 08       	r5 = I0 + Null;

   r0 = r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_MIXING_OFFSETS_FIELD;
8420396a:	92 f0 0c 20 	r0 = r7 + 12;
   r0 = M[r0];
8420396e:	12 e8       	r0 = M[r0 + Null];
   I0 = r0;
84203970:	10 0a       	I0 = r0 + Null;
   I7 = r0;
84203972:	17 0a       	I7 = r0 + Null;
   //            r0
   // --|----|---^---|-------------------------------------|--
   //   RD   Low     High                                 WR
   //
   // ====================================================================
   Null = r5 - r6;
84203974:	8f f7 00 c2 	Null = r5 - r6;
   if NEG jump neg_part;
84203978:	04 f0 95 e0 	if NEG jump (m) $M.cbops.aec_ref_sidetone_op.neg_part;

8420397c <$M.cbops.aec_ref_sidetone_op.pos_part>:
   pos_part:
      // expect: r6 <= r0 < r5
      Null = r0 - r5;
8420397c:	d0 05       	Null = r0 - r5;
      if POS jump reset_mixing_offset;
8420397e:	05 f0 9d e0 	if POS jump (m) $M.cbops.aec_ref_sidetone_op.reset_mixing_offset;
      Null = r0 - r6;
84203982:	8f f2 00 c2 	Null = r0 - r6;
      if NEG jump reset_mixing_offset;
84203986:	04 f0 95 e0 	if NEG jump (m) $M.cbops.aec_ref_sidetone_op.reset_mixing_offset;
      jump mixing_point_check_done;
8420398a:	1a 6e       	jump (m) $M.cbops.aec_ref_sidetone_op.mixing_point_check_done;

8420398c <$M.cbops.aec_ref_sidetone_op.neg_part>:

   neg_part:
      // expect: r0 < r5 or r0 >= r6
      Null = r0 - r6;
8420398c:	8f f2 00 c2 	Null = r0 - r6;
      if POS jump mixing_point_check_done;
84203990:	05 f0 af e0 	if POS jump (m) $M.cbops.aec_ref_sidetone_op.mixing_point_check_done;
      Null = r0 - r5;
84203994:	d0 05       	Null = r0 - r5;
      if NEG jump mixing_point_check_done;
84203996:	04 f0 a9 e0 	if NEG jump (m) $M.cbops.aec_ref_sidetone_op.mixing_point_check_done;

8420399a <$M.cbops.aec_ref_sidetone_op.reset_mixing_offset>:

reset_mixing_offset:
   /* reset mixing offset */
   r1 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_SET_THRESHOLD_FIELD];
8420399a:	93 f0 08 88 	r1 = M[r7 + 32];
   BUFFER_WORDS_TO_ADDRS_ASM(r1);
8420399e:	5b 5c       	r1 = r1 ASHIFT 2;
   M0 = r1;
842039a0:	18 0b       	M0 = r1 + Null;
   I0 = I6;
842039a2:	b0 0a       	I0 = I6 + Null;
   r1 = M[I0, M0];
842039a4:	30 f0 20 c0 	Null = Null + Null, r1 = M[I0,M0];

   // update debug counter showing mixing offset has been re-aligned
   r2 = I0 - r0;
842039a8:	2f f0 84 c6 	r2 = I0 - r0;
   if NEG r2 = r2 + L0;
842039ac:	c4 f4 44 c4 	if NEG r2 = r2 + L0;
   BUFFER_ADDRS_TO_WORDS_ASM(r2);
842039b0:	64 58       	r2 = r2 ASHIFT -2;
   r1 = M[r7+ $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_ALIGNED_SAMPLES_FIELD];
842039b2:	93 f0 0d 88 	r1 = M[r7 + 52];
   r1 = r1 + r2;
842039b6:	e3 00       	r1 = r2 + r1;
   M[r7+ $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_ALIGNED_SAMPLES_FIELD] = r1;
842039b8:	93 f0 0d 8e 	M[r7 + 52] = r1;

   // r0 = mixing offset updated
   r0 = I0;
842039bc:	82 08       	r0 = I0 + Null;

842039be <$M.cbops.aec_ref_sidetone_op.mixing_point_check_done>:
   // L0 = speaker buffer length
   // I6 = speaker buffer read address

   // work out the distance between HW read address and
   // mixing address in samples
   push B0;
842039be:	00 f2 3a cf 	push B0;
   pop r1;
842039c2:	00 f4 33 cf 	pop r1;
   r1 = r0 - I6;
842039c6:	6f f2 43 c6 	r1 = r0 - I6;
   if NEG r1 = r1 + L0;
842039ca:	c4 f3 43 c4 	if NEG r1 = r1 + L0;
   BUFFER_ADDRS_TO_WORDS_ASM(r1);
842039ce:	5b 58       	r1 = r1 ASHIFT -2;

   // get amount to mix
   r5 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.AMOUNT_TO_MIX_FIELD];
842039d0:	97 f0 0f 88 	r5 = M[r7 + 60];
   // r1 = distance before mixing
   // r3 = distance after mixing
   r3 = r5 + r1;
842039d4:	fd 00       	r3 = r5 + r1;

   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_THRESHOLD_FIELD];
842039d6:	92 f0 09 88 	r0 = M[r7 + 36];
   r1 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_LOW_FIELD];
842039da:	93 f0 06 88 	r1 = M[r7 + 24];
   r2 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_HIGH_FIELD];
842039de:	94 f0 07 88 	r2 = M[r7 + 28];
   r9 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_SET_THRESHOLD_FIELD];
842039e2:	9b f0 08 88 	r9 = M[r7 + 32];
   r1 = r0 + r1;   // low threshold after mixing
842039e6:	d3 00       	r1 = r0 + r1;
   r2 = r0 + r2;   // high threshold after mixing
842039e8:	14 01       	r2 = r0 + r2;
   r9 = r0 + r9;   // good threshold after mixing
842039ea:	13 0d       	r9 = r0 + r9;

   // r6 = samples to insert
   r6 = 0;
842039ec:	00 09       	r6 = Null + Null;

   // expect r1 < r3 < r2
   r0 = r1 - r3;
842039ee:	5a 05       	r0 = r1 - r3;
   if GT jump insert_sidetone;
842039f0:	0c 6a       	if GT jump (m) $M.cbops.aec_ref_sidetone_op.insert_sidetone;
   r0 = r3 - r2;
842039f2:	2a 05       	r0 = r3 - r2;
   if LE jump mix_sidetone;
842039f4:	12 6c       	if LE jump (m) $M.cbops.aec_ref_sidetone_op.mix_sidetone;

842039f6 <$M.cbops.aec_ref_sidetone_op.discard_sidetone>:

discard_sidetone:
   // discard here means ignore, we are doing in-place mixing
   // actual discard if needed will be done by sink_overflow_disgard operator
   r1 = r5 - r9;
842039f6:	bf f7 03 c2 	r1 = r5 - r9;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_DISCARDED_SAMPLES_FIELD];
842039fa:	92 f0 0a 88 	r0 = M[r7 + 40];
   r0 = r0 + r1;
842039fe:	9a 00       	r0 = r1 + r0;
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_DISCARDED_SAMPLES_FIELD] = r0;
84203a00:	92 f0 0a 8e 	M[r7 + 40] = r0;
   r5 = r9;
84203a04:	5f 08       	r5 = r9 + Null;
   jump mix_sidetone;
84203a06:	09 6e       	jump (m) $M.cbops.aec_ref_sidetone_op.mix_sidetone;

84203a08 <$M.cbops.aec_ref_sidetone_op.insert_sidetone>:

insert_sidetone:
   // we don't have enough samples to mix, we needs to mix
   // the difference, it will be mixing using last mixed sample
   r6 = r9 - r5;
84203a08:	7f fb 08 c2 	r6 = r9 - r5;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_INSERTED_SAMPLES_FIELD];
84203a0c:	92 f0 0b 88 	r0 = M[r7 + 44];
   r0 = r0 + r6;
84203a10:	42 0c       	r0 = r6 + r0;
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_INSERTED_SAMPLES_FIELD] = r0;
84203a12:	92 f0 0b 8e 	M[r7 + 44] = r0;
   r5 = r9;
84203a16:	5f 08       	r5 = r9 + Null;

84203a18 <$M.cbops.aec_ref_sidetone_op.mix_sidetone>:
mix_sidetone:

   // M0 = amount to adjust
   M0 = I0 - I7;
84203a18:	7f f0 c8 c7 	M0 = I0 - I7;
   if NEG M0 = M0 + L0;
84203a1c:	c4 f8 c8 c5 	if NEG M0 = M0 + L0;

   // get number of speakers (1 or 2)
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.NR_SPKRS_FIELD];
84203a20:	92 f0 02 88 	r0 = M[r7 + 8];
   M3 = r0;
84203a24:	13 0b       	M3 = r0 + Null;

   // mixing offset address
   I2 = r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_MIXING_OFFSETS_FIELD;
84203a26:	92 f8 0c 20 	I2 = r7 + 12;

   // Get sidetone buffer and see how much we need to read
   r0 = M[r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD];
84203a2a:	a2 f0 03 88 	r0 = M[r8 + 12];
   call $cbops.get_cbuffer;
84203a2e:	ff fd 8e f3 	call 0x7572c;
84203a32:	3e e7 
   I5 = r0;
84203a34:	15 0a       	I5 = r0 + Null;

   // see how much data is in sidetone buffer
   call $cbuffer.calc_amount_data_in_words;
84203a36:	ff fd b1 f1 	call (m) 0x39dd4;
84203a3a:	3f ec 
   r3 = r0;
84203a3c:	15 00       	r3 = r0 + Null;
   r0 = M[r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD];
84203a3e:	a2 f0 03 88 	r0 = M[r8 + 12];
   call $cbops.get_amount_ptr;
84203a42:	ff fd 8e f3 	call 0x7573c;
84203a46:	3a e7 
   r0 = M[r0];
84203a48:	12 e8       	r0 = M[r0 + Null];
   r0 = r0 + r3;
84203a4a:	aa 00       	r0 = r3 + r0;
   // r0: amount we have
   // r5: amount we need
   // r6: amount to invent
   r1 = r5 - r0;
84203a4c:	bb 04       	r1 = r5 - r0;
   if LE jump enough_data;
84203a4e:	03 6c       	if LE jump (m) $M.cbops.aec_ref_sidetone_op.enough_data;
      // Limit to amount available
      r5 = r5 - r1;
84203a50:	ff 04       	r5 = r5 - r1;
      r6 = r6 + r1;
84203a52:	18 0d       	r6 = r1 + r6;

84203a54 <$M.cbops.aec_ref_sidetone_op.enough_data>:
   enough_data:

   r0 = I5;
84203a54:	aa 08       	r0 = I5 + Null;
   call $cbuffer.get_read_address_and_size_and_start_address;
84203a56:	ff fd b4 f1 	call (m) 0x3a27a;
84203a5a:	25 e1 
   I7 = r0;
84203a5c:	17 0a       	I7 = r0 + Null;
   L4 = r1;
84203a5e:	1e 0b       	L4 = r1 + Null;
   push r2;
84203a60:	00 f0 34 cf 	push r2;
   pop B4;
84203a64:	00 f6 3c cf 	pop B4;

   // speaker buffers
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
84203a68:	92 f0 00 88 	r0 = M[r7 + 0];
   I3 = r0;
84203a6c:	13 0a       	I3 = r0 + Null;

84203a6e <$M.cbops.aec_ref_sidetone_op.channel_mixing_loop>:

channel_mixing_loop:

      // get base address for this speaker channel
      r0 = M[I3, MK1];
84203a6e:	2d f0 30 c0 	Null = Null + Null, r0 = M[I3,4];
      r0 = M[r0 + $cbuffer.START_ADDR_FIELD];
84203a72:	d2 88       	r0 = M[r0 + 12];
      push r0;
84203a74:	00 f0 32 cf 	push r0;
      pop B0;
84203a78:	00 f6 3a cf 	pop B0;

      // get sidetone buffer
      I4 = I7;
84203a7c:	bc 0a       	I4 = I7 + Null;

      // get speaker mixing point
      r0 = M[I2, 0];
84203a7e:	28 f0 30 c0 	Null = Null + Null, r0 = M[I2,0];
      I0 = r0;
84203a82:	10 0a       	I0 = r0 + Null;

      // M0 is amount to fix the mixing point (should be 0 in normal condition)
      r0 = M[I0, M0];
84203a84:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];

      // get last sidetone sample
      r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SIDETONE_SAMPLE_FIELD];
84203a88:	92 f0 0c 88 	r0 = M[r7 + 48];

      r2 = 1.0;
84203a8c:	ff f7 f4 f7 	r2 = Null + 2147483647;
84203a90:	ff 7b 

      // r5 = sidetone samples to read and mix
      // r6 = sidetone samples to invent and mix
      r10 = r6;
84203a92:	44 09       	r10 = r6 + Null;
      if Z jump insert_done;
84203a94:	08 60       	if EQ jump (m) $M.cbops.aec_ref_sidetone_op.insert_done;
      do insert_loop;
84203a96:	07 4c       	do (m) $M.cbops.aec_ref_sidetone_op.insert_done;
         rMAC = M[I0, 0];
84203a98:	10 f0 30 c0 	Null = Null + Null, rMAC = M[I0,0];
         rMAC = rMAC + r0 * r2;
84203a9c:	4f f2 c1 ca 	rMAC = rMAC + r0 * r2 (SS);
         M[I0, MK1] = rMAC;
84203aa0:	91 f0 30 c0 	Null = Null + Null, M[I0,4] = rMAC;

84203aa4 <$M.cbops.aec_ref_sidetone_op.insert_done>:
      insert_loop:

      insert_done:
      r10 = r5;
84203aa4:	3c 09       	r10 = r5 + Null;
      do mix_loop;
84203aa6:	07 4c       	do (m) $M.cbops.aec_ref_sidetone_op.mix_loop;
         rMAC = M[I0, 0], r0 = M[I4,MK1];
84203aa8:	21 f0 31 d0 	Null = Null + Null, rMAC = M[I0,0], r0 = M[I4,4];
         rMAC = rMAC + r0 * r2;
84203aac:	4f f2 c1 ca 	rMAC = rMAC + r0 * r2 (SS);
         M[I0, MK1] = rMAC;
84203ab0:	91 f0 30 c0 	Null = Null + Null, M[I0,4] = rMAC;

84203ab4 <$M.cbops.aec_ref_sidetone_op.mix_loop>:
      mix_loop:
      M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SIDETONE_SAMPLE_FIELD] = r0;
84203ab4:	92 f0 0c 8e 	M[r7 + 48] = r0;

      // update mixing point for next time
      r1 = I0;
84203ab8:	83 08       	r1 = I0 + Null;
      M[I2, MK1] = r1;
84203aba:	b9 f0 30 c0 	Null = Null + Null, M[I2,4] = r1;
   // next channel
   M3 = M3 - 1;
84203abe:	bb fc 01 24 	M3 = M3 - 1;
   if GT jump channel_mixing_loop;
84203ac2:	d6 6b       	if GT jump (m) $M.cbops.aec_ref_sidetone_op.channel_mixing_loop;

   // update sidetone buffer
   r0 = I5;
84203ac4:	aa 08       	r0 = I5 + Null;
   r1 = I4;
84203ac6:	a3 08       	r1 = I4 + Null;
   call $cbuffer.set_read_address;
84203ac8:	ff fd b4 f1 	call (m) 0x3a2e6;
84203acc:	3f e0 

   pop rlink;
84203ace:	00 f4 3d cf 	pop rLink;
   rts;
84203ad2:	d8 4c       	rts;

84203ad4 <$_aec_ref_sidetone_initialise>:
// TRASHED REGISTERS:
//    r0 (C callable)
//
// *****************************************************************************
$_aec_ref_sidetone_initialise:
   push rLink;
84203ad4:	00 f0 3d cf 	push rLink;
   pushm <I2,I3>;
84203ad8:	00 f0 4c e4 	pushm <I2, I3>;
   pushm <r1,r2,r3,r7>;
84203adc:	23 f0 48 e0 	pushm <r1, r2, r3, r7>;

   // here we got pointer to the cbops structure, so need to get to the
   // parameter struct first.
   r7 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
84203ae0:	29 f0 03 88 	r7 = M[r0 + 12];

   // save the read address of first speaker buffer, we use this to see how many
   // samples speaker has read since last run
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
84203ae4:	92 f0 00 88 	r0 = M[r7 + 0];
   r0 = M[r0];
84203ae8:	12 e8       	r0 = M[r0 + Null];
   call $cbuffer.get_read_address_and_size_and_start_address;
84203aea:	ff fd b3 f1 	call (m) 0x3a27a;
84203aee:	31 ec 

   /* initialise mixing points */
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SPKR_ADDR_FIELD] = r0;
84203af0:	92 f0 0e 8e 	M[r7 + 56] = r0;
   r10 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.NR_SPKRS_FIELD];
84203af4:	9c f0 02 88 	r10 = M[r7 + 8];
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
84203af8:	92 f0 00 88 	r0 = M[r7 + 0];
   I2 = r0;
84203afc:	12 0a       	I2 = r0 + Null;
   I3 = r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_MIXING_OFFSETS_FIELD;
84203afe:	93 f8 0c 20 	I3 = r7 + 12;
   do init_mixing_points;
84203b02:	06 4c       	do (m) $M.cbops.aec_ref_sidetone_op.init_mixing_points;
      r0 = M[I2, MK1];   // get speaker buffer
84203b04:	29 f0 30 c0 	Null = Null + Null, r0 = M[I2,4];
      r0 = M[r0 + $cbuffer.START_ADDR_FIELD];
84203b08:	d2 88       	r0 = M[r0 + 12];
      M[I3, MK1] = r0;   // mixing point
84203b0a:	ad f0 30 c0 	Null = Null + Null, M[I3,4] = r0;

84203b0e <$M.cbops.aec_ref_sidetone_op.init_mixing_points>:
   init_mixing_points:

   popm <r1,r2,r3,r7>;
84203b0e:	23 f0 68 e0 	popm <r1, r2, r3, r7>;
   popm <I2,I3>;
84203b12:	00 f0 6c e4 	popm <I2, I3>;
   pop rLink;
84203b16:	00 f4 3d cf 	pop rLink;
   rts;
84203b1a:	d8 4c       	rts;

84203b1c <$cbops.multichan_sidetone_mix_op.main>:
84203b1c:	00 f0 3d cf 	push rLink;
// *****************************************************************************
$cbops.multichan_sidetone_mix_op.main:
   // push rLink onto stack
   push rLink;

   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
84203b20:	a9 f0 00 88 	r7 = M[r8 + 0];

   // used throughout this function
   M1 = MK1;
84203b24:	21 73       	M1 = Null + 4;
   // Go through all sidetone buffers and and find minimum
   // amount of data among them.
   // Note: We could just look at first buffer since we expect
   // all sidetone buffers to be synchronised but this will
   // prevent failing in dramatic way if they aren't synced.
   r6 = 0x7FFF; // start with reasonably large value
84203b26:	38 f0 ff 7b 	r6 = Null + 32767;
   r10 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NR_ST_CHANNELS_FIELD];
84203b2a:	9c f0 04 88 	r10 = M[r7 + 16];
   I6 = r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.ST_IDXS_FIELD;
84203b2e:	96 f8 14 20 	I6 = r7 + 20;
   // r6: Minimum amount of data in sidetone buffers
   do sidetone_buffers_get_amount_loop;
84203b32:	0b 4c       	do (m) $M.cbops.sidetone_mix_op.sidetone_buffers_get_amount_loop;
      // Get buffer index for sidetone buffer
      r0 = M[I6, M1];
84203b34:	29 f0 20 d0 	Null = Null + Null, r0 = M[I6,M1];

      // get sidetone buffer
      call $cbops.get_cbuffer;
84203b38:	ff fd 8d f3 	call 0x7572c;
84203b3c:	34 ef 

      // get the amount of sidetone data
      call $cbuffer.calc_amount_data_in_words;
84203b3e:	ff fd b1 f1 	call (m) 0x39dd4;
84203b42:	37 e4 

      // r6 holds minimum data in all connected sidetone channels
      r6  = MIN r0;
84203b44:	5f f2 48 ce 	r6 = MIN r0;

84203b48 <$M.cbops.sidetone_mix_op.sidetone_buffers_get_amount_loop>:
  sidetone_buffers_get_amount_loop:

   // Get transfer amount from input to output
   //  r0: transfer amount in samples
   //  r9: offset to output channels in addrs (from the start of index table)
   call $cbops.get_transfer_and_update_multi_channel;
84203b48:	ff fd 8d f3 	call 0x7568c;
84203b4c:	24 ea 

   // M3: amount of sidetone to invent this run
   //     if sidetone buffers don't have enough data.
   M3 = r0 - r6;
84203b4e:	8f f2 0b c7 	M3 = r0 - r6;
   if NEG M3 = 0;
84203b52:	04 f0 0b c5 	if NEG M3 = Null + Null;

   // update insert counter
   r1 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NUM_INSERTS_FIELD];
84203b56:	93 f0 01 88 	r1 = M[r7 + 4];
   r1 = r1 + M3;
84203b5a:	db 0c       	r1 = M3 + r1;
   M[r7 +  $cbops_sidetone_mix_op.multichan_st_mix_struct.NUM_INSERTS_FIELD]=r1;
84203b5c:	93 f0 01 8e 	M[r7 + 4] = r1;

   // M2: Amount of real sidetone that will be mixed this run
   M2 = r0 - M3;
84203b60:	bf f2 4a c7 	M2 = r0 - M3;

   // If amount of sidetone after transfer is > 2*SIDETONE_MAX_SAMPLES_FIELD
   // drop sidetone to leave SIDETONE_MAX_SAMPLES_FIELD samples
   // r5 is amount to drop
   r1 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.MAX_SAMPLES_FIELD];
84203b64:	93 f0 00 88 	r1 = M[r7 + 0];
   r0 = r6 - r0;    //Amount remaining sidetone samples in the buffers after mix
84203b68:	2f f8 02 c2 	r0 = r6 - r0;
   r5 = r0 - r1;    // remaining sidetone samples - SIDETONE_MAX_SAMPLES_FIELD
84203b6c:	d7 04       	r5 = r0 - r1;
   NULL = r5 - r1;
84203b6e:	f8 04       	Null = r5 - r1;
   if NEG r5 = NULL; // remaining data < 2*SIDETONE_MAX_SAMPLES_FIELD (no drop)
84203b70:	04 f0 07 c0 	if NEG r5 = Null + Null;

   // r5 sidetone samples are dropped to control latency, update the accumulator
   r2 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NUM_DROPS_FIELD];
84203b74:	94 f0 02 88 	r2 = M[r7 + 8];
   r2 = r2 + r5;
84203b78:	3c 01       	r2 = r5 + r2;
   M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NUM_DROPS_FIELD]=r2;
84203b7a:	94 f0 02 8e 	M[r7 + 8] = r2;

   // Total sidetone samples consumed =
   //   M2: mixed sidetone samples +
   //   r5: dropped sidetone samples
   r5 = M2 + r5;
84203b7e:	d7 0c       	r5 = M2 + r5;

   // Go through all sidetone buffers and
   // update transfer amount (=r5)
   r10 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NR_ST_CHANNELS_FIELD];
84203b80:	9c f0 04 88 	r10 = M[r7 + 16];
   I6 = r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.ST_IDXS_FIELD;
84203b84:	96 f8 14 20 	I6 = r7 + 20;
   do sidetone_buffers_update_transfer_amount_loop;
84203b88:	07 4c       	do (m) $M.cbops.sidetone_mix_op.sidetone_buffers_update_transfer_amount_loop;
      r0 = M[I6, M1];
84203b8a:	29 f0 20 d0 	Null = Null + Null, r0 = M[I6,M1];
      call $cbops.get_amount_ptr;
84203b8e:	ff fd 8d f3 	call 0x7573c;
84203b92:	2e ed 
      M[r0] = r5;
84203b94:	87 ee       	M[Null + r0] = r5;

84203b96 <$M.cbops.sidetone_mix_op.sidetone_buffers_update_transfer_amount_loop>:
   sidetone_buffers_update_transfer_amount_loop:

   // see if we have something to transfer
   // from input to output
   NULL = M2 + M3;
84203b96:	bf fa c0 c4 	Null = M2 + M3;
   if LE jump all_done;
84203b9a:	6c 6c       	if LE jump (m) $M.cbops.sidetone_mix_op.all_done;

   // set M0 to number of channels
   r0 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NR_CHANNELS_FIELD];
84203b9c:	92 f0 03 88 	r0 = M[r7 + 12];
   M0 = r0;
84203ba0:	10 0b       	M0 = r0 + Null;

   // set I6 to sidetone map indexes
   r0 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NR_ST_CHANNELS_FIELD];
84203ba2:	92 f0 04 88 	r0 = M[r7 + 16];
   Words2Addr(r0);
84203ba6:	52 5c       	r0 = r0 ASHIFT 2;
   I6 = r7 +  $cbops_sidetone_mix_op.multichan_st_mix_struct.ST_IDXS_FIELD;
84203ba8:	96 f8 14 20 	I6 = r7 + 20;
   I6 = I6 + r0;
84203bac:	16 0e       	I6 = r0 + I6;

   // set I2 to input indexes
   I2 = r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD;
84203bae:	a2 f8 0c 20 	I2 = r8 + 12;

   // set I3 to output indexes
   I3 = I2 + r9;
84203bb2:	bf f2 83 c5 	I3 = I2 + r9;

   // Sidetone attenuation (0dB)
   r5 = 1.0;
84203bb6:	ff f7 f7 f7 	r5 = Null + 2147483647;
84203bba:	ff 7b 

84203bbc <$M.cbops.sidetone_mix_op.transfer_and_sidetone_mix_channel_loop>:

   transfer_and_sidetone_mix_channel_loop:
      // get input, output and sidetone indexes
      // for this channel
      r0 = M[I6, M1];          // get sidetone index
84203bbc:	29 f0 20 d0 	Null = Null + Null, r0 = M[I6,M1];
      r7 = r0, r0 = M[I3, M1]; // get output index
84203bc0:	2d f0 0f f2 	r7 = r0 + Null, r0 = M[I3,M1];
84203bc4:	09 c0 
      r3 = r0, r0 = M[I2, M1]; // get input index
84203bc6:	29 f0 0f f2 	r3 = r0 + Null, r0 = M[I2,M1];
84203bca:	05 c0 
      I7 = r3 - r0;
84203bcc:	2f f5 07 c7 	I7 = r3 - r0;
      // r3 = output index
      // r0 = input index
      // I7 = output index - input index (useful to skip transfer only)

      // Setup Input Buffer
      call $cbops.get_buffer_address_and_length;
84203bd0:	ff fd 8d f3 	call 0x756c0;
84203bd4:	30 e7 
      I0 = r0;
84203bd6:	10 0a       	I0 = r0 + Null;
      if Z jump transfer_and_sidetone_mix_next_channel;
84203bd8:	3f 60       	if EQ jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
      L0 = r1;
84203bda:	1c 0b       	L0 = r1 + Null;
      push r2;
84203bdc:	00 f0 34 cf 	push r2;
      pop B0;
84203be0:	00 f6 3a cf 	pop B0;

      // Setup Output Buffer
      r0 = r3;
84203be4:	2a 00       	r0 = r3 + Null;
      call $cbops.get_buffer_address_and_length;
84203be6:	ff fd 8d f3 	call 0x756c0;
84203bea:	3a e6 
      I4 = r0;
84203bec:	14 0a       	I4 = r0 + Null;
      if Z jump transfer_and_sidetone_mix_next_channel;
84203bee:	34 60       	if EQ jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
      L4 = r1;
84203bf0:	1e 0b       	L4 = r1 + Null;
      push r2;
84203bf2:	00 f0 34 cf 	push r2;
      pop B4;
84203bf6:	00 f6 3c cf 	pop B4;

      // setup sidetone buffer
      r0 = r7;
84203bfa:	4a 08       	r0 = r7 + Null;
      // if not mapped to any sidetone buffer just
      // simple transfer from input to output
      if NEG jump just_transfer_input_to_output;
84203bfc:	04 f0 c9 e0 	if NEG jump (m) $M.cbops.sidetone_mix_op.just_transfer_input_to_output;
      call $cbops.get_buffer_address_and_length;
84203c00:	ff fd 8d f3 	call 0x756c0;
84203c04:	20 e6 
      push r2;
84203c06:	00 f0 34 cf 	push r2;
      pop B1;
84203c0a:	00 f6 3b cf 	pop B1;
      // set the length & get the first input sample
      I1 = r0;
84203c0e:	11 0a       	I1 = r0 + Null;
      L1 = r1, rMAC = M[I0,M1];
84203c10:	11 f0 3f f0 	L1 = Null + r1, rMAC = M[I0,M1];
84203c14:	0d c5 
      // I1/L1/B1 = Sidetone buffer
      // I0/L0/B0 = Input buffer
      // I4/L4/B4 = Output buffer

      // Mixing loop
      r10 = M2;
84203c16:	d4 09       	r10 = M2 + Null;
      do mix_real_sidetone_loop;
84203c18:	07 4c       	do (m) $M.cbops.sidetone_mix_op.mix_real_sidetone_loop;
         // calculate the current output sample and read a side tone sample
         r0 = M[I1,M1];
84203c1a:	25 f0 20 c0 	Null = Null + Null, r0 = M[I1,M1];
         rMAC = rMAC + r0 * r5;
84203c1e:	7f f2 c1 ca 	rMAC = rMAC + r0 * r5 (SS);

         // get the next input value and write current output
         rMAC = M[I0,M1], M[I4,M1] = rMAC;
84203c22:	91 f1 21 d0 	Null = Null + Null, rMAC = M[I0,M1], M[I4,M1] = rMAC;

84203c26 <$M.cbops.sidetone_mix_op.mix_real_sidetone_loop>:
      mix_real_sidetone_loop:

      // continue only of we need to invent sidetone samples
      r10 = M3;
84203c26:	dc 09       	r10 = M3 + Null;
      if Z jump transfer_and_sidetone_mix_next_channel;
84203c28:	17 60       	if EQ jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
      // Repeat Last sample of sidetone buffer (insert sidetone samples)
      r0 = M[I1,-MK1];
84203c2a:	27 f0 30 c0 	Null = Null + Null, r0 = M[I1,-4];
      r0 = M[I1,M1];
84203c2e:	25 f0 20 c0 	Null = Null + Null, r0 = M[I1,M1];
      // Ensure sidetone is connected repeat last sample, else mix silence
      NULL = r6;
84203c32:	40 08       	Null = r6 + Null;
      if Z r0=NULL;
84203c34:	00 f0 02 c0 	if EQ r0 = Null + Null;
      do mix_invented_sidetone_loop;
84203c38:	05 4c       	do (m) $M.cbops.sidetone_mix_op.mix_invented_sidetone_loop;
         // calculate the current output sample
         rMAC = rMAC + r0 * r5;
84203c3a:	7f f2 c1 ca 	rMAC = rMAC + r0 * r5 (SS);
         // get the next input value and write the result
         rMAC = M[I0,M1], M[I4,M1] = rMAC;
84203c3e:	91 f1 21 d0 	Null = Null + Null, rMAC = M[I0,M1], M[I4,M1] = rMAC;

84203c42 <$M.cbops.sidetone_mix_op.mix_invented_sidetone_loop>:
      mix_invented_sidetone_loop:
      jump transfer_and_sidetone_mix_next_channel;
84203c42:	0a 6e       	jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;

84203c44 <$M.cbops.sidetone_mix_op.just_transfer_input_to_output>:

      just_transfer_input_to_output:
      NULL = I7; // if output index == input index then skip transfer
84203c44:	b8 08       	Null = I7 + Null;
      if Z jump transfer_and_sidetone_mix_next_channel;
84203c46:	08 60       	if EQ jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
      r10 = M2 + M3;
84203c48:	bf fa cc c4 	r10 = M2 + M3;
      do just_transfer_loop;
84203c4c:	05 4c       	do (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
         r0 = M[I0,M1];
84203c4e:	21 f0 20 c0 	Null = Null + Null, r0 = M[I0,M1];
         M[I4,M1] = r0;
84203c52:	a1 f0 20 d0 	Null = Null + Null, M[I4,M1] = r0;

84203c56 <$M.cbops.sidetone_mix_op.just_transfer_loop>:
      just_transfer_loop:
   transfer_and_sidetone_mix_next_channel:
   M0 = M0 - 1;
84203c56:	88 fc 01 24 	M0 = M0 - 1;
   if NZ jump transfer_and_sidetone_mix_channel_loop;
84203c5a:	b1 63       	if NE jump (m) $M.cbops.sidetone_mix_op.transfer_and_sidetone_mix_channel_loop;

   // zero the remaining length registers we have used
   L0 = 0;
84203c5c:	04 0b       	L0 = Null + Null;
   L4 = 0;
84203c5e:	06 0b       	L4 = Null + Null;
   L1 = 0;
84203c60:	05 0b       	L1 = Null + Null;
   push Null;
84203c62:	00 f0 30 cf 	push Null;
   B0 = M[SP - 1*ADDR_PER_WORD];
84203c66:	fe fa 1a cf 	B0 = M[SP + -0x4];
   B1 = M[SP - 1*ADDR_PER_WORD];
84203c6a:	fe fa 1b cf 	B1 = M[SP + -0x4];
   pop B4;
84203c6e:	00 f6 3c cf 	pop B4;

84203c72 <$M.cbops.sidetone_mix_op.all_done>:
all_done:
   // pop rLink from stack
   pop rLink;
84203c72:	00 f4 3d cf 	pop rLink;
   rts;
84203c76:	d8 4c       	rts;
