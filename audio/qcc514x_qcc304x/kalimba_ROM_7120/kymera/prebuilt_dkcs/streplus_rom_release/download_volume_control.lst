
/home/svc-audio-dspsw/kymera_builds/builds/2020/kymera_2005191628/kalimba/kymera/tools/KCSMaker/out/7120/streplus_rom_release/download/debugbin/download_volume_control.elf:     file format elf32-littlekalimba

Disassembly of section .text_maxim:

84200000 <$_vol_ctrl_update_channel>:
.MODULE $M.vol_ctrl_update_channel;
    .MAXIM;
    .CODESEGMENT VOL_CTRL_UPD_CHAN_PM;

$_vol_ctrl_update_channel:
    pushm <r4,r5,r6,r7,r8,r9>;
84200000:	c0 0f 00 f1 	pushm <r4, r5, r6, r7, r8, r9>;
    pushm <I0,I1,I4,I5,M3,L0,L4,L5>;
84200004:	33 d8 01 f1 	pushm <I0, I1, I4, I5, M3, L0, L4, L5>;
    pushm <B0,B4,B5>;
84200008:	00 34 02 f1 	pushm <B0, B4, B5>;
    pushm <FP(=SP),r0,r1,r2,r3,rLink>;
8420000c:	3d 20 00 f1 	pushm <FP(=SP), r0, r1, r2, r3, rLink>;

   LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($vol_ctrl_update_channel.PATCH_ID_0, r7)

    /* Number of channels */
    r7 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.NUM_CHANNELS_FIELD];
84200010:	5c 00 92 d1 	r7 = M[r0 + 92];
    if LE jump vol_ctrl_apply_volume_abort;
84200014:	72 01 d0 dd 	if LE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_abort;

    // Enable saturate on add/sub
    r4 = M[$ARITHMETIC_MODE];
84200018:	14 e0 60 09 	r4 = Null + M[0xffffe014];
    push r4;
8420001c:	00 00 60 f3 	push r4;
    r4 = r4 OR $ADDSUB_SATURATE_ON_OVERFLOW_MASK;
84200020:	01 00 66 85 	r4 = r4 OR 0x1;
    M[$ARITHMETIC_MODE] = r4;
84200024:	14 e0 60 19 	M[0xffffe014] = r4 + Null;


    /* Update Channel for AUX stream priority.   */
    /* op_extra_data->aux_in_use  = 0; */
    M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_IN_USE_FIELD] = NULL;
84200028:	e8 02 02 d5 	M[r0 + 744] = Null;

8420002c <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_next>:
        {
            vol_ctrl_update_channel(op_extra_data,&op_extra_data->channels[i],op_extra_data->lpvols,&volume_tc);
        }
    */
vol_ctrl_update_channel_next:
    push r7;
8420002c:	00 00 90 f3 	push r7;
// r1: vol_ctrl_channel_t   *chan_ptr
// r2: vol_ctrl_gains_t     *volptr
// r3: vol_time_constants_t *lpvcs


    r4 = 1.0;
84200030:	ff 7f 00 fd 	r4 = Null + 2147483647;
84200034:	ff ff 60 01 
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMITER_GAIN_LINEAR_FIELD]=r4;
84200038:	10 00 63 d5 	M[r1 + 16] = r4;
    // chan_idx
    r4 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
8420003c:	00 00 63 d1 	r4 = M[r1 + 0];
    // target_vol (r5) = volptr->master_gain;
    r5 = M[r2 + $volume_control_cap.vol_ctrl_gains_struct.MASTER_GAIN_FIELD];
84200040:	00 00 74 d1 	r5 = M[r2 + 0];
    // channel_trim (r6) = volptr->channel_trims[chan_ptr->chan_idx];
    r6 = r4 * ADDR_PER_WORD (int);
84200044:	04 00 86 99 	r6 = r4 * 4 (int);
    r6 = r6 + $volume_control_cap.vol_ctrl_gains_struct.CHANNEL_TRIMS_FIELD;
84200048:	28 00 88 01 	r6 = r6 + 40;
    r6 = M[r2 + r6];
8420004c:	8f 00 84 d0 	r6 = M[r2 + r6];
    // chan_params (r7) = (vol_ctrl_chan_params_t*)&op_extra_data->parameters.OFFSET_CHAN1_AUX_ROUTE;
    // aux_routing (r9) = chan_params[chan_ptr->chan_idx].aux_routing;
    r8 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CHAN1_AUX_ROUTE_FIELD);
84200050:	f4 01 a2 01 	r8 = r0 + 500;
    r7 = r4 * ($volume_control_cap.vol_ctrl_chan_params_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200054:	14 00 96 99 	r7 = r4 * 20 (int);
    r7 = r7 + r8;
84200058:	00 00 9a 03 	r7 = r7 + r8;
    r9 = M[r7 + $volume_control_cap.vol_ctrl_chan_params_struct.AUX_ROUTING_FIELD];
8420005c:	00 00 b9 d1 	r9 = M[r7 + 0];
    // Pointer (I0) to Channel Aux prim_scale factors
    I0 = r7 + $volume_control_cap.vol_ctrl_chan_params_struct.PRIM_SCALE_FIELD;
84200060:	04 00 09 51 	I0 = r7 + 4;

    // Conditionally add in NDVC adjustment
    NULL = r9 AND $M.VOL_CTRL.CONSTANT.CHAN_NDVC_ENABLE_BIT;
84200064:	10 00 00 fd 	Null = r9 AND 0x100000;
84200068:	00 00 0b 81 
    if Z jump vol_ctrl_update_channel_no_ndvc;
8420006c:	05 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_ndvc;
        r8 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.SHARED_VOLUME_PTR_FIELD];
84200070:	8c 01 a2 d1 	r8 = M[r0 + 396];
        r8 = M[r8 + $volume_control_cap._shared_volume_struct.NDVC_NOISE_LEVEL_FIELD];
84200074:	00 00 aa d1 	r8 = M[r8 + 0];
	    /* NDVC is in 3dB steps */
        r8 = r8 * 180 (int);
84200078:	b4 00 aa 99 	r8 = r8 * 180 (int);
        r6 = r6 + r8;
8420007c:	00 00 8a 03 	r6 = r6 + r8;

84200080 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_ndvc>:
    vol_ctrl_update_channel_no_ndvc:

   /* Bypass Aux */
   NULL = M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_ACTIVE_FIELD];
84200080:	e0 02 02 d1 	Null = M[r0 + 736];
   if Z r9 = NULL;
84200084:	00 00 b0 00 	if EQ r9 = Null + Null;

    // channel_trim -= op_extra_data->post_gain;
    r8 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.POST_GAIN_FIELD];
84200088:	f4 00 a2 d1 	r8 = M[r0 + 244];
    r6 = r6 - r8;
8420008c:	00 00 8a 23 	r6 = r6 - r8;
    // target_vol = dB60toLinearQ5(target_vol+channel_trim);
    r0 = r6 + r5;
84200090:	7f 00 28 00 	r0 = r6 + r5;
    call $_dB60toLinearQ5;
84200094:	03 00 00 fd 	call (m) 0x37fbe;
84200098:	bf 7f f0 e1 

    // Update Channel Gain (r0 is target)
    r1 = M[FP + $vol_ctrl.cufp.chan_ptr];
8420009c:	08 00 38 f1 	r1 = M[FP + 0x8];
    r2 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD];
842000a0:	18 00 43 d1 	r2 = M[r1 + 24];

    r3 = M[FP + $vol_ctrl.cufp.tc_ptr];
842000a4:	10 00 58 f1 	r3 = M[FP + 0x10];
    r3 = M[r3 + $volume_control_cap.vol_time_constants_struct.VOL_TC_FIELD];
842000a8:	04 00 55 d1 	r3 = M[r3 + 4];

    r8 = r0 - r2;
842000ac:	4f 00 a2 20 	r8 = r0 - r2;
    if Z jump vol_ctrl_update_channel_no_vol_change;
842000b0:	09 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_vol_change;
        r8 = ABS r8;
842000b4:	4f 00 aa e4 	r8 = ABS r8;
        r3 = r2 * r3 (frac);
842000b8:	5f 00 54 94 	r3 = r2 * r3 (frac);
        r3 = r3 + $volume_and_limit.VOLUME_RAMP_OFFSET_CONST;
842000bc:	6e 34 55 01 	r3 = r3 + 13422;
        r3 = MIN r8;
842000c0:	5f 00 5a e4 	r3 = MIN r8;
        Null = r0 - r2;
842000c4:	4f 00 02 20 	Null = r0 - r2;
        if NEG r3 = -r3;
842000c8:	54 00 50 20 	if NEG r3 = Null - r3;
        r2 = r2 + r3;
842000cc:	00 00 45 03 	r2 = r2 + r3;
        M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD] = r2;
842000d0:	18 00 43 d5 	M[r1 + 24] = r2;

842000d4 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_vol_change>:
    vol_ctrl_update_channel_no_vol_change:

     r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
842000d4:	04 00 28 f1 	r0 = M[FP + 0x4];
     r0 = r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
842000d8:	6c 00 22 01 	r0 = r0 + 108;

// r9=routing, r1=chan_ptr, I0=prim_scale, r0=aux_chan_ptr, r6=chan_trim, r4=chan_idx

    /* Check each aux in channel priority */
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_MIX_GAIN_FIELD]  = NULL;
842000dc:	04 00 03 d5 	M[r1 + 4] = Null;
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_BUFFER_FIELD]    = NULL;
842000e0:	20 00 03 d5 	M[r1 + 32] = Null;

842000e4 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_lp>:

    // while(aux_routing&VOL_CTRL_CONSTANT_AUX_PRIORITY_VALID_BIT)
vol_ctrl_update_channel_aux_prio_lp:
    NULL = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_VALID_BIT;
842000e4:	10 00 0b 81 	Null = r9 AND 0x10;
    if NZ jump vol_ctrl_update_channel_aux_prio_valid;
842000e8:	05 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_valid;
        // There is no AUX
        r2 = $volume_and_limit.OneQ5;
842000ec:	00 08 00 fd 	r2 = Null + 134217728;
842000f0:	00 00 40 01 
        M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD]      = r2;
842000f4:	08 00 43 d5 	M[r1 + 8] = r2;
        jump vol_ctrl_update_channel_aux_prio_done;
842000f8:	37 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done;

842000fc <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_valid>:
vol_ctrl_update_channel_aux_prio_valid:
        // aux_idx =  aux_routing&VOL_CTRL_CONSTANT_AUX_PRIORITY_CHANNEL_MASK;
        r5 = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_CHANNEL_MASK;
842000fc:	07 00 7b 81 	r5 = r9 AND 0x7;
        // op_extra_data->aux_channel[aux_idx].state
        r8 = r5 * ($volume_control_cap.vol_ctrl_aux_channel_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200100:	10 00 a7 99 	r8 = r5 * 16 (int);
        r8 = r8 + r0,   r3=M[I0,M1];    // r3 = prim_scale
84200104:	00 51 a2 02 	r8 = r8 + r0, r3 = M[I0,M1];
        r7 = M[r8 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
84200108:	04 00 9a d1 	r7 = M[r8 + 4];
        if NZ jump vol_ctrl_update_channel_aux_prio_found;
8420010c:	03 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_found;
            // NO_AUX, Try Next entry
            r9 = r9 LSHIFT -$M.VOL_CTRL.CONSTANT.AUX_PRIORITY_NUM_BITS;
84200110:	fb 00 bb 8d 	r9 = r9 LSHIFT -5;
            jump vol_ctrl_update_channel_aux_prio_lp;
84200114:	f4 ff f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_lp;

84200118 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_found>:
vol_ctrl_update_channel_aux_prio_found:
        NULL = r7 - $volume_control_cap.AUX_STATE_IN_AUX;
84200118:	cf 00 09 e4 	Null = r7 - 2;
        if Z jump vol_ctrl_update_channel_aux_prio_in_aux;
8420011c:	16 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_in_aux;
    	    r2 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD];
84200120:	08 00 43 d1 	r2 = M[r1 + 8];

            NULL = r7 - $volume_control_cap.AUX_STATE_END_AUX;
84200124:	03 00 09 21 	Null = r7 - 3;
            if NZ jump vol_ctrl_update_channel_aux_prio_transition;
84200128:	0d 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_transition;
                // Leaving AUX mix,  see if a lower priority aux is pending
                r3 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD];
8420012c:	08 00 53 d1 	r3 = M[r1 + 8];

84200130 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_lp>:
                vol_ctrl_update_channel_aux_prio_prev_lp:
                    r9 = r9 LSHIFT -$M.VOL_CTRL.CONSTANT.AUX_PRIORITY_NUM_BITS;
84200130:	fb 00 bb 8d 	r9 = r9 LSHIFT -5;
                    NULL = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_VALID_BIT;
84200134:	10 00 0b 81 	Null = r9 AND 0x10;
                    if Z jump vol_ctrl_update_channel_aux_prio_prev_none;
84200138:	07 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_none;
                        r5 = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_CHANNEL_MASK;
8420013c:	07 00 7b 81 	r5 = r9 AND 0x7;
                        r5 = r5 * ($volume_control_cap.vol_ctrl_aux_channel_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200140:	10 00 77 99 	r5 = r5 * 16 (int);
                        r5 = r5 + r0,   r2=M[I0,M1];    // r3 = prim_scale
84200144:	00 41 72 02 	r5 = r5 + r0, r2 = M[I0,M1];
                        r7 = M[r5 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
84200148:	04 00 97 d1 	r7 = M[r5 + 4];
                        if Z jump vol_ctrl_update_channel_aux_prio_prev_lp;
8420014c:	f9 ff 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_lp;
                        jump vol_ctrl_update_channel_aux_prio_transition;
84200150:	03 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_transition;

84200154 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_none>:
                vol_ctrl_update_channel_aux_prio_prev_none:
                r2 = $volume_and_limit.OneQ5;
84200154:	00 08 00 fd 	r2 = Null + 134217728;
84200158:	00 00 40 01 

8420015c <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_transition>:

            vol_ctrl_update_channel_aux_prio_transition:
            // transition = op_extra_data->aux_channel[aux_idx].transition;
            r7 = M[r8 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD];
8420015c:	08 00 9a d1 	r7 = M[r8 + 8];
            // chan_ptr->prim_mix_gain = (MAXINT-transition)*Q5.xx + chan_params->prim_scale[chan_ptr->chan_idx]*transition;
            rMAC = r2;              // r2=1.0  Q5.xx
84200160:	0f 00 14 00 	rMAC = r2 + Null;
            rmAC = rMAC - r7*r2;
84200164:	4f 00 19 bc 	rMAC = rMAC - r7 * r2 (SS);
            rMAC = rMAC + r7*r3;
84200168:	5f 00 19 ac 	rMAC = rMAC + r7 * r3 (SS);
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD] = rMAC;
8420016c:	08 00 13 d5 	M[r1 + 8] = rMAC;
            jump vol_ctrl_update_channel_aux_prio_done;
84200170:	19 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done;

84200174 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_in_aux>:
        vol_ctrl_update_channel_aux_prio_in_aux:
            // Transition is complete, in aux
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD] = r3;
84200174:	08 00 53 d5 	M[r1 + 8] = r3;

            // Check if aux mix not muted
            NULL = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_MUTE_BIT;
84200178:	08 00 0b 81 	Null = r9 AND 0x8;
            if NZ jump vol_ctrl_update_channel_aux_prio_done;
8420017c:	16 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done;
            // chan_ptr->aux_buffer       = op_extra_data->aux_channel[aux_idx].buffer;
            r7 = M[r8 + $volume_control_cap.vol_ctrl_aux_channel_struct.BUFFER_FIELD];
84200180:	00 00 9a d1 	r7 = M[r8 + 0];
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_BUFFER_FIELD] = r7;
84200184:	20 00 93 d5 	M[r1 + 32] = r7;

            // r5=aux_idx, r1=chan_ptr, r6=chan_trim, r4 = chan_idx
            r0 = M[FP+$vol_ctrl.cufp.op_data_ptr];
84200188:	04 00 28 f1 	r0 = M[FP + 0x4];

            // aux_in_use |= (1<<aux_idx);
            r2 = 1 LSHIFT r5;
8420018c:	01 00 47 e9 	r2 = 0x1 LSHIFT r5;
            r3 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_IN_USE_FIELD];
84200190:	e8 02 52 d1 	r3 = M[r0 + 744];
            r3 = r3 OR r2;
84200194:	00 00 54 87 	r3 = r3 OR r2;
            M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_IN_USE_FIELD]=r3;
84200198:	e8 02 52 d5 	M[r0 + 744] = r3;

            // aux_params = (vol_ctrl_aux_params_t*)&op_extra_data->parameters.OFFSET_AUX1_SCALE;
            // aux_volume = aux_params[aux_idx].aux_scale;
            r0 = M[FP+$vol_ctrl.cufp.op_data_ptr];
8420019c:	04 00 28 f1 	r0 = M[FP + 0x4];
            r0 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD+$volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_AUX1_SCALE_FIELD);
842001a0:	94 01 22 01 	r0 = r0 + 404;
            r2 = r5 * ($volume_control_cap.vol_ctrl_aux_params_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
842001a4:	0c 00 47 99 	r2 = r5 * 12 (int);
            r0 = M[r0 + r2];
842001a8:	00 00 24 d3 	r0 = M[r0 + r2];
            // aux_volume += op_extra_data->lpvols->auxiliary_gain[aux_idx];
            r3 = M[FP + $vol_ctrl.cufp.vol_ptr];
842001ac:	0c 00 58 f1 	r3 = M[FP + 0xc];
            r2 = r5 * ADDR_PER_WORD (int);
842001b0:	04 00 47 99 	r2 = r5 * 4 (int);
            r3 = r3 + r2;
842001b4:	00 00 54 03 	r3 = r3 + r2;
            r3 = M[r3 + $volume_control_cap.vol_ctrl_gains_struct.AUXILIARY_GAIN_FIELD];
842001b8:	08 00 55 d1 	r3 = M[r3 + 8];
            r0 = r0 + r3;
842001bc:	00 00 25 03 	r0 = r0 + r3;
            // chan_ptr->aux_mix_gain  = dB60toLinearQ5(aux_volume+channel_trim);
            r0 = r0 + r6;
842001c0:	00 00 28 03 	r0 = r0 + r6;
            call $_dB60toLinearQ5;
842001c4:	03 00 00 fd 	call (m) 0x37fbe;
842001c8:	bf 7f f0 e1 
            r1 = M[FP + $vol_ctrl.cufp.chan_ptr];
842001cc:	08 00 38 f1 	r1 = M[FP + 0x8];
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_MIX_GAIN_FIELD]  = r0;
842001d0:	04 00 23 d5 	M[r1 + 4] = r0;

842001d4 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done>:

vol_ctrl_update_channel_aux_prio_done:

    r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
842001d4:	04 00 28 f1 	r0 = M[FP + 0x4];

    // r4=chan_idx, r0=op_data_ptr

    // limiter_attn = 0;
    r5 = NULL;
842001d8:	0f 00 70 00 	r5 = Null + Null;

    r1 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD+$volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CONFIG_FIELD)];
842001dc:	90 01 32 d1 	r1 = M[r0 + 400];
    NULL = r1 AND $M.VOL_CTRL.CONFIG.SATURATEENA;
842001e0:	02 00 03 81 	Null = r1 AND 0x2;
    if Z jump vol_ctrl_update_channel_sat_done;
842001e4:	29 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done;
    r7 = M[FP + $vol_ctrl.cufp.chan_ptr];
842001e8:	08 00 98 f1 	r7 = M[FP + 0x8];
    r8 = M[r7 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD];
842001ec:	18 00 a9 d1 	r8 = M[r7 + 24];
    NULL = r8 - $volume_and_limit.MIN_POSITIVE_VOLUME;
842001f0:	00 08 00 fd 	Null = r8 - 134217728;
842001f4:	00 00 0a 21 
    if LE jump vol_ctrl_update_channel_sat_done;
842001f8:	24 00 d0 dd 	if LE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done;

        // Get Data Buffer
        r6 = r4 * ADDR_PER_WORD (int);
842001fc:	04 00 86 99 	r6 = r4 * 4 (int);
        r6 = r6 + $volume_control_cap._vol_ctrl_data_struct.INPUT_BUFFER_FIELD;
84200200:	00 00 88 01 	r6 = r6 + 0;
        r0 = M[r0 + r6];
84200204:	00 00 28 d3 	r0 = M[r0 + r6];
        call $cbuffer.get_read_address_and_size_and_start_address;
84200208:	03 00 00 fd 	call (m) 0x3a27a;
8420020c:	7b a2 f0 e1 
        I0 = r0;
84200210:	2f 00 00 50 	I0 = Null + r0;
        L0 = r1;
84200214:	3f 00 c0 50 	L0 = Null + r1;
        push r2;
84200218:	00 00 40 f3 	push r2;
        pop B0;
8420021c:	00 00 a6 f3 	pop B0;

        // Compute Peak
        r3 = M[FP + $vol_ctrl.cufp.tc_ptr];
84200220:	10 00 58 f1 	r3 = M[FP + 0x10];
        r10 = M[r3+$volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
84200224:	00 00 c5 d1 	r10 = M[r3 + 0];
        r2 = M[r3+$volume_control_cap.vol_time_constants_struct.SAT_TCP5_FIELD];
84200228:	0c 00 45 d1 	r2 = M[r3 + 12];
        r3 = M[r7 + $volume_control_cap.vol_ctrl_channel_struct.LAST_PEAK_FIELD];
8420022c:	14 00 59 d1 	r3 = M[r7 + 20];
        r10 = r10 - 1;
84200230:	3f 00 cc e4 	r10 = r10 - 1;
        // Use history for peak but decay it based on num samples
        r3 = r3 * r2 (frac), r2=M[I0,M1];
84200234:	00 41 54 96 	r3 = r3 * r2 (frac), r2 = M[I0,M1];
        do vol_ctrl_update_channel_peak_lp;
84200238:	03 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_channel_peak_lp;
            r2 = ABS r2;
8420023c:	4f 00 44 e4 	r2 = ABS r2;
            r3 = MAX r2, r2=M[I0,M1];
84200240:	6f 41 54 e4 	r3 = MAX r2, r2 = M[I0,M1];

84200244 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_peak_lp>:
        vol_ctrl_update_channel_peak_lp:
        r2 = ABS r2;
84200244:	4f 00 44 e4 	r2 = ABS r2;
        r3 = MAX r2;
84200248:	6f 00 54 e4 	r3 = MAX r2;
        M[r7 + $volume_control_cap.vol_ctrl_channel_struct.LAST_PEAK_FIELD]=r3;
8420024c:	14 00 59 d5 	M[r7 + 20] = r3;

        // max_abs = MAX(ABS(channel data)) * chan_ptr->channel_gain;
        rMAC = r3 * r8;
84200250:	af 00 15 cc 	rMAC = r3 * r8 (SS);

        r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
84200254:	04 00 28 f1 	r0 = M[FP + 0x4];
        r1 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_LIMIT_THRESHOLD_LINEAR_FIELD)];
84200258:	a4 02 32 d1 	r1 = M[r0 + 676];
        NULL = rMAC - r1;
8420025c:	3f 00 01 20 	Null = rMAC - r1;
        if NEG jump vol_ctrl_update_channel_sat_done;
84200260:	0a 00 40 dd 	if NEG jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done;

        r7 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_LIMIT_ADAPTATION_RATIO_FIELD)];
84200264:	a8 02 92 d1 	r7 = M[r0 + 680];
        r9 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_LIMIT_THRESHOLD_LOG_FIELD)];
84200268:	ac 02 b2 d1 	r9 = M[r0 + 684];

        // limiter_attn = (LIMIT_THRESHOLD - log2(max_abs)) * LIMIT_RATIO;
        call $math.log2_table;
8420026c:	07 00 00 fd 	call 0x745ac;
84200270:	ac 45 f0 e1 
        /* Input to log was Q5.xx,  need to adjust to Q1.xx */
        r0 = r0 + (4<<(DAWTH-8));
84200274:	00 04 00 fd 	r0 = r0 + 67108864;
84200278:	00 00 22 01 
        r9 = r9 - r0;
8420027c:	00 00 b2 23 	r9 = r9 - r0;
        r5 = r9 * r7 (frac);
84200280:	9f 00 7b 94 	r5 = r9 * r7 (frac);
        if POS r5=NULL;
84200284:	05 00 70 00 	if POS r5 = Null + Null;

84200288 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done>:
vol_ctrl_update_channel_sat_done:

    // Time constants are scaled based on num samples
    r1 = M[FP+$vol_ctrl.cufp.chan_ptr];
84200288:	08 00 38 f1 	r1 = M[FP + 0x8];
    r2 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMIT_GAIN_LOG2_FIELD];
8420028c:	0c 00 43 d1 	r2 = M[r1 + 12];
    r3 = M[FP + $vol_ctrl.cufp.tc_ptr];
84200290:	10 00 58 f1 	r3 = M[FP + 0x10];
    r4 = M[r3 + $volume_control_cap.vol_time_constants_struct.SAT_TC_FIELD];
84200294:	08 00 65 d1 	r4 = M[r3 + 8];
    r3 = M[r3 + $volume_control_cap.vol_time_constants_struct.SAT_TCP5_FIELD];
84200298:	0c 00 55 d1 	r3 = M[r3 + 12];
    NULL = r5 - r2;
8420029c:	4f 00 07 20 	Null = r5 - r2;
    if POS r3 = r4;
842002a0:	05 00 56 00 	if POS r3 = r4 + Null;

    // chan_ptr->limit_gain_log2 = (1.0 - tc)*limiter_attn + tc*chan_ptr->limit_gain_log2;
    // chan_ptr->limit_gain_log2 = MIN(chan_ptr->limit_gain_log2,0);
    rMAC = r5;
842002a4:	0f 00 17 00 	rMAC = r5 + Null;
    rMAC = rMAC - r3*r5;
842002a8:	7f 00 15 bc 	rMAC = rMAC - r3 * r5 (SS);
    rMAC = rMAC + r3*r2;
842002ac:	4f 00 15 ac 	rMAC = rMAC + r3 * r2 (SS);
    if POS rMAC = NULL;
842002b0:	05 00 10 00 	if POS rMAC = Null + Null;

    r3 = r5 - rMAC;
842002b4:	1f 00 57 20 	r3 = r5 - rMAC;
    r3 = ABS r3;
842002b8:	4f 00 55 e4 	r3 = ABS r3;
    NULL = r3 - 0.00001;
842002bc:	e3 53 05 21 	Null = r3 - 21475;
    if LE rMAC = r5;
842002c0:	0d 00 17 00 	if LE rMAC = r5 + Null;

    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMIT_GAIN_LOG2_FIELD]=rMAC;
842002c4:	0c 00 13 d5 	M[r1 + 12] = rMAC;

    // r1 = chan_ptr

    L0 = NULL;
842002c8:	0f 00 c0 50 	L0 = Null + Null;
    push NULL;
842002cc:	00 00 00 f3 	push Null;
    pop B0;
842002d0:	00 00 a6 f3 	pop B0;

    /* channel count */
    pop r7;
842002d4:	00 00 94 f3 	pop r7;

    /* advance channel */
    r1 = r1 + ($volume_control_cap.vol_ctrl_channel_struct.STRUC_SIZE*ADDR_PER_WORD);
842002d8:	24 00 33 01 	r1 = r1 + 36;
    M[FP + $vol_ctrl.cufp.chan_ptr] = r1;
842002dc:	08 00 3c f1 	M[FP + 0x8] = r1;

    /* restore data */
    r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
842002e0:	04 00 28 f1 	r0 = M[FP + 0x4];
    r2 = M[FP + $vol_ctrl.cufp.vol_ptr];
842002e4:	0c 00 48 f1 	r2 = M[FP + 0xc];

    /* Another channel ? */
    r7 = r7 - 1;
842002e8:	3f 00 99 e4 	r7 = r7 - 1;
    if GT jump vol_ctrl_update_channel_next;
842002ec:	50 ff c0 dd 	if GT jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_next;

842002f0 <$_vol_ctrl_update_saturation>:
//    Function is C compatible
//
// *****************************************************************************
$_vol_ctrl_update_saturation:
    /* Saturation protection may be per channel or across all channels */
    r1 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CONFIG_FIELD)];
842002f0:	90 01 32 d1 	r1 = M[r0 + 400];
    NULL = r1 AND $M.VOL_CTRL.CONFIG.SATURATEENA;
842002f4:	02 00 03 81 	Null = r1 AND 0x2;
    if Z jump vol_ctrl_update_saturation_done;
842002f8:	1a 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp;

        r2 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.CHANNELS_FIELD];
842002fc:	68 00 42 d1 	r2 = M[r0 + 104];
        r10 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.NUM_CHANNELS_FIELD];
84200300:	5c 00 c2 d1 	r10 = M[r0 + 92];
        M3 = ($volume_control_cap.vol_ctrl_channel_struct.STRUC_SIZE * ADDR_PER_WORD);
84200304:	24 00 b0 51 	M3 = Null + 36;
        I0 = r2 + $volume_control_cap.vol_ctrl_channel_struct.LIMIT_GAIN_LOG2_FIELD;
84200308:	0c 00 04 51 	I0 = r2 + 12;
        I1 = r2 + $volume_control_cap.vol_ctrl_channel_struct.LIMITER_GAIN_LINEAR_FIELD;
8420030c:	10 00 14 51 	I1 = r2 + 16;

        NULL = r1 AND $M.VOL_CTRL.CONFIG.SATURATESYNCENA;
84200310:	04 00 03 81 	Null = r1 AND 0x4;
        if Z jump vol_ctrl_update_saturation_not_sync;
84200314:	0e 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_not_sync;
            // Min log gain of channels
            push r10,    r1 = M[I0,M3];
84200318:	00 33 c0 f2 	push r10, r1 = M[I0,M3];
            r10 = r10 - 1;
8420031c:	3f 00 cc e4 	r10 = r10 - 1;
            r0  = r1;
84200320:	0f 00 23 00 	r0 = r1 + Null;
            do vol_ctrl_update_saturation_min_lp;
84200324:	02 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_min_lp;
                r0 = MIN r1, r1 = M[I0,M3];
84200328:	5f 33 23 e4 	r0 = MIN r1, r1 = M[I0,M3];

8420032c <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_min_lp>:
            vol_ctrl_update_saturation_min_lp:
            r0 = MIN r1;
8420032c:	5f 00 23 e4 	r0 = MIN r1;
            // Convert to linear
            call $math.pow2_table;
84200330:	07 00 00 fd 	call 0x74514;
84200334:	14 45 f0 e1 
            // Apply to all channels
            pop r10;
84200338:	00 00 c4 f3 	pop r10;
            // Nops ensures pipeline for setting r10
            nop;
8420033c:	00 00 00 03 	Null = Null + Null;
            do vol_ctrl_update_saturation_apply_lp;
84200340:	02 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_apply_lp;
                M[I1,M3]=r0;
84200344:	00 a7 00 02 	Null = Null + Null, M[I1,M3] = r0;

84200348 <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_apply_lp>:
            vol_ctrl_update_saturation_apply_lp:
            jump vol_ctrl_update_saturation_done;
84200348:	06 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp;

8420034c <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_not_sync>:

        vol_ctrl_update_saturation_not_sync:
            // Convert to linear
            do vol_ctrl_update_saturation_conv_lp;
8420034c:	05 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp;
                r0 = M[I0,M3];
84200350:	00 23 00 02 	Null = Null + Null, r0 = M[I0,M3];
                call $math.pow2_table;
84200354:	07 00 00 fd 	call 0x74514;
84200358:	14 45 f0 e1 
                M[I1,M3]=r0;
8420035c:	00 a7 00 02 	Null = Null + Null, M[I1,M3] = r0;

84200360 <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp>:
           vol_ctrl_apply_volume(op_extra_data,&op_extra_data->channels[i],&volume_tc);
       }
   */
$_vol_ctrl_apply_volume:

    r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
84200360:	04 00 28 f1 	r0 = M[FP + 0x4];

    /* Number of channels */
    r7 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.NUM_CHANNELS_FIELD];
84200364:	5c 00 92 d1 	r7 = M[r0 + 92];

    // Reset chan_ptr
    r1 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.CHANNELS_FIELD];
84200368:	68 00 32 d1 	r1 = M[r0 + 104];
    M[FP + $vol_ctrl.cuup.chan_ptr]=r1;
8420036c:	08 00 3c f1 	M[FP + 0x8] = r1;

    // Move time constants */
    r2 = M[FP + $vol_ctrl.cufp.tc_ptr];
84200370:	10 00 48 f1 	r2 = M[FP + 0x10];
    M[FP + $vol_ctrl.cuup.tc_ptr] = r2;
84200374:	0c 00 4c f1 	M[FP + 0xc] = r2;

84200378 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_next>:
    // r0: VOL_CTRL_DATA_T *op_extra_data
    // r1: vol_ctrl_channel_t *chan_ptr
    // r2: vol_time_constants_t *lpvcs

vol_ctrl_apply_volume_next:
    push r7;
84200378:	00 00 90 f3 	push r7;
    // r0: VOL_CTRL_DATA_T *op_extra_data
    // r1: vol_ctrl_channel_t *chan_ptr
    // r2: vol_time_constants_t *lpvcs

    // r3: routing
    r7 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CHAN1_AUX_ROUTE_FIELD);
8420037c:	f4 01 92 01 	r7 = r0 + 500;
    r6 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
84200380:	00 00 83 d1 	r6 = M[r1 + 0];
    r6 = r6  * ($volume_control_cap.vol_ctrl_chan_params_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200384:	14 00 88 99 	r6 = r6 * 20 (int);
    r3 = M[r7+r6];
84200388:	8f 00 59 d0 	r3 = M[r7 + r6];

    // Boost
    r8 = $volume_and_limit.OneQ5;
8420038c:	00 08 00 fd 	r8 = Null + 134217728;
84200390:	00 00 a0 01 
    r5  = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_BOOST_FIELD)];
84200394:	9c 02 72 d1 	r5 = M[r0 + 668];
    NULL = r3 AND $M.VOL_CTRL.CONSTANT.CHAN_BOOST_CLIP_ENABLE_BIT;
84200398:	20 00 00 fd 	Null = r3 AND 0x200000;
8420039c:	00 00 05 81 
    if Z r5 = r8;
842003a0:	00 00 7a 00 	if EQ r5 = r8 + Null;

    // Gains
    r9  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD];        // Q5.xx
842003a4:	18 00 b3 d1 	r9 = M[r1 + 24];
    r10 = M[r2 + $volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
842003a8:	00 00 c4 d1 	r10 = M[r2 + 0];
    r7  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD];       // Q5.xx
842003ac:	08 00 93 d1 	r7 = M[r1 + 8];
    r6  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMITER_GAIN_LINEAR_FIELD]; // Q.xx
842003b0:	10 00 83 d1 	r6 = M[r1 + 16];

    // calculate init and final volume for this frame
    rMAC = r9 * r6;
842003b4:	8f 00 1b cc 	rMAC = r9 * r6 (SS);
    rMAC = rMAC * r7;
842003b8:	9f 00 11 cc 	rMAC = rMAC * r7 (SS);
    rMAC = rMAC ASHIFT 4 (56bit);
842003bc:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
    rMAC = rMAC * r5;
842003c0:	7f 00 11 cc 	rMAC = rMAC * r5 (SS);
    rMAC = rMAC ASHIFT 4 (56bit);  // Boost
842003c4:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);

    // Compute the volume step size
    r4  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LAST_VOLUME_FIELD];         // Q5.xx
842003c8:	1c 00 63 d1 	r4 = M[r1 + 28];
    r2 = rMAC - r4;
842003cc:	6f 00 41 20 	r2 = rMAC - r4;
    rMAC = r2 ASHIFT 0 (LO);
842003d0:	00 01 e4 91 	rMAC = r2 ASHIFT 0 (LO);
    Div = rMAC / r10;
842003d4:	00 00 1c d9 	Div = rMAC / r10;

    // Aux Mix
    r8  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_MIX_GAIN_FIELD];        // Q5.xx
842003d8:	04 00 a3 d1 	r8 = M[r1 + 4];
    rMAC = r8 * r5;
842003dc:	7f 00 1a cc 	rMAC = r8 * r5 (SS);
    r8 = rMAC ASHIFT 4;  // Boost
842003e0:	04 00 a1 91 	r8 = rMAC ASHIFT 4;

    /* Adjust Clip Point
       (might as well do it even if we don't use it, divide takes time anyway) */
    r5 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CLIP_POINT_FIELD)];
842003e4:	94 02 72 d1 	r5 = M[r0 + 660];
    r2 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_BOOST_CLIP_POINT_FIELD)];
842003e8:	98 02 42 d1 	r2 = M[r0 + 664];
    // Multiply the Clip Point (r5) with the Inverse Post Gain (r7)
    r7 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.SHARED_VOLUME_PTR_FIELD];
842003ec:	8c 01 92 d1 	r7 = M[r0 + 396];
    r7 = M[r7 + $volume_control_cap._shared_volume_struct.INV_POST_GAIN_FIELD];
842003f0:	0c 00 99 d1 	r7 = M[r7 + 12];
    // The inverse DAC gain is Q5.xx, so we need to shift r7 to get Q1.xx
    rMAC = r5 * r7;
842003f4:	9f 00 17 cc 	rMAC = r5 * r7 (SS);
    r7 = rMAC ASHIFT 4;
842003f8:	04 00 91 91 	r7 = rMAC ASHIFT 4;
    // limit the clipper threshold so DAC wrap bug doesn't occur
    Null = r7 - r2;
842003fc:	4f 00 09 20 	Null = r7 - r2;
    if POS r7 = r2;
84200400:	05 00 94 00 	if POS r7 = r2 + Null;

    // Step for main volume
    r5 = DivResult;
84200404:	01 00 70 d9 	r5 = DivResult;

    // Setup Buffers
    pushm <r3,r10>;
84200408:	20 10 00 f1 	pushm <r3, r10>;

    r1 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
8420040c:	00 00 33 d1 	r1 = M[r1 + 0];
    r1 = r1 * ADDR_PER_WORD (int);
84200410:	04 00 33 99 	r1 = r1 * 4 (int);
    r0 = r0 + r1;
84200414:	00 00 23 03 	r0 = r0 + r1;
    push r0;
84200418:	00 00 20 f3 	push r0;
    r0 = M[r0];
8420041c:	00 00 20 d3 	r0 = M[r0 + Null];
    call $cbuffer.get_read_address_and_size_and_start_address;
84200420:	03 00 00 fd 	call (m) 0x3a27a;
84200424:	7b a2 f0 e1 
    I0 = r0;
84200428:	2f 00 00 50 	I0 = Null + r0;
    push r2;
8420042c:	00 00 40 f3 	push r2;
    pop  B0;
84200430:	00 00 a6 f3 	pop B0;
    L0 = r1;
84200434:	3f 00 c0 50 	L0 = Null + r1;

    pop r0;
84200438:	00 00 24 f3 	pop r0;
    r0 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.OUTPUT_BUFFER_FIELD];
8420043c:	20 00 22 d1 	r0 = M[r0 + 32];
    call $cbuffer.get_write_address_and_size_and_start_address;
84200440:	03 00 00 fd 	call (m) 0x3a2b0;
84200444:	b1 a2 f0 e1 
    I5 = r0;
84200448:	2f 00 50 50 	I5 = Null + r0;
    push r2;
8420044c:	00 00 40 f3 	push r2;
    pop B5;
84200450:	00 00 d6 f3 	pop B5;
    L5 = r1;
84200454:	3f 00 f0 50 	L5 = Null + r1;

    r1 = M[FP + $vol_ctrl.cuup.chan_ptr];
84200458:	08 00 38 f1 	r1 = M[FP + 0x8];
    r0 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_BUFFER_FIELD];
8420045c:	20 00 23 d1 	r0 = M[r1 + 32];
    if NZ jump vol_ctrl_apply_volume_get_aux;
84200460:	06 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux;
        r0 = FP + $vol_ctrl.cuup.dummy;
84200464:	10 00 27 f1 	r0 = FP + 16;
        r1 = ADDR_PER_WORD;
84200468:	bf 00 30 e4 	r1 = Null + 4;
        r2 = r0;
8420046c:	0f 00 42 00 	r2 = r0 + Null;
        r8 = NULL;
84200470:	0f 00 a0 00 	r8 = Null + Null;
        jump vol_ctrl_apply_volume_get_aux_ok;
84200474:	03 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux_ok;

84200478 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux>:
    vol_ctrl_apply_volume_get_aux:
        call $cbuffer.get_read_address_and_size_and_start_address;
84200478:	03 00 00 fd 	call (m) 0x3a27a;
8420047c:	7b a2 f0 e1 

84200480 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux_ok>:
  vol_ctrl_apply_volume_get_aux_ok:
    // Set Aux pointer
    I4 = r0;
84200480:	2f 00 40 50 	I4 = Null + r0;
    push r2;
84200484:	00 00 40 f3 	push r2;
    pop B4;
84200488:	00 00 c6 f3 	pop B4;
    L4 = r1;
8420048c:	3f 00 e0 50 	L4 = Null + r1;

    popm <r3,r10>;
84200490:	20 10 04 f1 	popm <r3, r10>;
    // r7=clip, r4=main gain, r8=aux gain, r3=routing, r10 = amount

    /* Check Mute */
    r0 = M[FP + $vol_ctrl.cuup.op_data_ptr];
84200494:	04 00 28 f1 	r0 = M[FP + 0x4];
    r6 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.CUR_MUTE_GAIN_FIELD];
84200498:	04 03 82 d1 	r6 = M[r0 + 772];
    r9 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.MUTE_INCREMENT_FIELD];
8420049c:	08 03 b2 d1 	r9 = M[r0 + 776];
    if NZ jump vol_ctrl_apply_volume_mute;
842004a0:	16 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute;

    NULL = r3 AND $M.VOL_CTRL.CONSTANT.CHAN_BOOST_CLIP_ENABLE_BIT;
842004a4:	20 00 00 fd 	Null = r3 AND 0x200000;
842004a8:	00 00 05 81 
    if NZ jump vol_ctrl_apply_volume_clip;
842004ac:	08 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip;
        do vol_ctrl_apply_volume_lp;
842004b0:	06 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
842004b4:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
842004b8:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
842004bc:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
842004c0:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            M[I5,MK1] = rMAC;
842004c4:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;

842004c8 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_lp>:
        vol_ctrl_apply_volume_lp:
        jump vol_ctrl_apply_volume_done;
842004c8:	26 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;

842004cc <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip>:

    vol_ctrl_apply_volume_clip:
        do vol_ctrl_apply_volume_clip_lp;
842004cc:	0a 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
842004d0:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
842004d4:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
842004d8:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
842004dc:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            // Hard Clip
            r1 = rMAC ASHIFT (8 + 2 * DAWTH);
842004e0:	48 00 31 91 	r1 = rMAC ASHIFT 72;
            r2 = ABS rMAC;
842004e4:	4f 00 41 e4 	r2 = ABS rMAC;
            r2 = MIN r7;
842004e8:	5f 00 49 e4 	r2 = MIN r7;
            r2 = r2 * r1 (frac);
842004ec:	00 00 43 97 	r2 = r2 * r1 (frac);
            M[I5,MK1] = r2;
842004f0:	c5 00 00 03 	Null = Null + Null, M[I5,4] = r2;

842004f4 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_lp>:
        vol_ctrl_apply_volume_clip_lp:
        jump vol_ctrl_apply_volume_done;
842004f4:	1b 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;

842004f8 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute>:

vol_ctrl_apply_volume_mute:
        NULL = r3 AND $M.VOL_CTRL.CONSTANT.CHAN_BOOST_CLIP_ENABLE_BIT;
842004f8:	20 00 00 fd 	Null = r3 AND 0x200000;
842004fc:	00 00 05 81 
        if NZ jump vol_ctrl_apply_volume_clip_mute;
84200500:	0b 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute;

        do vol_ctrl_apply_volume_mute_lp;
84200504:	09 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
84200508:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
8420050c:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
84200510:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
84200514:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            // Mute
            r6 = r6 + r9;
84200518:	00 00 8b 03 	r6 = r6 + r9;
            if NEG r6=NULL;
8420051c:	04 00 80 00 	if NEG r6 = Null + Null;
            rMAC = rMAC * r6 (frac);
84200520:	00 00 18 97 	rMAC = rMAC * r6 (frac);
            // Save result
            M[I5,MK1] = rMAC;
84200524:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;

84200528 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute_lp>:
        vol_ctrl_apply_volume_mute_lp:
        jump vol_ctrl_apply_volume_done;
84200528:	0e 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;

8420052c <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute>:

vol_ctrl_apply_volume_clip_mute:
        do vol_ctrl_apply_volume_clip_mute_lp;
8420052c:	0d 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
84200530:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
84200534:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
84200538:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
8420053c:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            // Hard Clip
            r1 = rMAC ASHIFT (8 + 2 * DAWTH);
84200540:	48 00 31 91 	r1 = rMAC ASHIFT 72;
            r2 = ABS rMAC;
84200544:	4f 00 41 e4 	r2 = ABS rMAC;
            r2 = MIN r7;
84200548:	5f 00 49 e4 	r2 = MIN r7;
            r2 = r2 * r1 (frac);
8420054c:	00 00 43 97 	r2 = r2 * r1 (frac);
            // Mute
            r6 = r6 + r9;
84200550:	00 00 8b 03 	r6 = r6 + r9;
            if NEG r6=NULL;
84200554:	04 00 80 00 	if NEG r6 = Null + Null;
            r2 = r2 * r6 (frac);
84200558:	00 00 48 97 	r2 = r2 * r6 (frac);
            // Save result
            M[I5,MK1] = r2;
8420055c:	c5 00 00 03 	Null = Null + Null, M[I5,4] = r2;

84200560 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp>:
        vol_ctrl_apply_volume_clip_mute_lp:

vol_ctrl_apply_volume_done:

    // Save last gain
    r1 = M[FP +$vol_ctrl.cuup.chan_ptr];
84200560:	08 00 38 f1 	r1 = M[FP + 0x8];
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LAST_VOLUME_FIELD] = r4;
84200564:	1c 00 63 d5 	M[r1 + 28] = r4;

    // Update Buffer
    r1 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
84200568:	00 00 33 d1 	r1 = M[r1 + 0];
    r1 = r1 * ADDR_PER_WORD(int);
8420056c:	04 00 33 99 	r1 = r1 * 4 (int);
    r0 = M[FP + $vol_ctrl.cuup.op_data_ptr];
84200570:	04 00 28 f1 	r0 = M[FP + 0x4];
    r0 = r0 + r1;
84200574:	00 00 23 03 	r0 = r0 + r1;
    push r0;
84200578:	00 00 20 f3 	push r0;
    r0 = M[r0];
8420057c:	00 00 20 d3 	r0 = M[r0 + Null];
    r1 = I0;
84200580:	0f 00 30 44 	r1 = Null + I0;
    call $cbuffer.set_read_address;
84200584:	03 00 00 fd 	call (m) 0x3a2e6;
84200588:	e7 a2 f0 e1 
    pop r0;
8420058c:	00 00 24 f3 	pop r0;
    r0 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.OUTPUT_BUFFER_FIELD];
84200590:	20 00 22 d1 	r0 = M[r0 + 32];
    r1 = I5;
84200594:	5f 00 30 44 	r1 = Null + I5;
    call $cbuffer.set_write_address;
84200598:	03 00 00 fd 	call (m) 0x3a320;
8420059c:	21 a3 f0 e1 

    /* Next Channel */
    pop r7;
842005a0:	00 00 94 f3 	pop r7;

    /* Restore parameters */
    r0 = M[FP + $vol_ctrl.cuup.op_data_ptr];
842005a4:	04 00 28 f1 	r0 = M[FP + 0x4];
    r1 = M[FP + $vol_ctrl.cuup.chan_ptr];
842005a8:	08 00 38 f1 	r1 = M[FP + 0x8];
    r2 = M[FP + $vol_ctrl.cuup.tc_ptr];
842005ac:	0c 00 48 f1 	r2 = M[FP + 0xc];

    /* advance chan_ptr */
    r1 = r1 + ($volume_control_cap.vol_ctrl_channel_struct.STRUC_SIZE*ADDR_PER_WORD);
842005b0:	24 00 33 01 	r1 = r1 + 36;
    M[FP + $vol_ctrl.cuup.chan_ptr]=r1;
842005b4:	08 00 3c f1 	M[FP + 0x8] = r1;

    /* Another channel */
    r7 = r7 - 1;
842005b8:	3f 00 99 e4 	r7 = r7 - 1;
    if GT jump vol_ctrl_apply_volume_next;
842005bc:	6f ff c0 dd 	if GT jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_next;

    // Save current mute
    M[r0 + $volume_control_cap._vol_ctrl_data_struct.CUR_MUTE_GAIN_FIELD]=r6;
842005c0:	04 03 82 d5 	M[r0 + 772] = r6;
    NULL = r6 - 1.0;
842005c4:	ff 7f 00 fd 	Null = r6 - 2147483647;
842005c8:	ff ff 08 21 
    if Z r9=NULL;
842005cc:	00 00 b0 00 	if EQ r9 = Null + Null;
    M[r0 + $volume_control_cap._vol_ctrl_data_struct.MUTE_INCREMENT_FIELD]=r9;
842005d0:	08 03 b2 d5 	M[r0 + 776] = r9;

    // Restore arithmetic mode */
    pop r4;
842005d4:	00 00 64 f3 	pop r4;
    M[$ARITHMETIC_MODE]=r4;
842005d8:	14 e0 60 19 	M[0xffffe014] = r4 + Null;

842005dc <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_abort>:

vol_ctrl_apply_volume_abort:

    popm <FP,r0,r1,r2,r3,rlink>;
842005dc:	3d 20 04 f1 	popm <FP, r0, r1, r2, r3, rLink>;
    popm <B0,B4,B5>;
842005e0:	00 34 06 f1 	popm <B0, B4, B5>;
    popm <I0,I1,I4,I5,M3,L0,L4,L5>;
842005e4:	33 d8 05 f1 	popm <I0, I1, I4, I5, M3, L0, L4, L5>;
    popm <r4,r5,r6,r7,r8,r9>;
842005e8:	c0 0f 04 f1 	popm <r4, r5, r6, r7, r8, r9>;

    rts;
842005ec:	0f 00 0d dc 	rts;
Disassembly of section .text_minim:

842005f0 <$_setup_processing>:
    op_extra_data->mute_increment = (bMute) ? -mute_increment : mute_increment;

}

bool setup_processing(VOL_CTRL_DATA_T   *op_extra_data)
{
842005f0:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842005f2:	11 09       	r7 = r0 + Null;
    unsigned touched_sink = TOUCHED_NOTHING;
842005f4:	06 00       	r4 = Null + Null;
    unsigned touched_src  = TOUCHED_NOTHING;
842005f6:	07 00       	r5 = Null + Null;
    unsigned i,sink_bit,initial_channel_gain,chan_count=0;
842005f8:	00 09       	r6 = Null + Null;
    vol_ctrl_channel_t *chan_ptr;
	vol_ctrl_gains_t *lpvols =&op_extra_data->host_vol;
842005fa:	9a f0 f8 20 	r8 = r7 + 248;

    patch_fn_shared(volume_control_wrapper);

    /* Release data object */
    destroy_processing(op_extra_data);
842005fe:	6a 4e       	call (m) $_destroy_processing;


    /* Validate channel sinks and sources.  Count connected channels   */
    for(i=0,sink_bit=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++,sink_bit+=2)
84200600:	01 00       	rMAC = Null + Null;
84200602:	02 00       	r0 = Null + Null;
84200604:	93 f0 20 20 	r1 = r7 + 32;

84200608 <Lc_setup_processing_2>:
    {
        if(op_extra_data->input_buffer[i])
84200608:	34 f3 f8 b9 	r2 = M[r1 + -32];
8420060c:	43 60       	if EQ jump (m) Lc_setup_processing_12;

8420060e <Lc_setup_processing_3>:
        {
            if(op_extra_data->output_buffer[i])
8420060e:	1c e8       	r2 = M[r1 + Null];
84200610:	43 60       	if EQ jump (m) Lc_setup_processing_13;

84200612 <Lc_setup_processing_4>:
            {
                chan_count++;
84200612:	08 75       	r6 = r6 + 1;
                touched_sink |= ( TOUCHED_SINK_0 <<sink_bit );
84200614:	14 00       	r2 = r0 + Null;
84200616:	00 f4 94 de 	r2 = 0x1 LSHIFT r2;
8420061a:	36 13       	r4 = r4 OR r2;
                touched_src  |=  (TOUCHED_SOURCE_0 << i);
8420061c:	0c 00       	r2 = rMAC + Null;
8420061e:	00 f4 94 de 	r2 = 0x1 LSHIFT r2;
84200622:	3f 13       	r5 = r5 OR r2;

84200624 <Lc_setup_processing_5>:
    /* Release data object */
    destroy_processing(op_extra_data);


    /* Validate channel sinks and sources.  Count connected channels   */
    for(i=0,sink_bit=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++,sink_bit+=2)
84200624:	49 20       	rMAC = rMAC + 1;
84200626:	92 20       	r0 = r0 + 2;
84200628:	1b 21       	r1 = r1 + 4;
8420062a:	08 26       	Null = rMAC - 8;
8420062c:	ee 65       	if NC jump (m) Lc_setup_processing_2;

8420062e <Lc_setup_processing_6>:
            return FALSE;
        }
    }

    /* Must have at least one channel */
    if(chan_count<1)
8420062e:	0f f8 00 c2 	Null = r6 - Null;
84200632:	32 60       	if EQ jump (m) Lc_setup_processing_13;

84200634 <Lc_setup_processing_7>:
    {
        return FALSE;
    }

    /* A valid set of channels is connected */
    op_extra_data->channels = (vol_ctrl_channel_t*)xzpmalloc(chan_count*sizeof(vol_ctrl_channel_t));
84200634:	c3 20       	r1 = Null + 3;
84200636:	12 f8 92 c9 	r0 = r6 * 36 (int);
8420063a:	ff fd 31 f0 	call (m) 0x68a6;
8420063e:	2d e3 
    if(!op_extra_data->channels)
84200640:	92 f0 1a 8e 	M[r7 + 104] = r0;
84200644:	29 60       	if EQ jump (m) Lc_setup_processing_13;

84200646 <Lc_setup_processing_8>:
    {
        return FALSE;
    }
    op_extra_data->touched_src  = touched_src;
84200646:	97 f0 19 8e 	M[r7 + 100] = r5;
    op_extra_data->touched_sink = touched_sink;
8420064a:	96 f0 18 8e 	M[r7 + 96] = r4;
    op_extra_data->num_channels = chan_count;
8420064e:	98 f0 17 8e 	M[r7 + 92] = r6;

    /* Initialize Mute */
    op_extra_data->cur_mute_gain = 0;
84200652:	90 f0 c1 8e 	M[r7 + 772] = Null;
    vol_ctrl_setup_mute(op_extra_data,lpvols->mute);
84200656:	a3 f0 01 88 	r1 = M[r8 + 4];
8420065a:	4a 08       	r0 = r7 + Null;
8420065c:	08 f0 3f e8 	call (m) Lc_vol_ctrl_setup_mute_1;

    /* Link Channels with channel object */
    chan_ptr = op_extra_data->channels;
84200660:	96 f0 1a 88 	r4 = M[r7 + 104];
    for(i=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++)
84200664:	07 00       	r5 = Null + Null;
84200666:	98 f0 20 20 	r6 = r7 + 32;

8420066a <Lc_setup_processing_9>:
    {
        if(op_extra_data->output_buffer[i])
8420066a:	81 f0 00 e8 	rMAC = M[r6 + Null];
8420066e:	21 60       	if EQ jump (m) Lc_setup_processing_16;

84200670 <Lc_setup_processing_10>:
        {
		    /* If initial value not specified before operator start, use -96db as default
			 * If an initial value is specified calculate channel gain as master_gain + channel_trim - post gain
			 */
		    if(op_extra_data->vol_initialised)
84200670:	90 f0 bf 88 	Null = M[r7 + 764];
84200674:	13 60       	if EQ jump (m) Lc_setup_processing_14;

84200676 <Lc_setup_processing_11>:
		    {
			    initial_channel_gain = dB60toLinearQ5(op_extra_data->lpvols->channel_trims[i] + op_extra_data->lpvols->master_gain - op_extra_data->post_gain);
84200676:	91 f0 62 88 	rMAC = M[r7 + 392];
8420067a:	7a 54       	r0 = r5 LSHIFT 2;
8420067c:	8a 00       	r0 = rMAC + r0;
8420067e:	92 98       	r0 = M[r0 + 40];
84200680:	1f f2 81 c0 	rMAC = r0 + M[rMAC];
84200684:	92 f0 3d 88 	r0 = M[r7 + 244];
84200688:	8a 04       	r0 = rMAC - r0;
8420068a:	ff fd bc f1 	call (m) 0x37fbe;
8420068e:	35 e9 
84200690:	06 6e       	jump (m) Lc_setup_processing_15;

84200692 <Lc_setup_processing_12>:
            else
            {
                return FALSE;
            }
        }
        else if(op_extra_data->output_buffer[i])
84200692:	1c e8       	r2 = M[r1 + Null];
84200694:	c8 61       	if EQ jump (m) Lc_setup_processing_5;

84200696 <Lc_setup_processing_13>:
                touched_sink |= ( TOUCHED_SINK_0 <<sink_bit );
                touched_src  |=  (TOUCHED_SOURCE_0 << i);
            }
            else
            {
                return FALSE;
84200696:	02 00       	r0 = Null + Null;
84200698:	1b 6e       	jump (m) Lc_setup_processing_18;

8420069a <Lc_setup_processing_14>:
		    {
			    initial_channel_gain = dB60toLinearQ5(op_extra_data->lpvols->channel_trims[i] + op_extra_data->lpvols->master_gain - op_extra_data->post_gain);
			}
			else
			{
				initial_channel_gain = 0;
8420069a:	02 00       	r0 = Null + Null;

8420069c <Lc_setup_processing_15>:
			};

			chan_ptr->chan_idx = i;
8420069c:	37 ee       	M[r4 + Null] = r5;
			chan_ptr->channel_gain = initial_channel_gain;
8420069e:	b2 8f       	M[r4 + 24] = r0;
			chan_ptr->prim_mix_gain = dB60toLinearQ5(0); /*set to 0db. this will be recalculated as part of the update function*/
842006a0:	02 00       	r0 = Null + Null;
842006a2:	ff fd bc f1 	call (m) 0x37fbe;
842006a6:	3d e8 
842006a8:	b2 8e       	M[r4 + 8] = r0;
			chan_ptr->last_volume  = chan_ptr->channel_gain;
842006aa:	b1 89       	rMAC = M[r4 + 24];
842006ac:	f1 8f       	M[r4 + 28] = rMAC;
			chan_ptr++;
842006ae:	36 31       	r4 = r4 + 36;

842006b0 <Lc_setup_processing_16>:
    op_extra_data->cur_mute_gain = 0;
    vol_ctrl_setup_mute(op_extra_data,lpvols->mute);

    /* Link Channels with channel object */
    chan_ptr = op_extra_data->channels;
    for(i=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++)
842006b0:	7f 20       	r5 = r5 + 1;
842006b2:	20 75       	r6 = r6 + 4;
842006b4:	38 26       	Null = r5 - 8;
842006b6:	da 65       	if NC jump (m) Lc_setup_processing_9;

842006b8 <Lc_setup_processing_17>:
			chan_ptr->last_volume  = chan_ptr->channel_gain;
			chan_ptr++;
        }
    }

    op_extra_data->vol_initialised = 0;
842006b8:	90 f0 bf 8e 	M[r7 + 764] = Null;
    op_extra_data->wait_on_space_buffer=NULL;
842006bc:	90 f0 10 8e 	M[r7 + 64] = Null;
    op_extra_data->wait_on_data_buffer=NULL;
842006c0:	90 f0 11 8e 	M[r7 + 68] = Null;
    op_extra_data->aux_pending = FALSE;
842006c4:	90 f0 bc 8e 	M[r7 + 752] = Null;
    op_extra_data->used_all_input = FALSE;
842006c8:	90 f0 bd 8e 	M[r7 + 756] = Null;

    return TRUE;
842006cc:	42 20       	r0 = Null + 1;

842006ce <Lc_setup_processing_18>:
}
842006ce:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842006d0:	d8 4c       	rts;

842006d2 <$_destroy_processing>:
}

/* ************************************* Data processing-related functions and wrappers **********************************/

void destroy_processing(VOL_CTRL_DATA_T *op_extra_data)
{
842006d2:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842006d4:	16 00       	r4 = r0 + Null;
    timer_cancel_event_atomic(&op_extra_data->pending_timer);
842006d6:	67 f0 f8 22 	r5 = r4 + 760;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
842006da:	ff fd d3 f1 	call (m) 0x3ad3a;
842006de:	21 e3 
    if (*timer_id != TIMER_ID_INVALID)
842006e0:	3a e8       	r0 = M[r5 + Null];
842006e2:	07 60       	if EQ jump (m) Lc_destroy_processing_3;

842006e4 <Lc_destroy_processing_2>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
842006e4:	04 00       	r2 = Null + Null;
842006e6:	03 00       	r1 = Null + Null;
842006e8:	ff fd 2d f0 	call (m) 0x6292;
842006ec:	2b ed 
        *timer_id = TIMER_ID_INVALID;
842006ee:	38 ee       	M[r5 + Null] = Null;

842006f0 <Lc_destroy_processing_3>:
    }
    interrupt_unblock();
842006f0:	ff fd d3 f1 	call (m) 0x3ad56;
842006f4:	27 e3 

    if(!op_extra_data->channels)
842006f6:	b2 b8       	r0 = M[r4 + 104];
842006f8:	05 60       	if EQ jump (m) Lc_destroy_processing_5;

842006fa <Lc_destroy_processing_4>:
    {
        return;
    }

    pfree(op_extra_data->channels);
842006fa:	ff fd 30 f0 	call (m) 0x68d8;
842006fe:	3f ee 
    op_extra_data->channels = NULL;
84200700:	b0 be       	M[r4 + 104] = Null;

84200702 <Lc_destroy_processing_5>:
}
84200702:	f2 48       	popm <FP, r4, r5, rLink>;
84200704:	d8 4c       	rts;

84200706 <$_vol_ctlr_create>:


/* ********************************** API functions ************************************* */

bool vol_ctlr_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200706:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200708:	17 00       	r5 = r0 + Null;
8420070a:	19 09       	r7 = r1 + Null;
8420070c:	20 09       	r6 = r2 + Null;
8420070e:	2a 09       	r8 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200710:	ef fd fe ff 	call (m) 0x4e6;
84200714:	37 ee 
84200716:	16 00       	r4 = r0 + Null;
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(volume_control_wrapper);

    if (!base_op_create(op_data, message_data, response_id, response_data))
84200718:	55 08       	r3 = r8 + Null;
8420071a:	44 08       	r2 = r6 + Null;
8420071c:	4b 08       	r1 = r7 + Null;
8420071e:	3a 00       	r0 = r5 + Null;
84200720:	ef fd fe ff 	call (m) 0x35a;
84200724:	3b e1 
84200726:	10 04       	Null = r0 - Null;
84200728:	03 62       	if NE jump (m) Lc_vol_ctlr_create_3;

8420072a <Lc_vol_ctlr_create_2>:
    {
        return FALSE;
8420072a:	02 00       	r0 = Null + Null;
8420072c:	31 6e       	jump (m) Lc_vol_ctlr_create_7;

8420072e <Lc_vol_ctlr_create_3>:
    }

    /*allocate the volume control shared memory*/
    op_extra_data->shared_volume_ptr = allocate_shared_volume_cntrl();
8420072e:	ff fd 9d f0 	call (m) 0x14256;
84200732:	29 e9 
84200734:	62 f0 63 8e 	M[r4 + 396] = r0;
    if(!op_extra_data->shared_volume_ptr)
84200738:	61 f0 63 88 	rMAC = M[r4 + 396];
8420073c:	08 62       	if NE jump (m) Lc_vol_ctlr_create_6;

8420073e <Lc_vol_ctlr_create_4>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
8420073e:	01 f0 00 60 	rMAC = Null + 4096;
84200742:	a2 f0 00 e8 	r0 = M[r8 + Null];
84200746:	51 8e       	M[r0 + 4] = rMAC;

84200748 <Lc_vol_ctlr_create_5>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
84200748:	42 20       	r0 = Null + 1;
8420074a:	22 6e       	jump (m) Lc_vol_ctlr_create_7;

8420074c <Lc_vol_ctlr_create_6>:
    }

    op_extra_data->lpvols = &op_extra_data->host_vol;
8420074c:	61 f0 f8 20 	rMAC = r4 + 248;
84200750:	61 f0 62 8e 	M[r4 + 392] = rMAC;
    op_extra_data->stream_based = FALSE;
84200754:	60 f0 c3 8e 	M[r4 + 780] = Null;

    /* Initialize mute control */
    op_extra_data->mute_period = 10;
84200758:	81 22       	rMAC = Null + 10;
8420075a:	61 f0 c0 8e 	M[r4 + 768] = rMAC;

    /* Initialize extended data for operator.  Assume initialized to zero*/
    op_extra_data->ReInitFlag = 1;
8420075e:	41 20       	rMAC = Null + 1;
84200760:	61 f0 ac 8e 	M[r4 + 688] = rMAC;

    op_extra_data->pending_timer = TIMER_ID_INVALID;
84200764:	60 f0 be 8e 	M[r4 + 760] = Null;

    if(!cpsInitParameters(&op_extra_data->parms_def,(unsigned*)VOL_CTRL_GetDefaults(base_op_get_cap_id(op_data)),(unsigned*)&op_extra_data->parameters,sizeof(VOL_CTRL_PARAMETERS)))
84200768:	3a 00       	r0 = r5 + Null;
8420076a:	ef fd fe ff 	call (m) 0x4ea;
8420076e:	21 ec 
84200770:	08 f0 3d e6 	call (m) $_VOL_CTRL_GetDefaults;
84200774:	13 00       	r1 = r0 + Null;
84200776:	05 f0 20 41 	r3 = Null + 288;
8420077a:	64 f0 90 21 	r2 = r4 + 400;
8420077e:	62 f0 b4 22 	r0 = r4 + 692;
84200782:	ef fd ff ff 	call (m) 0x742;
84200786:	21 ee 
84200788:	10 04       	Null = r0 - Null;
8420078a:	df 63       	if NE jump (m) Lc_vol_ctlr_create_5;

8420078c <Lc__ite_11>:
8420078c:	d9 6f       	jump (m) Lc_vol_ctlr_create_4;

8420078e <Lc_vol_ctlr_create_7>:
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    return TRUE;
}
8420078e:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200790:	d8 4c       	rts;

84200792 <$_vol_ctlr_destroy>:



bool vol_ctlr_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200792:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200794:	10 09       	r6 = r0 + Null;
84200796:	1a 09       	r8 = r1 + Null;
84200798:	27 00       	r5 = r2 + Null;
8420079a:	29 09       	r7 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
8420079c:	ef fd fe ff 	call (m) 0x4e6;
842007a0:	2b ea 
842007a2:	16 00       	r4 = r0 + Null;
bool vol_ctlr_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    /* call base_op destroy that creates and fills response message, too */
    if(!base_op_destroy(op_data, message_data, response_id, response_data))
842007a4:	4d 08       	r3 = r7 + Null;
842007a6:	3c 00       	r2 = r5 + Null;
842007a8:	53 08       	r1 = r8 + Null;
842007aa:	42 08       	r0 = r6 + Null;
842007ac:	ef fd fd ff 	call (m) 0x370;
842007b0:	25 ee 
842007b2:	10 04       	Null = r0 - Null;
842007b4:	03 62       	if NE jump (m) Lc_vol_ctlr_destroy_3;

842007b6 <Lc_vol_ctlr_destroy_2>:
    {
        return(FALSE);
842007b6:	02 00       	r0 = Null + Null;
842007b8:	0b 6e       	jump (m) Lc_vol_ctlr_destroy_4;

842007ba <Lc_vol_ctlr_destroy_3>:
    }

    /*free volume control shared memory*/
    release_shared_volume_cntrl(op_extra_data->shared_volume_ptr);
842007ba:	62 f0 63 88 	r0 = M[r4 + 396];
842007be:	ff fd 9d f0 	call (m) 0x1427a;
842007c2:	3d e5 
    op_extra_data->shared_volume_ptr = NULL;
842007c4:	60 f0 63 8e 	M[r4 + 396] = Null;

    /* Release Channels */
    destroy_processing(op_extra_data);
842007c8:	32 00       	r0 = r4 + Null;
842007ca:	84 4f       	call (m) $_destroy_processing;

    return TRUE;
842007cc:	42 20       	r0 = Null + 1;

842007ce <Lc_vol_ctlr_destroy_4>:
}
842007ce:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842007d0:	d8 4c       	rts;

842007d2 <$_vol_ctlr_connect>:
    }
    op_extra_data->aux_buff_size = aux_buffer_min_size;
}

bool vol_ctlr_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842007d2:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842007d4:	11 09       	r7 = r0 + Null;
842007d6:	18 09       	r6 = r1 + Null;
842007d8:	2a 09       	r8 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842007da:	ef fd fe ff 	call (m) 0x4e6;
842007de:	2d e8 
842007e0:	16 00       	r4 = r0 + Null;
}

bool vol_ctlr_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);    /* extract the terminal_id */
842007e2:	87 f0 00 e8 	r5 = M[r6 + Null];
    tCbuffer* pterminal_buf = OPMGR_GET_OP_CONNECT_BUFFER(message_data);
842007e6:	88 f0 01 88 	r6 = M[r6 + 4];

    /* Setup Response to Connection Request. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
842007ea:	03 00       	r1 = Null + Null;
842007ec:	54 08       	r2 = r8 + Null;
842007ee:	4a 08       	r0 = r7 + Null;
842007f0:	ef fd fe ff 	call (m) 0x4bc;
842007f4:	2d e6 
842007f6:	10 04       	Null = r0 - Null;
842007f8:	03 62       	if NE jump (m) Lc_vol_ctlr_connect_3;

842007fa <Lc_vol_ctlr_connect_2>:
    {
        return FALSE;
842007fa:	02 00       	r0 = Null + Null;
842007fc:	67 6e       	jump (m) Lc_vol_ctlr_connect_23;

842007fe <Lc_vol_ctlr_connect_3>:
    }

    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id) || !pterminal_buf)
842007fe:	3b 00       	r1 = r5 + Null;
84200800:	4a 08       	r0 = r7 + Null;
84200802:	ef fd fe ff 	call (m) 0x496;
84200806:	35 e4 
84200808:	10 04       	Null = r0 - Null;
8420080a:	04 60       	if EQ jump (m) Lc_vol_ctlr_connect_5;

8420080c <Lc_vol_ctlr_connect_4>:
8420080c:	0f f8 00 c2 	Null = r6 - Null;
84200810:	07 62       	if NE jump (m) Lc_vol_ctlr_connect_6;

84200812 <Lc_vol_ctlr_connect_5>:
84200812:	01 f0 00 60 	rMAC = Null + 4096;
84200816:	a2 f0 00 e8 	r0 = M[r8 + Null];
8420081a:	51 8e       	M[r0 + 4] = rMAC;
8420081c:	47 6e       	jump (m) Lc_vol_ctlr_connect_19;

8420081e <Lc_vol_ctlr_connect_6>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    if (opmgr_op_is_running(op_data))
8420081e:	4a 08       	r0 = r7 + Null;
84200820:	ff fd 27 f0 	call (m) 0x5700;
84200824:	21 e7 
84200826:	10 04       	Null = r0 - Null;
84200828:	07 60       	if EQ jump (m) Lc_vol_ctlr_connect_9;

8420082a <Lc_vol_ctlr_connect_7>:
    {
        /* Only Auxiliary Terminals Can be Altered while running */
        if(!(terminal_id & TERMINAL_SINK_MASK) || !(terminal_id&0x1))
8420082a:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
8420082e:	00 00 
84200830:	f1 61       	if EQ jump (m) Lc_vol_ctlr_connect_5;

84200832 <Lc_vol_ctlr_connect_8>:
84200832:	39 c0       	rMAC = r5 AND 0x1;
84200834:	ef 61       	if EQ jump (m) Lc_vol_ctlr_connect_5;

84200836 <Lc_vol_ctlr_connect_9>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
        }
    }

    if(terminal_id&TERMINAL_SINK_MASK)
84200836:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
8420083a:	00 00 
8420083c:	39 60       	if EQ jump (m) Lc_vol_ctlr_connect_20;

8420083e <Lc_vol_ctlr_connect_10>:
    {
        unsigned term_idx = (terminal_id&TERMINAL_NUM_MASK)>>1;
8420083e:	3a 50       	r0 = r5 LSHIFT -1;
84200840:	2a f0 1f 00 	r8 = r0 AND 0x1f;

        if(terminal_id&0x1)
84200844:	39 c0       	rMAC = r5 AND 0x1;
84200846:	23 60       	if EQ jump (m) Lc_vol_ctlr_connect_15;

84200848 <Lc_vol_ctlr_connect_11>:
        {
            opmgr_op_suspend_processing(op_data);
84200848:	4a 08       	r0 = r7 + Null;
8420084a:	ff fd 27 f0 	call (m) 0x570c;
8420084e:	23 e6 
            op_extra_data->aux_connected |= (1<<term_idx);
84200850:	51 08       	rMAC = r8 + Null;
84200852:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84200856:	61 f0 b7 88 	rMAC = M[r4 + 732];
8420085a:	89 12       	rMAC = rMAC OR r0;
8420085c:	61 f0 b7 8e 	M[r4 + 732] = rMAC;
            op_extra_data->aux_channel[term_idx].buffer = pterminal_buf;
84200860:	02 fa d2 c8 	r0 = r8 LSHIFT 4;
84200864:	31 00       	rMAC = r4 + Null;
84200866:	51 00       	rMAC = r0 + rMAC;
84200868:	17 f0 6c 20 	r5 = rMAC + 108;
8420086c:	78 f0 00 ee 	M[r5 + Null] = r6;
            opmgr_op_resume_processing(op_data);
84200870:	4a 08       	r0 = r7 + Null;
84200872:	ff fd 27 f0 	call (m) 0x573a;
84200876:	29 e6 
#ifdef INSTALL_METADATA
            if(op_extra_data->metadata_aux_channel == NULL)
84200878:	31 a9       	rMAC = M[r4 + 80];
8420087a:	05 62       	if NE jump (m) Lc_vol_ctlr_connect_14;

8420087c <Lc_vol_ctlr_connect_12>:
            {
                if (buff_has_metadata(op_extra_data->aux_channel[term_idx].buffer))
8420087c:	39 e8       	rMAC = M[r5 + Null];
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(tCbuffer *buff)
{
    if (buff->metadata != NULL)
8420087e:	89 89       	rMAC = M[rMAC + 24];
84200880:	02 60       	if EQ jump (m) Lc_vol_ctlr_connect_14;

84200882 <Lc_vol_ctlr_connect_13>:
                {
                    op_extra_data->metadata_aux_channel = &op_extra_data->aux_channel[term_idx];
84200882:	37 af       	M[r4 + 80] = r5;

84200884 <Lc_vol_ctlr_connect_14>:
                }
            }
#endif /* INSTALL_METADATA */
            vol_ctrl_recalc_aux_buffer_size(op_extra_data);
84200884:	32 00       	r0 = r4 + Null;
84200886:	05 f0 29 ed 	call (m) Lc_vol_ctrl_recalc_aux_buffer_size_1;
8420088a:	10 6e       	jump (m) Lc_vol_ctlr_connect_19;

8420088c <Lc_vol_ctlr_connect_15>:
        }
        else
        {
            op_extra_data->input_buffer[term_idx] = pterminal_buf;
8420088c:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
84200890:	68 f0 02 ee 	M[r4 + r0] = r6;
#ifdef INSTALL_METADATA
            if(op_extra_data->metadata_ip_buffer == NULL)
84200894:	b1 a8       	rMAC = M[r4 + 72];
84200896:	06 62       	if NE jump (m) Lc_vol_ctlr_connect_18;

84200898 <Lc_vol_ctlr_connect_16>:
84200898:	81 f0 06 88 	rMAC = M[r6 + 24];
8420089c:	03 60       	if EQ jump (m) Lc_vol_ctlr_connect_18;

8420089e <Lc_vol_ctlr_connect_17>:
            {
                if (buff_has_metadata(op_extra_data->input_buffer[term_idx]))
                {
                    op_extra_data->metadata_ip_buffer = op_extra_data->input_buffer[term_idx];
8420089e:	68 f0 12 8e 	M[r4 + 72] = r6;

842008a2 <Lc_vol_ctlr_connect_18>:
            {
                op_extra_data->metadata_op_buffer = op_extra_data->output_buffer[term_idx];
            }
        }
#endif /* INSTALL_METADATA */
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
842008a2:	3b 00       	r1 = r5 + Null;
842008a4:	32 00       	r0 = r4 + Null;
842008a6:	05 f0 27 ec 	call (m) Lc_vol_ctrl_recalc_main_buffer_size_1;

842008aa <Lc_vol_ctlr_connect_19>:
    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id) || !pterminal_buf)
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
842008aa:	42 20       	r0 = Null + 1;
842008ac:	0f 6e       	jump (m) Lc_vol_ctlr_connect_23;

842008ae <Lc_vol_ctlr_connect_20>:
            vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
        }
    }
    else
    {
        unsigned term_idx = terminal_id&TERMINAL_NUM_MASK;
842008ae:	ba c2       	r0 = r5 AND 0x3f;
        op_extra_data->output_buffer[term_idx] = pterminal_buf;
842008b0:	52 54       	r0 = r0 LSHIFT 2;
842008b2:	31 00       	rMAC = r4 + Null;
842008b4:	51 00       	rMAC = r0 + rMAC;
842008b6:	18 f0 08 8e 	M[rMAC + 32] = r6;
#ifdef INSTALL_METADATA
        if(op_extra_data->metadata_op_buffer == NULL)
842008ba:	f1 a8       	rMAC = M[r4 + 76];
842008bc:	f3 63       	if NE jump (m) Lc_vol_ctlr_connect_18;

842008be <Lc_vol_ctlr_connect_21>:
842008be:	81 f0 06 88 	rMAC = M[r6 + 24];
842008c2:	f0 61       	if EQ jump (m) Lc_vol_ctlr_connect_18;

842008c4 <Lc_vol_ctlr_connect_22>:
        {
            if (buff_has_metadata(op_extra_data->output_buffer[term_idx]))
            {
                op_extra_data->metadata_op_buffer = op_extra_data->output_buffer[term_idx];
842008c4:	68 f0 13 8e 	M[r4 + 76] = r6;
842008c8:	ed 6f       	jump (m) Lc_vol_ctlr_connect_18;

842008ca <Lc_vol_ctlr_connect_23>:
        }
#endif /* INSTALL_METADATA */
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
    }
    return TRUE;
}
842008ca:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842008cc:	d8 4c       	rts;

842008ce <$_vol_ctlr_disconnect>:

bool vol_ctlr_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842008ce:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842008d0:	10 09       	r6 = r0 + Null;
842008d2:	1f 00       	r5 = r1 + Null;
842008d4:	29 09       	r7 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842008d6:	ef fd fe ff 	call (m) 0x4e6;
842008da:	31 e0 
842008dc:	16 00       	r4 = r0 + Null;
}

bool vol_ctlr_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_DISCONNECT_TERMINAL_ID(message_data);
842008de:	3f e8       	r5 = M[r5 + Null];

    /* Setup Response to Disconnection Request. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
842008e0:	03 00       	r1 = Null + Null;
842008e2:	4c 08       	r2 = r7 + Null;
842008e4:	42 08       	r0 = r6 + Null;
842008e6:	ef fd fd ff 	call (m) 0x4bc;
842008ea:	37 ee 
842008ec:	10 04       	Null = r0 - Null;
842008ee:	03 62       	if NE jump (m) Lc_vol_ctlr_disconnect_3;

842008f0 <Lc_vol_ctlr_disconnect_2>:
    {
        return FALSE;
842008f0:	02 00       	r0 = Null + Null;
842008f2:	92 6e       	jump (m) Lc_vol_ctlr_disconnect_39;

842008f4 <Lc_vol_ctlr_disconnect_3>:
    }

    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id))
842008f4:	3b 00       	r1 = r5 + Null;
842008f6:	42 08       	r0 = r6 + Null;
842008f8:	ef fd fd ff 	call (m) 0x496;
842008fc:	3f ec 
842008fe:	10 04       	Null = r0 - Null;
84200900:	08 62       	if NE jump (m) Lc_vol_ctlr_disconnect_6;

84200902 <Lc_vol_ctlr_disconnect_4>:
84200902:	01 f0 00 60 	rMAC = Null + 4096;
84200906:	92 f0 00 e8 	r0 = M[r7 + Null];
8420090a:	51 8e       	M[r0 + 4] = rMAC;

8420090c <Lc_vol_ctlr_disconnect_5>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
8420090c:	42 20       	r0 = Null + 1;
8420090e:	84 6e       	jump (m) Lc_vol_ctlr_disconnect_39;

84200910 <Lc_vol_ctlr_disconnect_6>:
    }

    if (opmgr_op_is_running(op_data))
84200910:	42 08       	r0 = r6 + Null;
84200912:	ff fd 26 f0 	call (m) 0x5700;
84200916:	2f ef 
84200918:	10 04       	Null = r0 - Null;
8420091a:	07 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_9;

8420091c <Lc_vol_ctlr_disconnect_7>:
    {
        /* Only Auxiliary Terminals Can be Altered while running */
        if(!(terminal_id & TERMINAL_SINK_MASK) || !(terminal_id&0x1))
8420091c:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
84200920:	00 00 
84200922:	f0 61       	if EQ jump (m) Lc_vol_ctlr_disconnect_4;

84200924 <Lc_vol_ctlr_disconnect_8>:
84200924:	39 c0       	rMAC = r5 AND 0x1;
84200926:	ee 61       	if EQ jump (m) Lc_vol_ctlr_disconnect_4;

84200928 <Lc_vol_ctlr_disconnect_9>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
        }
    }

    if(terminal_id&TERMINAL_SINK_MASK)
84200928:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
8420092c:	00 00 
8420092e:	50 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_28;

84200930 <Lc_vol_ctlr_disconnect_10>:
    {
        unsigned term_idx = (terminal_id&TERMINAL_NUM_MASK)>>1;
84200930:	3a 50       	r0 = r5 LSHIFT -1;
84200932:	29 f0 1f 00 	r7 = r0 AND 0x1f;

        if(terminal_id&0x1)
84200936:	39 c0       	rMAC = r5 AND 0x1;
84200938:	2f 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_19;

8420093a <Lc_vol_ctlr_disconnect_11>:
        {
#ifdef INSTALL_METADATA
            if (op_extra_data->metadata_aux_channel == &op_extra_data->aux_channel[term_idx])
8420093a:	02 f9 d2 c8 	r0 = r7 LSHIFT 4;
8420093e:	31 00       	rMAC = r4 + Null;
84200940:	51 00       	rMAC = r0 + rMAC;
84200942:	17 f0 6c 20 	r5 = rMAC + 108;
84200946:	31 a9       	rMAC = M[r4 + 80];
84200948:	c8 05       	Null = rMAC - r5;
8420094a:	10 62       	if NE jump (m) Lc_vol_ctlr_disconnect_18;

8420094c <Lc_vol_ctlr_disconnect_12>:
            {
                unsigned i;
                bool found_alternative = FALSE;
                vol_ctrl_aux_channel_t *aux_chan = NULL;
                for (i = 0, aux_chan = &op_extra_data->aux_channel[0];
8420094c:	01 00       	rMAC = Null + Null;
8420094e:	62 f0 6c 20 	r0 = r4 + 108;

84200952 <Lc_vol_ctlr_disconnect_13>:
                     i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
                     i++, aux_chan++)
                {
                    if (i == term_idx)
84200952:	9f f1 00 c2 	Null = rMAC - r7;
84200956:	05 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_16;

84200958 <Lc_vol_ctlr_disconnect_14>:
                    {
                        continue;
                    }
                    if (aux_chan->buffer != NULL && buff_has_metadata(aux_chan->buffer))
84200958:	13 e8       	r1 = M[r0 + Null];
8420095a:	03 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_16;

8420095c <Lc_vol_ctlr_disconnect_15>:
8420095c:	9b 89       	r1 = M[r1 + 24];
8420095e:	50 62       	if NE jump (m) Lc_vol_ctlr_disconnect_36;

84200960 <Lc_vol_ctlr_disconnect_16>:
                unsigned i;
                bool found_alternative = FALSE;
                vol_ctrl_aux_channel_t *aux_chan = NULL;
                for (i = 0, aux_chan = &op_extra_data->aux_channel[0];
                     i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
                     i++, aux_chan++)
84200960:	49 20       	rMAC = rMAC + 1;
84200962:	12 28       	r0 = r0 + 16;
            {
                unsigned i;
                bool found_alternative = FALSE;
                vol_ctrl_aux_channel_t *aux_chan = NULL;
                for (i = 0, aux_chan = &op_extra_data->aux_channel[0];
                     i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
84200964:	08 26       	Null = rMAC - 8;
84200966:	f6 65       	if NC jump (m) Lc_vol_ctlr_disconnect_13;

84200968 <Lc_vol_ctlr_disconnect_17>:
                        break;
                    }
                }
                if (!found_alternative)
                {
                    op_extra_data->metadata_aux_channel = NULL;
84200968:	30 af       	M[r4 + 80] = Null;

8420096a <Lc_vol_ctlr_disconnect_18>:
                }
            }
#endif /* INSTALL_METADATA */
            opmgr_op_suspend_processing(op_data);
8420096a:	42 08       	r0 = r6 + Null;
8420096c:	ff fd 26 f0 	call (m) 0x570c;
84200970:	21 ed 
            op_extra_data->aux_connected &= ~(1<<term_idx);
84200972:	00 f9 92 de 	r0 = 0x1 LSHIFT r7;
84200976:	ff f2 51 d6 	rMAC = -1 - r0;
8420097a:	62 f0 b7 88 	r0 = M[r4 + 732];
8420097e:	89 10       	rMAC = rMAC AND r0;
84200980:	61 f0 b7 8e 	M[r4 + 732] = rMAC;
            op_extra_data->aux_channel[term_idx].buffer = NULL;
84200984:	38 ee       	M[r5 + Null] = Null;
            opmgr_op_resume_processing(op_data);
84200986:	42 08       	r0 = r6 + Null;
84200988:	ff fd 26 f0 	call (m) 0x573a;
8420098c:	33 ed 
            vol_ctrl_recalc_aux_buffer_size(op_extra_data);
8420098e:	32 00       	r0 = r4 + Null;
84200990:	05 f0 3f e4 	call (m) Lc_vol_ctrl_recalc_aux_buffer_size_1;
84200994:	bc 6f       	jump (m) Lc_vol_ctlr_disconnect_5;

84200996 <Lc_vol_ctlr_disconnect_19>:
        }
        else
        {
#ifdef INSTALL_METADATA
            if (op_extra_data->metadata_ip_buffer == op_extra_data->input_buffer[term_idx])
84200996:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
8420099a:	31 00       	rMAC = r4 + Null;
8420099c:	51 00       	rMAC = r0 + rMAC;
8420099e:	b2 a8       	r0 = M[r4 + 72];
842009a0:	0b e8       	r1 = M[rMAC + Null];
842009a2:	d0 04       	Null = r0 - r1;
842009a4:	0f 62       	if NE jump (m) Lc_vol_ctlr_disconnect_26;

842009a6 <Lc_vol_ctlr_disconnect_20>:
            {
                unsigned i;
                bool found_alternative = FALSE;
                for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
842009a6:	03 00       	r1 = Null + Null;
842009a8:	32 00       	r0 = r4 + Null;

842009aa <Lc_vol_ctlr_disconnect_21>:
                {
                    if (i == term_idx)
842009aa:	9f f3 00 c2 	Null = r1 - r7;
842009ae:	05 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_24;

842009b0 <Lc_vol_ctlr_disconnect_22>:
                    {
                        continue;
                    }
                    if (op_extra_data->input_buffer[i] != NULL && buff_has_metadata(op_extra_data->input_buffer[i]))
842009b0:	14 e8       	r2 = M[r0 + Null];
842009b2:	03 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_24;

842009b4 <Lc_vol_ctlr_disconnect_23>:
842009b4:	a4 89       	r2 = M[r2 + 24];
842009b6:	26 62       	if NE jump (m) Lc_vol_ctlr_disconnect_37;

842009b8 <Lc_vol_ctlr_disconnect_24>:
#ifdef INSTALL_METADATA
            if (op_extra_data->metadata_ip_buffer == op_extra_data->input_buffer[term_idx])
            {
                unsigned i;
                bool found_alternative = FALSE;
                for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
842009b8:	5b 20       	r1 = r1 + 1;
842009ba:	12 21       	r0 = r0 + 4;
842009bc:	18 26       	Null = r1 - 8;
842009be:	f6 65       	if NC jump (m) Lc_vol_ctlr_disconnect_21;

842009c0 <Lc_vol_ctlr_disconnect_25>:
                        break;
                    }
                }
                if (!found_alternative)
                {
                    op_extra_data->metadata_ip_buffer = NULL;
842009c0:	b0 ae       	M[r4 + 72] = Null;

842009c2 <Lc_vol_ctlr_disconnect_26>:
                }
            }
#endif /* INSTALL_METADATA */
            op_extra_data->input_buffer[term_idx] = NULL;
842009c2:	08 ee       	M[rMAC + Null] = Null;

842009c4 <Lc_vol_ctlr_disconnect_27>:
                op_extra_data->metadata_op_buffer = NULL;
            }
        }
#endif /* INSTALL_METADATA */
        op_extra_data->output_buffer[term_idx] = NULL;
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
842009c4:	3b 00       	r1 = r5 + Null;
842009c6:	32 00       	r0 = r4 + Null;
842009c8:	05 f0 25 e3 	call (m) Lc_vol_ctrl_recalc_main_buffer_size_1;
842009cc:	a0 6f       	jump (m) Lc_vol_ctlr_disconnect_5;

842009ce <Lc_vol_ctlr_disconnect_28>:
            vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
        }
    }
    else
    {
        unsigned term_idx = terminal_id&TERMINAL_NUM_MASK;
842009ce:	ba c2       	r0 = r5 AND 0x3f;
#ifdef INSTALL_METADATA
        if (op_extra_data->metadata_op_buffer == op_extra_data->output_buffer[term_idx])
842009d0:	53 54       	r1 = r0 LSHIFT 2;
842009d2:	31 00       	rMAC = r4 + Null;
842009d4:	59 00       	rMAC = r1 + rMAC;
842009d6:	09 30       	rMAC = rMAC + 32;
842009d8:	f3 a8       	r1 = M[r4 + 76];
842009da:	0c e8       	r2 = M[rMAC + Null];
842009dc:	18 05       	Null = r1 - r2;
842009de:	0e 62       	if NE jump (m) Lc_vol_ctlr_disconnect_35;

842009e0 <Lc_vol_ctlr_disconnect_29>:
        {
            unsigned i;
            bool found_alternative = FALSE;
            for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
842009e0:	03 00       	r1 = Null + Null;
842009e2:	34 30       	r2 = r4 + 32;

842009e4 <Lc_vol_ctlr_disconnect_30>:
            {
                if (i == term_idx)
842009e4:	98 04       	Null = r1 - r0;
842009e6:	05 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_33;

842009e8 <Lc_vol_ctlr_disconnect_31>:
                {
                    continue;
                }
                if (op_extra_data->output_buffer[i] != NULL && buff_has_metadata(op_extra_data->output_buffer[i]))
842009e8:	25 e8       	r3 = M[r2 + Null];
842009ea:	03 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_33;

842009ec <Lc_vol_ctlr_disconnect_32>:
842009ec:	ad 89       	r3 = M[r3 + 24];
842009ee:	0e 62       	if NE jump (m) Lc_vol_ctlr_disconnect_38;

842009f0 <Lc_vol_ctlr_disconnect_33>:
#ifdef INSTALL_METADATA
        if (op_extra_data->metadata_op_buffer == op_extra_data->output_buffer[term_idx])
        {
            unsigned i;
            bool found_alternative = FALSE;
            for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
842009f0:	5b 20       	r1 = r1 + 1;
842009f2:	24 21       	r2 = r2 + 4;
842009f4:	18 26       	Null = r1 - 8;
842009f6:	f7 65       	if NC jump (m) Lc_vol_ctlr_disconnect_30;

842009f8 <Lc_vol_ctlr_disconnect_34>:
                    break;
                }
            }
            if (!found_alternative)
            {
                op_extra_data->metadata_op_buffer = NULL;
842009f8:	f0 ae       	M[r4 + 76] = Null;

842009fa <Lc_vol_ctlr_disconnect_35>:
            }
        }
#endif /* INSTALL_METADATA */
        op_extra_data->output_buffer[term_idx] = NULL;
842009fa:	08 ee       	M[rMAC + Null] = Null;
842009fc:	e4 6f       	jump (m) Lc_vol_ctlr_disconnect_27;

842009fe <Lc_vol_ctlr_disconnect_36>:
                    {
                        continue;
                    }
                    if (aux_chan->buffer != NULL && buff_has_metadata(aux_chan->buffer))
                    {
                        op_extra_data->metadata_aux_channel = aux_chan;
842009fe:	32 af       	M[r4 + 80] = r0;
                        found_alternative = TRUE;
                        break;
84200a00:	b5 6f       	jump (m) Lc_vol_ctlr_disconnect_18;

84200a02 <Lc_vol_ctlr_disconnect_37>:
                    {
                        continue;
                    }
                    if (op_extra_data->input_buffer[i] != NULL && buff_has_metadata(op_extra_data->input_buffer[i]))
                    {
                        op_extra_data->metadata_ip_buffer = op_extra_data->input_buffer[i];
84200a02:	5a 54       	r0 = r1 LSHIFT 2;
84200a04:	b2 e8       	r0 = M[r4 + r0];
84200a06:	b2 ae       	M[r4 + 72] = r0;
                        found_alternative = TRUE;
                        break;
84200a08:	dd 6f       	jump (m) Lc_vol_ctlr_disconnect_26;

84200a0a <Lc_vol_ctlr_disconnect_38>:
                {
                    continue;
                }
                if (op_extra_data->output_buffer[i] != NULL && buff_has_metadata(op_extra_data->output_buffer[i]))
                {
                    op_extra_data->metadata_op_buffer = op_extra_data->output_buffer[i];
84200a0a:	5b 54       	r1 = r1 LSHIFT 2;
84200a0c:	32 00       	r0 = r4 + Null;
84200a0e:	9a 00       	r0 = r1 + r0;
84200a10:	12 98       	r0 = M[r0 + 32];
84200a12:	f2 ae       	M[r4 + 76] = r0;
                    found_alternative = TRUE;
                    break;
84200a14:	f3 6f       	jump (m) Lc_vol_ctlr_disconnect_35;

84200a16 <Lc_vol_ctlr_disconnect_39>:
        op_extra_data->output_buffer[term_idx] = NULL;
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
    }

    return TRUE;
}
84200a16:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200a18:	d8 4c       	rts;

84200a1a <$_vol_ctlr_start>:

bool vol_ctlr_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200a1a:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200a1c:	17 00       	r5 = r0 + Null;
84200a1e:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200a20:	ef fd fd ff 	call (m) 0x4e6;
84200a24:	27 e6 
84200a26:	16 00       	r4 = r0 + Null;

bool vol_ctlr_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    /* Setup Response to Start Request.   Assume Failure*/
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84200a28:	03 00       	r1 = Null + Null;
84200a2a:	44 08       	r2 = r6 + Null;
84200a2c:	3a 00       	r0 = r5 + Null;
84200a2e:	ef fd fd ff 	call (m) 0x4bc;
84200a32:	2f e4 
84200a34:	10 04       	Null = r0 - Null;
84200a36:	03 62       	if NE jump (m) Lc_vol_ctlr_start_3;

84200a38 <Lc_vol_ctlr_start_2>:
    {
        return FALSE;
84200a38:	02 00       	r0 = Null + Null;
84200a3a:	39 6e       	jump (m) Lc_vol_ctlr_start_11;

84200a3c <Lc_vol_ctlr_start_3>:
    }

    if (opmgr_op_is_running(op_data))
84200a3c:	3a 00       	r0 = r5 + Null;
84200a3e:	ff fd 26 f0 	call (m) 0x5700;
84200a42:	23 e6 
84200a44:	10 04       	Null = r0 - Null;
84200a46:	32 62       	if NE jump (m) Lc_vol_ctlr_start_10;

84200a48 <Lc_vol_ctlr_start_4>:
    {
        return TRUE;
    }

    if (!setup_processing(op_extra_data))
84200a48:	32 00       	r0 = r4 + Null;
84200a4a:	fd ff 27 ed 	call (m) .L0;
84200a4e:	10 04       	Null = r0 - Null;
84200a50:	06 62       	if NE jump (m) Lc_vol_ctlr_start_6;

84200a52 <Lc_vol_ctlr_start_5>:
84200a52:	01 f0 00 60 	rMAC = Null + 4096;
84200a56:	82 f0 00 e8 	r0 = M[r6 + Null];
84200a5a:	51 8e       	M[r0 + 4] = rMAC;

84200a5c <Lc_vol_ctlr_start_6>:
     *
     * User can set that via DOWNSTREAM_LATENCY_EST parameter, if hasn't
     * been set by the user we will find a suitable value.
     */
    op_extra_data->downstream_latency_estimate =
        VOL_CTRL_DOWNSTREAM_LATENCY_EST(op_extra_data)*MILLISECOND;
84200a5c:	61 f0 d2 88 	rMAC = M[r4 + 840];
84200a60:	03 f0 e8 f1 	rMAC = rMAC * 1000 (int);
84200a64:	91 d9 
    if(0 == op_extra_data->downstream_latency_estimate &&
       NULL != op_extra_data->metadata_op_buffer)
84200a66:	61 f0 d0 8e 	M[r4 + 832] = rMAC;
84200a6a:	18 62       	if NE jump (m) Lc_vol_ctlr_start_9;

84200a6c <Lc_vol_ctlr_start_7>:
84200a6c:	f2 a8       	r0 = M[r4 + 76];
84200a6e:	16 60       	if EQ jump (m) Lc_vol_ctlr_start_9;

84200a70 <Lc_vol_ctlr_start_8>:
        /* user hasn't set the parameter, a good achievable latency with the
         * assumption that the operator's output buffer is directly consumed
         * by a timed playback module at the end of chain is 75% of the buffers
         * size plus one system kick period.
         */
        unsigned buf_size = cbuffer_get_size_in_words(op_extra_data->metadata_op_buffer);
84200a70:	ff fd 9c f0 	call (m) 0x14450;
84200a74:	21 ef 
84200a76:	10 09       	r6 = r0 + Null;
        op_extra_data->downstream_latency_estimate =
            convert_samples_to_time(buf_size, op_extra_data->sample_rate)*3/4 +
            stream_if_get_system_kick_period();
84200a78:	ff fd 3b f0 	call (m) 0x8146;
84200a7c:	2f e6 
84200a7e:	17 00       	r5 = r0 + Null;
84200a80:	63 f0 3b 88 	r1 = M[r4 + 236];
84200a84:	42 08       	r0 = r6 + Null;
84200a86:	ff fd bc f0 	call (m) 0x183fe;
84200a8a:	39 eb 
84200a8c:	d2 40       	r0 = r0 * 3 (int);
84200a8e:	01 21       	rMAC = Null + 4;
84200a90:	8a 4c       	Div = r0 / rMAC;
84200a92:	c1 4c       	rMAC = DivResult;
84200a94:	79 00       	rMAC = r5 + rMAC;
84200a96:	61 f0 d0 8e 	M[r4 + 832] = rMAC;

84200a9a <Lc_vol_ctlr_start_9>:
    }
    /* Reset timestamp references used for aux TTP*/
    op_extra_data->current_timestamp_valid = FALSE;
84200a9a:	60 f0 cd 8e 	M[r4 + 820] = Null;
    op_extra_data->main_timestamp_valid = FALSE;
84200a9e:	60 f0 ca 8e 	M[r4 + 808] = Null;
    op_extra_data->prev_consumed_samples = 0;
84200aa2:	60 f0 cf 8e 	M[r4 + 828] = Null;
    op_extra_data->aux0_ttp.generate_ttp = FALSE;
84200aa6:	60 f0 c8 8e 	M[r4 + 800] = Null;

84200aaa <Lc_vol_ctlr_start_10>:
        return FALSE;
    }

    if (opmgr_op_is_running(op_data))
    {
        return TRUE;
84200aaa:	42 20       	r0 = Null + 1;

84200aac <Lc_vol_ctlr_start_11>:
    op_extra_data->prev_consumed_samples = 0;
    op_extra_data->aux0_ttp.generate_ttp = FALSE;
#endif /* VOLUME_CONTROL_AUX_TTP_SUPPORT */

    return TRUE;
}
84200aac:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200aae:	d8 4c       	rts;

84200ab0 <$_vol_ctlr_buffer_details>:
    return TRUE;
}


bool vol_ctlr_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200ab0:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200ab2:	12 09       	r8 = r0 + Null;
84200ab4:	18 09       	r6 = r1 + Null;
84200ab6:	23 09       	r9 = r2 + Null;
84200ab8:	29 09       	r7 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200aba:	ef fd fd ff 	call (m) 0x4e6;
84200abe:	2d e1 
84200ac0:	17 00       	r5 = r0 + Null;
bool vol_ctlr_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T* opx_data = get_instance_data(op_data);
    OP_BUF_DETAILS_RSP *resp;
    unsigned buffer_size, base_buffer_size;
    unsigned terminal_id = OPMGR_GET_OP_BUF_DETAILS_TERMINAL_ID(message_data);
84200ac2:	86 f0 00 e8 	r4 = M[r6 + Null];
#if !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE)
    unsigned term_idx;
#endif /* !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE) */

    if (!base_op_buffer_details(op_data, message_data, response_id, response_data))
84200ac6:	4d 08       	r3 = r7 + Null;
84200ac8:	5c 08       	r2 = r9 + Null;
84200aca:	43 08       	r1 = r6 + Null;
84200acc:	52 08       	r0 = r8 + Null;
84200ace:	ef fd fc ff 	call (m) 0x37c;
84200ad2:	2f e5 
84200ad4:	10 04       	Null = r0 - Null;
84200ad6:	03 62       	if NE jump (m) Lc_vol_ctlr_buffer_details_3;

84200ad8 <Lc_vol_ctlr_buffer_details_2>:
    {
        return FALSE;
84200ad8:	02 00       	r0 = Null + Null;
84200ada:	58 6e       	jump (m) Lc_vol_ctlr_buffer_details_20;

84200adc <Lc_vol_ctlr_buffer_details_3>:
    }

    resp = (OP_BUF_DETAILS_RSP*)*response_data;
84200adc:	94 f0 00 e8 	r2 = M[r7 + Null];
    base_buffer_size = resp->b.buffer_size + VOL_CTRL_BUFFER_SIZE_PROVISION;
84200ae0:	21 89       	rMAC = M[r2 + 16];
84200ae2:	89 21       	rMAC = rMAC + 6;
        /* If an input/output connection is already present and has metadata then
         * we are obliged to return that buffer so that metadata can be shared
         * between channels. */
        tCbuffer *meta_buff;

        if ((terminal_id & TERMINAL_SINK_MASK) == TERMINAL_SINK_MASK)
84200ae4:	40 f0 62 f0 	r0 = r4 AND 0x800000;
84200ae8:	00 00 
84200aea:	31 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_16;

84200aec <Lc_vol_ctlr_buffer_details_4>:
        {
            /* Only the main input channels consume metadata, the aux inputs do not */
            if ((terminal_id & 0x1) == 0)
84200aec:	32 c0       	r0 = r4 AND 0x1;
84200aee:	03 62       	if NE jump (m) Lc_vol_ctlr_buffer_details_6;

84200af0 <Lc_vol_ctlr_buffer_details_5>:
            {
                meta_buff = opx_data->metadata_ip_buffer;
84200af0:	ba a8       	r0 = M[r5 + 72];
84200af2:	06 6e       	jump (m) Lc_vol_ctlr_buffer_details_9;

84200af4 <Lc_vol_ctlr_buffer_details_6>:
                resp->supports_metadata = TRUE;
            }
            else
            {
                if(NULL != opx_data->metadata_aux_channel)
84200af4:	3a a9       	r0 = M[r5 + 80];
84200af6:	03 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_8;

84200af8 <Lc_vol_ctlr_buffer_details_7>:
                {
                    meta_buff = opx_data->metadata_aux_channel->buffer;
84200af8:	12 e8       	r0 = M[r0 + Null];
84200afa:	02 6e       	jump (m) Lc_vol_ctlr_buffer_details_9;

84200afc <Lc_vol_ctlr_buffer_details_8>:
                }
                else
                {
                    meta_buff = NULL;
84200afc:	02 00       	r0 = Null + Null;

84200afe <Lc_vol_ctlr_buffer_details_9>:
            }
        }
        else
        {
            meta_buff = opx_data->metadata_op_buffer;
            resp->supports_metadata = TRUE;
84200afe:	23 92       	r1 = MBU[r2 + 8];
84200b00:	33 ff ef 1f 	r1 = r1 AND 0xffffffef;
84200b04:	db c9       	r1 = r1 OR 0x10;
84200b06:	23 9a       	MB[r2 + 8] = r1;
        }

        resp->metadata_buffer = meta_buff;
84200b08:	e2 8e       	M[r2 + 12] = r0;

    }
#endif /* INSTALL_METADATA */

    /* buffer size of 2.5ms worth at the sample rate of the operator */
    buffer_size = frac_mult(opx_data->sample_rate,FRACTIONAL(0.0025));
84200b0a:	72 f0 3b 88 	r0 = M[r5 + 236];
84200b0e:	05 f0 f3 f0 	r1 = Null + 5368709;
84200b12:	85 53 
84200b14:	00 f3 72 c9 	r0 = r0 * r1 (frac);

    if (buffer_size==0)
84200b18:	10 04       	Null = r0 - Null;
84200b1a:	03 62       	if NE jump (m) Lc_vol_ctlr_buffer_details_11;

84200b1c <Lc_vol_ctlr_buffer_details_10>:
    {
        buffer_size = VOL_CTRL_BUFFER_SIZE;
84200b1c:	02 f0 80 40 	r0 = Null + 128;

84200b20 <Lc_vol_ctlr_buffer_details_11>:
    }

    if (buffer_size < base_buffer_size)
84200b20:	50 04       	Null = r0 - rMAC;
84200b22:	02 f0 87 e0 	if C jump (m) Lc_vol_ctlr_buffer_details_13;

84200b26 <Lc_vol_ctlr_buffer_details_12>:
    {
        buffer_size = base_buffer_size;
84200b26:	0a 00       	r0 = rMAC + Null;

84200b28 <Lc_vol_ctlr_buffer_details_13>:
    }
#if !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE)
    if(terminal_id&TERMINAL_SINK_MASK)
84200b28:	40 f0 61 f0 	rMAC = r4 AND 0x800000;
84200b2c:	00 00 
84200b2e:	1a 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_18;

84200b30 <Lc_vol_ctlr_buffer_details_14>:
    {
        if(terminal_id&0x1)
84200b30:	31 c0       	rMAC = r4 AND 0x1;
84200b32:	0f 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_17;

84200b34 <Lc_vol_ctlr_buffer_details_15>:
        {
            /* Don't run in place on the aux inputs. */
            resp->runs_in_place = FALSE;
84200b34:	21 92       	rMAC = MBU[r2 + 8];
84200b36:	11 ff f7 1f 	rMAC = rMAC AND 0xfffffff7;
84200b3a:	21 9a       	MB[r2 + 8] = rMAC;

            /* Set the asked buffer size. */
            resp->b.buffer_size = buffer_size;
84200b3c:	22 8f       	M[r2 + 16] = r0;
            opx_data->aux_buff_size = buffer_size;
84200b3e:	72 f0 bb 8e 	M[r5 + 748] = r0;

            return vol_ctrl_fixup_buffer_details(opx_data, terminal_id, resp);
84200b42:	33 00       	r1 = r4 + Null;
84200b44:	3a 00       	r0 = r5 + Null;
84200b46:	04 f0 23 e7 	call (m) Lc_vol_ctrl_fixup_buffer_details_1;
84200b4a:	20 6e       	jump (m) Lc_vol_ctlr_buffer_details_20;

84200b4c <Lc_vol_ctlr_buffer_details_16>:
                resp->supports_metadata = TRUE;
            }
        }
        else
        {
            meta_buff = opx_data->metadata_op_buffer;
84200b4c:	fa a8       	r0 = M[r5 + 76];
84200b4e:	d8 6f       	jump (m) Lc_vol_ctlr_buffer_details_9;

84200b50 <Lc_vol_ctlr_buffer_details_17>:

            return vol_ctrl_fixup_buffer_details(opx_data, terminal_id, resp);
        }
        else
        {
            term_idx = (terminal_id&TERMINAL_NUM_MASK)>>1;
84200b50:	33 50       	r1 = r4 LSHIFT -1;
84200b52:	1b c2       	r1 = r1 AND 0x1f;

            /*input terminal. give the output buffer for the channel */
            resp->b.in_place_buff_params.buffer = opx_data->output_buffer[term_idx] ;
84200b54:	5d 54       	r3 = r1 LSHIFT 2;
84200b56:	39 00       	rMAC = r5 + Null;
84200b58:	69 00       	rMAC = r3 + rMAC;
84200b5a:	09 98       	rMAC = M[rMAC + 32];
84200b5c:	a1 8f       	M[r2 + 24] = rMAC;

            /* Choose terminal associated with the term_idx. */
            resp->b.in_place_buff_params.in_place_terminal = term_idx;
84200b5e:	23 8f       	M[r2 + 16] = r1;
84200b60:	0b 6e       	jump (m) Lc_vol_ctlr_buffer_details_19;

84200b62 <Lc_vol_ctlr_buffer_details_18>:
        }
    }
    else
    {
        /* The output terminal index is directly mapped to the input_buffer array */
        unsigned buffer_idx = (terminal_id&TERMINAL_NUM_MASK);
84200b62:	b3 c2       	r1 = r4 AND 0x3f;
        /* The input terminal index is the buffer index multiplied by 2. */
        term_idx = buffer_idx << 1;
84200b64:	1d 54       	r3 = r1 LSHIFT 1;

        /*output terminal. give the input buffer for the channel */
        resp->b.in_place_buff_params.buffer = opx_data->input_buffer[buffer_idx];
84200b66:	5b 54       	r1 = r1 LSHIFT 2;
84200b68:	f9 e8       	rMAC = M[r5 + r1];
84200b6a:	a1 8f       	M[r2 + 24] = rMAC;

        /* Choose terminal associated with the term_idx. */
        resp->b.in_place_buff_params.in_place_terminal = term_idx | TERMINAL_SINK_MASK;
84200b6c:	08 f0 00 f0 	rMAC = r3 OR 0x800000;
84200b70:	00 f5 51 c8 
84200b74:	21 8f       	M[r2 + 16] = rMAC;

84200b76 <Lc_vol_ctlr_buffer_details_19>:
    }

    /* Run in place*/
    resp->runs_in_place = TRUE;
84200b76:	21 92       	rMAC = MBU[r2 + 8];
84200b78:	11 ff f7 1f 	rMAC = rMAC AND 0xfffffff7;
84200b7c:	49 c9       	rMAC = rMAC OR 0x8;
84200b7e:	21 9a       	MB[r2 + 8] = rMAC;

    /* Set the asked buffer size. */
    resp->b.in_place_buff_params.size = buffer_size;
84200b80:	62 8f       	M[r2 + 20] = r0;

#else  /* !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE) */
    resp->b.buffer_size = buffer_size;
#endif /* !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE) */

    return vol_ctrl_fixup_buffer_details(opx_data, terminal_id, resp);
84200b82:	33 00       	r1 = r4 + Null;
84200b84:	3a 00       	r0 = r5 + Null;
84200b86:	04 f0 23 e5 	call (m) Lc_vol_ctrl_fixup_buffer_details_1;

84200b8a <Lc_vol_ctlr_buffer_details_20>:
}
84200b8a:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200b8c:	d8 4c       	rts;

84200b8e <$_vol_ctlr_get_sched_info>:

    return TRUE;
}

bool vol_ctlr_get_sched_info(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200b8e:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200b90:	17 00       	r5 = r0 + Null;
84200b92:	2e 00       	r4 = r3 + Null;
    OP_SCHED_INFO_RSP* resp;

    resp = base_op_get_sched_info_ex(op_data, message_data, response_id);
84200b94:	ef fd fc ff 	call (m) 0x41c;
84200b98:	29 e4 
    if (resp == NULL)
84200b9a:	10 04       	Null = r0 - Null;
84200b9c:	09 62       	if NE jump (m) Lc_vol_ctlr_get_sched_info_3;

84200b9e <Lc_vol_ctlr_get_sched_info_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84200b9e:	03 f0 00 60 	r1 = Null + 4096;
84200ba2:	34 00       	r2 = r4 + Null;
84200ba4:	3a 00       	r0 = r5 + Null;
84200ba6:	ef fd fc ff 	call (m) 0x4bc;
84200baa:	37 e8 
84200bac:	05 6e       	jump (m) Lc_vol_ctlr_get_sched_info_4;

84200bae <Lc_vol_ctlr_get_sched_info_3>:
    }
    *response_data = resp;
84200bae:	32 ee       	M[r4 + Null] = r0;

    resp->block_size = VOL_CTRL_BLOCK_SIZE;
84200bb0:	41 20       	rMAC = Null + 1;
84200bb2:	91 8e       	M[r0 + 8] = rMAC;

    return TRUE;
84200bb4:	0a 00       	r0 = rMAC + Null;

84200bb6 <Lc_vol_ctlr_get_sched_info_4>:
}
84200bb6:	f2 48       	popm <FP, r4, r5, rLink>;
84200bb8:	d8 4c       	rts;

84200bba <$_vol_ctlr_timer_task>:

    return TRUE;
}

void vol_ctlr_timer_task(void *kick_object)
{
84200bba:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200bbc:	16 00       	r4 = r0 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200bbe:	ef fd fc ff 	call (m) 0x4e6;
84200bc2:	29 e9 
84200bc4:	17 00       	r5 = r0 + Null;
    OPERATOR_DATA *op_data = (OPERATOR_DATA*) kick_object;
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(volume_control_wrapper);

    base_op_profiler_start(op_data);
84200bc6:	32 00       	r0 = r4 + Null;
84200bc8:	ef fd fc ff 	call (m) 0x51e;
84200bcc:	37 ea 

    op_extra_data->pending_timer = TIMER_ID_INVALID;
84200bce:	70 f0 be 8e 	M[r5 + 760] = Null;

    /* Raise a bg int to process */
    opmgr_kick_operator(op_data);
84200bd2:	32 00       	r0 = r4 + Null;
84200bd4:	ff fd 15 f0 	call (m) 0x374a;
84200bd8:	37 eb 

    base_op_profiler_stop(op_data);
84200bda:	32 00       	r0 = r4 + Null;
84200bdc:	ef fd fc ff 	call (m) 0x52c;
84200be0:	31 ea 

84200be2 <Lc_vol_ctlr_timer_task_2>:
}
84200be2:	f2 48       	popm <FP, r4, r5, rLink>;
84200be4:	d8 4c       	rts;

84200be6 <$_vol_ctlr_process_data>:
}
#endif /* VOLUME_CONTROL_AUX_TIMING_TRACE */

RUN_FROM_PM_RAM
void vol_ctlr_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
84200be6:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200be8:	42 de       	M[FP + 32] = r0;
84200bea:	4b de       	M[FP + 36] = r1;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200bec:	ef fd fc ff 	call (m) 0x4e6;
84200bf0:	3b e7 
84200bf2:	12 09       	r8 = r0 + Null;
    unsigned         i,samples_to_process,num_channels,amount,touched_sink;
    unsigned         block_size = VOL_CTRL_BLOCK_SIZE;

    patch_fn(volume_control_process_data_patch);

    op_extra_data->used_all_input = FALSE;
84200bf4:	a0 f0 bd 8e 	M[r8 + 756] = Null;

#ifdef VOLUME_CONTROL_AUX_TIMING_TRACE
    unsigned packed_aux_state = pack_aux_state(op_extra_data);
84200bf8:	05 f0 29 ef 	call (m) Lc_pack_aux_state_1;
84200bfc:	52 de       	M[FP + 40] = r0;
#endif

#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
    /* update timestamp for using aux TTP */
    vol_ctrl_update_current_timestamp(op_extra_data);
84200bfe:	52 08       	r0 = r8 + Null;
84200c00:	04 f0 21 ef 	call (m) Lc_vol_ctrl_update_current_timestamp_1;
#endif

    /* Accelerators for data/space */
    samples_to_process = MAXINT;
84200c04:	ff f7 f6 f7 	r4 = Null + 2147483647;
84200c08:	ff 7b 
    if(op_extra_data->stream_based)
84200c0a:	a0 f0 c3 88 	Null = M[r8 + 780];
84200c0e:	03 60       	if EQ jump (m) Lc_vol_ctlr_process_data_3;

84200c10 <Lc_vol_ctlr_process_data_2>:
    {
        num_channels = 1;
84200c10:	0b 71       	r9 = Null + 1;
84200c12:	25 6e       	jump (m) Lc_vol_ctlr_process_data_12;

84200c14 <Lc_vol_ctlr_process_data_3>:
    }
    else
    {
        if(op_extra_data->wait_on_space_buffer)
84200c14:	a2 f0 10 88 	r0 = M[r8 + 64];
84200c18:	0f 60       	if EQ jump (m) Lc_vol_ctlr_process_data_7;

84200c1a <Lc_vol_ctlr_process_data_4>:
        {
            samples_to_process = cbuffer_calc_amount_space_in_words(op_extra_data->wait_on_space_buffer);
84200c1a:	ff fd c8 f1 	call (m) 0x39d88;
84200c1e:	2f eb 
84200c20:	16 00       	r4 = r0 + Null;
            if(samples_to_process<block_size)
84200c22:	08 62       	if NE jump (m) Lc_vol_ctlr_process_data_6;

84200c24 <Lc_vol_ctlr_process_data_5>:
            {
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_SPACE_LATE);
84200c24:	c4 20       	r2 = Null + 3;
84200c26:	52 08       	r0 = r8 + Null;
84200c28:	4b d8       	r1 = M[FP + 36];
84200c2a:	04 f0 39 e1 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200c2e:	0f f0 ef e6 	jump (m) Lc_vol_ctlr_process_data_77;

84200c32 <Lc_vol_ctlr_process_data_6>:
                return;
            }
            op_extra_data->wait_on_space_buffer=NULL;
84200c32:	a0 f0 10 8e 	M[r8 + 64] = Null;

84200c36 <Lc_vol_ctlr_process_data_7>:
        }
        if(op_extra_data->wait_on_data_buffer)
84200c36:	a2 f0 11 88 	r0 = M[r8 + 68];
84200c3a:	0f 60       	if EQ jump (m) Lc_vol_ctlr_process_data_11;

84200c3c <Lc_vol_ctlr_process_data_8>:
        {
            amount = cbuffer_calc_amount_data_in_words(op_extra_data->wait_on_data_buffer);
84200c3c:	ff fd c8 f1 	call (m) 0x39dd4;
84200c40:	39 ec 
            if(amount<block_size)
84200c42:	10 04       	Null = r0 - Null;
84200c44:	08 62       	if NE jump (m) Lc_vol_ctlr_process_data_10;

84200c46 <Lc_vol_ctlr_process_data_9>:
            {
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_DATA_LATE);
84200c46:	84 20       	r2 = Null + 2;
84200c48:	52 08       	r0 = r8 + Null;
84200c4a:	4b d8       	r1 = M[FP + 36];
84200c4c:	04 f0 37 e0 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200c50:	0f f0 cd e6 	jump (m) Lc_vol_ctlr_process_data_77;

84200c54 <Lc_vol_ctlr_process_data_10>:
                return;
            }
            op_extra_data->wait_on_data_buffer=NULL;
84200c54:	a0 f0 11 8e 	M[r8 + 68] = Null;

84200c58 <Lc_vol_ctlr_process_data_11>:
        }
        num_channels = op_extra_data->num_channels;
84200c58:	ab f0 17 88 	r9 = M[r8 + 92];

84200c5c <Lc_vol_ctlr_process_data_12>:
84200c5c:	41 20       	rMAC = Null + 1;
84200c5e:	59 de       	M[FP + 44] = rMAC;
    }

    /* Compute channel transfer amount */
    for(i=0;i<num_channels;i++)
84200c60:	07 00       	r5 = Null + Null;
84200c62:	05 6e       	jump (m) Lc_vol_ctlr_process_data_15;

84200c64 <Lc_vol_ctlr_process_data_13>:
            {
                op_extra_data->wait_on_space_buffer = buffer;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_SPACE);
                return;
            }
            samples_to_process=amount;
84200c64:	16 00       	r4 = r0 + Null;
            op_extra_data->used_all_input = FALSE;
84200c66:	a0 f0 bd 8e 	M[r8 + 756] = Null;

84200c6a <Lc_vol_ctlr_process_data_14>:
        }
        num_channels = op_extra_data->num_channels;
    }

    /* Compute channel transfer amount */
    for(i=0;i<num_channels;i++)
84200c6a:	7f 20       	r5 = r5 + 1;

84200c6c <Lc_vol_ctlr_process_data_15>:
84200c6c:	bf f7 00 c2 	Null = r5 - r9;
84200c70:	02 f0 ef e0 	if C jump (m) Lc_vol_ctlr_process_data_23;

84200c74 <Lc_vol_ctlr_process_data_16>:
    {
        unsigned term_idx = op_extra_data->channels[i].chan_idx;
84200c74:	a1 f0 1a 88 	rMAC = M[r8 + 104];
84200c78:	12 f7 92 c9 	r0 = r5 * 36 (int);
84200c7c:	8a e8       	r0 = M[rMAC + r0];
        tCbuffer *buffer;

      buffer = op_extra_data->input_buffer[term_idx];
84200c7e:	52 54       	r0 = r0 LSHIFT 2;
84200c80:	51 08       	rMAC = r8 + Null;
84200c82:	51 00       	rMAC = r0 + rMAC;
84200c84:	08 09       	r6 = rMAC + Null;
84200c86:	89 f0 00 e8 	r7 = M[r6 + Null];
      amount = cbuffer_calc_amount_data_in_words(buffer);
84200c8a:	4a 08       	r0 = r7 + Null;
84200c8c:	ff fd c8 f1 	call (m) 0x39dd4;
84200c90:	29 ea 
      if(amount<=samples_to_process)
84200c92:	90 05       	Null = r0 - r4;
84200c94:	08 f0 a3 e0 	if HI jump (m) Lc_vol_ctlr_process_data_20;

84200c98 <Lc_vol_ctlr_process_data_17>:
      {
            if(amount < block_size)
84200c98:	10 04       	Null = r0 - Null;
84200c9a:	0a 62       	if NE jump (m) Lc_vol_ctlr_process_data_19;

84200c9c <Lc_vol_ctlr_process_data_18>:
            {
                op_extra_data->wait_on_data_buffer = buffer;
84200c9c:	a9 f0 11 8e 	M[r8 + 68] = r7;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_DATA);
84200ca0:	04 00       	r2 = Null + Null;
84200ca2:	52 08       	r0 = r8 + Null;
84200ca4:	4b d8       	r1 = M[FP + 36];
84200ca6:	03 f0 3d ed 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200caa:	0f f0 f3 e5 	jump (m) Lc_vol_ctlr_process_data_77;

84200cae <Lc_vol_ctlr_process_data_19>:
                return;
            }
            samples_to_process=amount;
84200cae:	16 00       	r4 = r0 + Null;
            op_extra_data->used_all_input = TRUE;
84200cb0:	59 d8       	rMAC = M[FP + 44];
84200cb2:	a1 f0 bd 8e 	M[r8 + 756] = rMAC;

84200cb6 <Lc_vol_ctlr_process_data_20>:
        }

        buffer = op_extra_data->output_buffer[term_idx];
84200cb6:	88 f0 08 88 	r6 = M[r6 + 32];
        amount = cbuffer_calc_amount_space_in_words(buffer);
84200cba:	42 08       	r0 = r6 + Null;
84200cbc:	ff fd c8 f1 	call (m) 0x39d88;
84200cc0:	2d e6 

        /* Relatively likely to need changes below */
        patch_fn(volume_control_adjust_amount);

        if(amount<samples_to_process)
84200cc2:	90 05       	Null = r0 - r4;
84200cc4:	f2 ff a7 ef 	if C jump (m) Lc_vol_ctlr_process_data_14;

84200cc8 <Lc_vol_ctlr_process_data_21>:
        {
            if(amount<block_size)
84200cc8:	10 04       	Null = r0 - Null;
84200cca:	cd 63       	if NE jump (m) Lc_vol_ctlr_process_data_13;

84200ccc <Lc_vol_ctlr_process_data_22>:
            {
                op_extra_data->wait_on_space_buffer = buffer;
84200ccc:	a8 f0 10 8e 	M[r8 + 64] = r6;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_SPACE);
84200cd0:	44 20       	r2 = Null + 1;
84200cd2:	52 08       	r0 = r8 + Null;
84200cd4:	4b d8       	r1 = M[FP + 36];
84200cd6:	03 f0 2d ec 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200cda:	0f f0 c3 e5 	jump (m) Lc_vol_ctlr_process_data_77;

84200cde <Lc_vol_ctlr_process_data_23>:
    }

    /* Update AUX state.
       If the aux stream doesn't have enough data it indicates a state change */
    unsigned aux_check = (op_extra_data->aux_active | op_extra_data->aux_connected)
        & VOL_CTRL_CHANNEL_MASK;
84200cde:	a1 f0 b8 88 	rMAC = M[r8 + 736];
84200ce2:	a2 f0 b7 88 	r0 = M[r8 + 732];
84200ce6:	89 12       	rMAC = rMAC OR r0;
84200ce8:	89 c3       	rMAC = rMAC AND 0xff;
84200cea:	61 de       	M[FP + 48] = rMAC;

    /* Relatively likely to need changes below */
    patch_fn(volume_control_aux_check);

    op_extra_data->tc.num_words = samples_to_process;
84200cec:	a6 f0 b2 8e 	M[r8 + 712] = r4;

    if (aux_check != 0)
84200cf0:	08 04       	Null = rMAC - Null;
84200cf2:	de 60       	if EQ jump (m) Lc_vol_ctlr_process_data_56;

84200cf4 <Lc_vol_ctlr_process_data_24>:
    {
        vol_ctrl_aux_channel_t* aux_ch;
        unsigned aux_kick = 0;
84200cf4:	01 09       	r7 = Null + Null;
        unsigned aux_limit = MAXINT;
84200cf6:	ff f7 fb f7 	r9 = Null + 2147483647;
84200cfa:	ff 7b 

        for (i = 0, aux_ch = &op_extra_data->aux_channel[0];
84200cfc:	00 09       	r6 = Null + Null;
84200cfe:	a7 f0 6c 20 	r5 = r8 + 108;

84200d02 <Lc_vol_ctlr_process_data_25>:
             i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
             i += 1, aux_ch += 1)
        {
            if (aux_ch->buffer == NULL)
84200d02:	3a e8       	r0 = M[r5 + Null];
84200d04:	03 62       	if NE jump (m) Lc_vol_ctlr_process_data_27;

84200d06 <Lc_vol_ctlr_process_data_26>:
            {
                aux_ch->advance_buffer = 0;
84200d06:	f8 8e       	M[r5 + 12] = Null;
84200d08:	21 6e       	jump (m) Lc_vol_ctlr_process_data_32;

84200d0a <Lc_vol_ctlr_process_data_27>:
            }
            else
            {
                amount = cbuffer_calc_amount_data_in_words(aux_ch->buffer);
84200d0a:	ff fd c8 f1 	call (m) 0x39dd4;
84200d0e:	2b e6 
84200d10:	14 00       	r2 = r0 + Null;

                /* Kick back any aux inputs which have no data, regardless
                 * of state. This helps to prime aux sources which have not
                 * started yet, or recover from false stall detections.
                 */
                if (amount == 0)
84200d12:	fc 8e       	M[r5 + 12] = r2;
84200d14:	0a 62       	if NE jump (m) Lc_vol_ctlr_process_data_29;

84200d16 <Lc_vol_ctlr_process_data_28>:
                {
                    touched->sinks |= (2 << (2 * i));
84200d16:	00 f8 d2 d8 	r0 = r6 LSHIFT 1;
84200d1a:	49 d8       	rMAC = M[FP + 36];
84200d1c:	01 f2 92 ce 	r0 = 0x2 LSHIFT r0;
84200d20:	49 88       	rMAC = M[rMAC + 4];
84200d22:	89 12       	rMAC = rMAC OR r0;
84200d24:	4a d8       	r0 = M[FP + 36];
84200d26:	51 8e       	M[r0 + 4] = rMAC;

84200d28 <Lc_vol_ctlr_process_data_29>:
                }

                /* Only active aux inputs limit the amount of data to process,
                 * because in other states, aux data is not consumed.
                 */
                if (aux_ch->state == AUX_STATE_IN_AUX)
84200d28:	39 81       	rMAC = MBS[r5 + 4];
84200d2a:	88 24       	Null = rMAC - 2;
84200d2c:	0f 62       	if NE jump (m) Lc_vol_ctlr_process_data_32;

84200d2e <Lc_vol_ctlr_process_data_30>:
                {
                    aux_limit = pl_min(aux_limit, amount);
84200d2e:	5b 08       	r1 = r9 + Null;
84200d30:	22 00       	r0 = r2 + Null;
84200d32:	5f f2 43 ce 	r1 = MIN r0;
84200d36:	1b 09       	r9 = r1 + Null;
                    if (amount < samples_to_process)
84200d38:	a0 05       	Null = r2 - r4;
84200d3a:	02 f0 91 e0 	if C jump (m) Lc_vol_ctlr_process_data_32;

84200d3e <Lc_vol_ctlr_process_data_31>:
                    {
                        aux_kick |= (2 << (2 * i));
84200d3e:	00 f8 d2 d8 	r0 = r6 LSHIFT 1;
84200d42:	01 f2 92 ce 	r0 = 0x2 LSHIFT r0;
84200d46:	00 f2 79 c8 	r7 = r7 OR r0;

84200d4a <Lc_vol_ctlr_process_data_32>:
        unsigned aux_kick = 0;
        unsigned aux_limit = MAXINT;

        for (i = 0, aux_ch = &op_extra_data->aux_channel[0];
             i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
             i += 1, aux_ch += 1)
84200d4a:	08 75       	r6 = r6 + 1;
84200d4c:	3f 28       	r5 = r5 + 16;
        vol_ctrl_aux_channel_t* aux_ch;
        unsigned aux_kick = 0;
        unsigned aux_limit = MAXINT;

        for (i = 0, aux_ch = &op_extra_data->aux_channel[0];
             i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
84200d4e:	80 f0 08 24 	Null = r6 - 8;
84200d52:	d8 65       	if NC jump (m) Lc_vol_ctlr_process_data_25;

84200d54 <Lc_vol_ctlr_process_data_33>:
         * 1/2 kick period of being kicked backwards (details see B-255916).
         * Currently there is one overall state for aux_pending, which means
         * that the handling of more than one independent aux source is
         * likely to be flawed (B-255917).
         */
        if (aux_limit >= samples_to_process)
84200d54:	6f fb 00 c2 	Null = r9 - r4;
84200d58:	04 64       	if NC jump (m) Lc_vol_ctlr_process_data_35;

84200d5a <Lc_vol_ctlr_process_data_34>:
        {
            op_extra_data->aux_pending = FALSE;
84200d5a:	a0 f0 bc 8e 	M[r8 + 752] = Null;
84200d5e:	45 6e       	jump (m) Lc_vol_ctlr_process_data_43;

84200d60 <Lc_vol_ctlr_process_data_35>:
        }
        else
        {
            if (op_extra_data->aux_pending && (aux_limit == 0))
84200d60:	a0 f0 bc 88 	Null = M[r8 + 752];
84200d64:	1e 60       	if EQ jump (m) Lc_vol_ctlr_process_data_42;

84200d66 <Lc_vol_ctlr_process_data_36>:
84200d66:	0f fb 00 c2 	Null = r9 - Null;
84200d6a:	0b 62       	if NE jump (m) Lc_vol_ctlr_process_data_39;

84200d6c <Lc_vol_ctlr_process_data_37>:
            {
                /* Since entering aux_pending state, no aux data has arrived */
                if (op_extra_data->pending_timer != TIMER_ID_INVALID)
84200d6c:	a0 f0 be 88 	Null = M[r8 + 760];
84200d70:	f5 61       	if EQ jump (m) Lc_vol_ctlr_process_data_34;

84200d72 <Lc_vol_ctlr_process_data_38>:
                {
                    vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_STILL_AUX_PENDING);
84200d72:	44 21       	r2 = Null + 5;
84200d74:	52 08       	r0 = r8 + Null;
84200d76:	4b d8       	r1 = M[FP + 36];
84200d78:	03 f0 2b e7 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200d7c:	0f f0 a1 e4 	jump (m) Lc_vol_ctlr_process_data_77;

84200d80 <Lc_vol_ctlr_process_data_39>:
            else
            {
                if (op_extra_data->aux_pending)
                {
                    /* Cleanup the timer before restarting it */
                    timer_cancel_event_atomic(&op_extra_data->pending_timer);
84200d80:	a6 f0 f8 22 	r4 = r8 + 760;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84200d84:	ff fd cf f1 	call (m) 0x3ad3a;
84200d88:	37 ed 
    if (*timer_id != TIMER_ID_INVALID)
84200d8a:	32 e8       	r0 = M[r4 + Null];
84200d8c:	07 60       	if EQ jump (m) Lc_vol_ctlr_process_data_41;

84200d8e <Lc_vol_ctlr_process_data_40>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
84200d8e:	04 00       	r2 = Null + Null;
84200d90:	03 00       	r1 = Null + Null;
84200d92:	ff fd 2a f0 	call (m) 0x6292;
84200d96:	21 e8 
        *timer_id = TIMER_ID_INVALID;
84200d98:	30 ee       	M[r4 + Null] = Null;

84200d9a <Lc_vol_ctlr_process_data_41>:
    }
    interrupt_unblock();
84200d9a:	ff fd cf f1 	call (m) 0x3ad56;
84200d9e:	3d ed 

84200da0 <Lc_vol_ctlr_process_data_42>:
                }

                /* (Re-)Start aux_pending */
                touched->sinks |= aux_kick;
84200da0:	49 d8       	rMAC = M[FP + 36];
84200da2:	0a 00       	r0 = rMAC + Null;
84200da4:	49 88       	rMAC = M[rMAC + 4];
84200da6:	00 f9 71 c8 	rMAC = rMAC OR r7;
84200daa:	51 8e       	M[r0 + 4] = rMAC;
                op_extra_data->pending_timer = timer_schedule_event_in(
                    stream_if_get_system_kick_period() / 2,
                    vol_ctlr_timer_task, (void*)op_data );
84200dac:	ff fd 39 f0 	call (m) 0x8146;
84200db0:	3b ec 
84200db2:	42 f0 06 f0 	r4 = Null + 69209019;
84200db6:	bb 53 
84200db8:	93 53       	r1 = r0 LSHIFT -31;
84200dba:	9a 00       	r0 = r1 + r0;
84200dbc:	17 58       	r5 = r0 ASHIFT -1;
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(time_get_time(), time_in), TimerEventFunction, data_pointer);
84200dbe:	ff fd 29 f0 	call (m) 0x6100;
84200dc2:	23 ea 
84200dc4:	ba 00       	r0 = r5 + r0;
84200dc6:	33 00       	r1 = r4 + Null;
84200dc8:	44 d8       	r2 = M[FP + 32];
84200dca:	ff fd 29 f0 	call (m) 0x610a;
84200dce:	21 ea 
}
84200dd0:	a2 f0 be 8e 	M[r8 + 760] = r0;
                op_extra_data->aux_pending = TRUE;
84200dd4:	41 20       	rMAC = Null + 1;
84200dd6:	a1 f0 bc 8e 	M[r8 + 752] = rMAC;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_AUX_PENDING);
84200dda:	04 21       	r2 = Null + 4;
84200ddc:	52 08       	r0 = r8 + Null;
84200dde:	4b d8       	r1 = M[FP + 36];
84200de0:	03 f0 23 e4 	call (m) Lc_vol_ctrl_kick_waiting_1;

                /* Proceed with processing; consume all data from at least one
                 * of the active aux inputs.
                 */
                op_extra_data->tc.num_words = aux_limit;
84200de4:	ab f0 b2 8e 	M[r8 + 712] = r9;

84200de8 <Lc_vol_ctlr_process_data_43>:
        }

        /* Time constants based on samples to process and sample rate */
        vol_ctrl_compute_time_constants(op_extra_data->sample_rate,
                                        op_extra_data->parameters.OFFSET_VOLUME_TC,
                                        &op_extra_data->tc);
84200de8:	a4 f0 c8 22 	r2 = r8 + 712;
84200dec:	a3 f0 a8 88 	r1 = M[r8 + 672];
84200df0:	a2 f0 3b 88 	r0 = M[r8 + 236];
84200df4:	05 f0 37 ef 	call (m) $_vol_ctrl_compute_time_constants;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
        /* There is a possibility that vol_ctrl_update_aux_state
         * limits the number of samples to process, so keep a copy
         * of that now.
         */
        samples_to_process = op_extra_data->tc.num_words;
84200df8:	a6 f0 b2 88 	r4 = M[r8 + 712];
#endif

        vol_ctrl_update_aux_state(op_extra_data, aux_check, &op_extra_data->tc);
84200dfc:	a4 f0 c8 22 	r2 = r8 + 712;
84200e00:	52 08       	r0 = r8 + Null;
84200e02:	63 d8       	r1 = M[FP + 48];
84200e04:	05 f0 2d e3 	call (m) $_vol_ctrl_update_aux_state;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
        /* whole of this block is for debugging purpose only,
         * showing to user whether aux is being mixed in timed mode
         * or normal mode.
         */
        if(op_extra_data->dbg_aux_mixing_started)
84200e08:	a0 f0 d1 88 	Null = M[r8 + 836];
84200e0c:	33 60       	if EQ jump (m) Lc_vol_ctlr_process_data_53;

84200e0e <Lc_vol_ctlr_process_data_44>:
        {
            if(op_extra_data->current_timestamp_valid && op_extra_data->aux0_ttp.enabled)
84200e0e:	a0 f0 cd 88 	Null = M[r8 + 820];
84200e12:	1d 60       	if EQ jump (m) Lc_vol_ctlr_process_data_49;

84200e14 <Lc_vol_ctlr_process_data_45>:
84200e14:	a0 f0 c4 88 	Null = M[r8 + 784];
84200e18:	1a 60       	if EQ jump (m) Lc_vol_ctlr_process_data_49;

84200e1a <Lc_vol_ctlr_process_data_46>:
                L2_DBG_MSG3("Volume Control: Started mixing auxiliary input in playback mode, "
                            "requested ttp: %d, mixed at=%d, diff=%d",
                            op_extra_data->aux0_ttp.time_to_play,
                            op_extra_data->current_timestamp,
                            time_sub(op_extra_data->current_timestamp,
                                     op_extra_data->aux0_ttp.time_to_play));
84200e1a:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200e1e:	88 24       	Null = rMAC - 2;
84200e20:	0c 68       	if LT jump (m) Lc_vol_ctlr_process_data_48;

84200e22 <Lc_vol_ctlr_process_data_47>:
84200e22:	a3 f0 c5 88 	r1 = M[r8 + 788];
84200e26:	a4 f0 cc 88 	r2 = M[r8 + 816];
84200e2a:	e5 04       	r3 = r2 - r1;
84200e2c:	55 f1 02 f0 	r0 = Null + 357564595;
84200e30:	b3 40 
84200e32:	ef fd ff ff 	call (m) 0xd08;
84200e36:	37 e6 

84200e38 <Lc_vol_ctlr_process_data_48>:

                record_aux_ttr_event(op_data,
                                     VOL_CTRL_TTR_EVENT_AUX_STARTED_MIXING,
                                     op_extra_data->aux0_ttp.time_to_play,
                                     op_extra_data->current_timestamp);
84200e38:	a5 f0 cc 88 	r3 = M[r8 + 816];
84200e3c:	a4 f0 c5 88 	r2 = M[r8 + 788];
84200e40:	03 f0 45 40 	r1 = Null + 69;
84200e44:	42 d8       	r0 = M[FP + 32];
84200e46:	04 f0 3d ed 	call (m) Lc_record_aux_ttr_event_1;
84200e4a:	12 6e       	jump (m) Lc_vol_ctlr_process_data_52;

84200e4c <Lc_vol_ctlr_process_data_49>:
            }
            else
            {
                L2_DBG_MSG("Volume Control: Started mixing auxiliary input in non-timed playback mode");
84200e4c:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200e50:	88 24       	Null = rMAC - 2;
84200e52:	07 68       	if LT jump (m) Lc_vol_ctlr_process_data_51;

84200e54 <Lc_vol_ctlr_process_data_50>:
84200e54:	55 f1 02 f0 	r0 = Null + 357564700;
84200e58:	1c 41 
84200e5a:	ef fd ff ff 	call (m) 0xccc;
84200e5e:	33 e3 

84200e60 <Lc_vol_ctlr_process_data_51>:

                record_aux_ttr_event(op_data,
                                     VOL_CTRL_TTR_EVENT_AUX_STARTED_MIXING,
                                     0,
                                     0);
84200e60:	03 f0 45 40 	r1 = Null + 69;
84200e64:	05 00       	r3 = Null + Null;
84200e66:	04 00       	r2 = Null + Null;
84200e68:	42 d8       	r0 = M[FP + 32];
84200e6a:	04 f0 39 ec 	call (m) Lc_record_aux_ttr_event_1;

84200e6e <Lc_vol_ctlr_process_data_52>:
            }
            op_extra_data->dbg_aux_mixing_started = FALSE;
84200e6e:	a0 f0 d1 8e 	M[r8 + 836] = Null;

84200e72 <Lc_vol_ctlr_process_data_53>:
        }

        if(samples_to_process > op_extra_data->tc.num_words)
84200e72:	a1 f0 b2 88 	rMAC = M[r8 + 712];
84200e76:	70 04       	Null = r4 - rMAC;
84200e78:	09 f0 cb e0 	if LS jump (m) Lc_vol_ctlr_process_data_57;

84200e7c <Lc_vol_ctlr_process_data_54>:
             */

            /* recalculate time constants based on limited amount */
            vol_ctrl_compute_time_constants(op_extra_data->sample_rate,
                                            op_extra_data->parameters.OFFSET_VOLUME_TC,
                                            &op_extra_data->tc);
84200e7c:	a4 f0 c8 22 	r2 = r8 + 712;
84200e80:	a3 f0 a8 88 	r1 = M[r8 + 672];
84200e84:	a2 f0 3b 88 	r0 = M[r8 + 236];
84200e88:	05 f0 23 eb 	call (m) $_vol_ctrl_compute_time_constants;

            /* Also do a self kick to process the rest of chunk immediately.*/
            if (op_extra_data->pending_timer == TIMER_ID_INVALID)
84200e8c:	a0 f0 be 88 	Null = M[r8 + 760];
84200e90:	19 62       	if NE jump (m) Lc_vol_ctlr_process_data_57;

84200e92 <Lc_vol_ctlr_process_data_55>:
            {
                op_extra_data->pending_timer =
                    timer_schedule_event_in(0, vol_ctlr_timer_task, (void*)op_data );
84200e92:	42 f0 06 f0 	r4 = Null + 69209019;
84200e96:	bb 53 
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(time_get_time(), time_in), TimerEventFunction, data_pointer);
84200e98:	ff fd 29 f0 	call (m) 0x6100;
84200e9c:	29 e3 
84200e9e:	33 00       	r1 = r4 + Null;
84200ea0:	44 d8       	r2 = M[FP + 32];
84200ea2:	ff fd 29 f0 	call (m) 0x610a;
84200ea6:	29 e3 
}
84200ea8:	a2 f0 be 8e 	M[r8 + 760] = r0;
84200eac:	0b 6e       	jump (m) Lc_vol_ctlr_process_data_57;

84200eae <Lc_vol_ctlr_process_data_56>:
#endif  /* VOLUME_CONTROL_AUX_TTP_SUPPORT  */

    }
    else
    {
        op_extra_data->aux_pending = FALSE;
84200eae:	a0 f0 bc 8e 	M[r8 + 752] = Null;

        /* Time constants based on samples to process and sample rate */
        vol_ctrl_compute_time_constants(op_extra_data->sample_rate,
                                        op_extra_data->parameters.OFFSET_VOLUME_TC,
                                        &op_extra_data->tc);
84200eb2:	a4 f0 c8 22 	r2 = r8 + 712;
84200eb6:	a3 f0 a8 88 	r1 = M[r8 + 672];
84200eba:	a2 f0 3b 88 	r0 = M[r8 + 236];
84200ebe:	05 f0 2d e9 	call (m) $_vol_ctrl_compute_time_constants;

84200ec2 <Lc_vol_ctlr_process_data_57>:
    }

    if (! op_extra_data->aux_pending)
84200ec2:	a0 f0 bc 88 	Null = M[r8 + 752];
84200ec6:	11 62       	if NE jump (m) Lc_vol_ctlr_process_data_61;

84200ec8 <Lc_vol_ctlr_process_data_58>:
    {
        timer_cancel_event_atomic(&op_extra_data->pending_timer);
84200ec8:	a6 f0 f8 22 	r4 = r8 + 760;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84200ecc:	ff fd cf f1 	call (m) 0x3ad3a;
84200ed0:	2f e3 
    if (*timer_id != TIMER_ID_INVALID)
84200ed2:	32 e8       	r0 = M[r4 + Null];
84200ed4:	07 60       	if EQ jump (m) Lc_vol_ctlr_process_data_60;

84200ed6 <Lc_vol_ctlr_process_data_59>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
84200ed6:	04 00       	r2 = Null + Null;
84200ed8:	03 00       	r1 = Null + Null;
84200eda:	ff fd 29 f0 	call (m) 0x6292;
84200ede:	39 ed 
        *timer_id = TIMER_ID_INVALID;
84200ee0:	30 ee       	M[r4 + Null] = Null;

84200ee2 <Lc_vol_ctlr_process_data_60>:
    }
    interrupt_unblock();
84200ee2:	ff fd cf f1 	call (m) 0x3ad56;
84200ee6:	35 e3 

84200ee8 <Lc_vol_ctlr_process_data_61>:
    }

#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
    /* update amount that is consumed this run */
    op_extra_data->prev_consumed_samples = op_extra_data->tc.num_words;
84200ee8:	a1 f0 b2 88 	rMAC = M[r8 + 712];
#endif
    if (op_extra_data->tc.num_words > 0)
84200eec:	a1 f0 cf 8e 	M[r8 + 828] = rMAC;
84200ef0:	11 60       	if EQ jump (m) Lc_vol_ctlr_process_data_63;

84200ef2 <Lc_vol_ctlr_process_data_62>:
    {
#ifdef INSTALL_METADATA
        metadata_tag* eoftag = vol_ctrl_handle_aux_metadata(op_extra_data);
84200ef2:	52 08       	r0 = r8 + Null;
84200ef4:	02 f0 31 eb 	call (m) Lc_vol_ctrl_handle_aux_metadata_1;
        vol_ctrl_handle_input_metadata(op_extra_data, eoftag);
84200ef8:	13 00       	r1 = r0 + Null;
84200efa:	52 08       	r0 = r8 + Null;
84200efc:	02 f0 3d ed 	call (m) Lc_vol_ctrl_handle_input_metadata_1;
#endif  /* INSTALL_METADATA */

        /* Update Main Channels */
        vol_ctrl_update_channel(op_extra_data,op_extra_data->channels,op_extra_data->lpvols,&op_extra_data->tc);
84200f00:	a5 f0 c8 22 	r3 = r8 + 712;
84200f04:	a4 f0 62 88 	r2 = M[r8 + 392];
84200f08:	a3 f0 1a 88 	r1 = M[r8 + 104];
84200f0c:	52 08       	r0 = r8 + Null;
84200f0e:	f8 ff 32 e7 	call $_vol_ctrl_update_channel;

84200f12 <Lc_vol_ctlr_process_data_63>:
    }

#ifdef VOLUME_CONTROL_AUX_TIMING_TRACE
    unsigned updated_aux_state = pack_aux_state(op_extra_data);
84200f12:	52 08       	r0 = r8 + Null;
84200f14:	04 f0 2d e6 	call (m) Lc_pack_aux_state_1;
    if (updated_aux_state != packed_aux_state)
84200f18:	51 d8       	rMAC = M[FP + 40];
84200f1a:	50 04       	Null = r0 - rMAC;
84200f1c:	08 60       	if EQ jump (m) Lc_vol_ctlr_process_data_65;

84200f1e <Lc_vol_ctlr_process_data_64>:
    {
        record_aux_ttr_event(op_data, VOL_CTRL_TTR_EVENT_AUX_STATE,
                             updated_aux_state, 0);
84200f1e:	03 f0 44 40 	r1 = Null + 68;
84200f22:	05 00       	r3 = Null + Null;
84200f24:	14 00       	r2 = r0 + Null;
84200f26:	42 d8       	r0 = M[FP + 32];
84200f28:	04 f0 3b e6 	call (m) Lc_record_aux_ttr_event_1;

84200f2c <Lc_vol_ctlr_process_data_65>:
    }
#endif /* VOLUME_CONTROL_AUX_TIMING_TRACE */

    /* Handle backwards kicks for main channels */
    touched_sink = (op_extra_data->used_all_input) ? op_extra_data->touched_sink : 0;
84200f2c:	a0 f0 bd 88 	Null = M[r8 + 756];
84200f30:	04 60       	if EQ jump (m) Lc_vol_ctlr_process_data_67;

84200f32 <Lc_vol_ctlr_process_data_66>:
84200f32:	a6 f0 18 88 	r4 = M[r8 + 96];
84200f36:	02 6e       	jump (m) Lc_vol_ctlr_process_data_68;

84200f38 <Lc_vol_ctlr_process_data_67>:
84200f38:	06 00       	r4 = Null + Null;

84200f3a <Lc_vol_ctlr_process_data_68>:

    /* Update Aux Buffers */
    op_extra_data->aux_state   = 0;
84200f3a:	a0 f0 b9 8e 	M[r8 + 740] = Null;
    amount    = op_extra_data->aux_connected;
    if(amount)
84200f3e:	a8 f0 b7 88 	r6 = M[r8 + 732];
84200f42:	25 60       	if EQ jump (m) Lc_vol_ctlr_process_data_76;

84200f44 <Lc_vol_ctlr_process_data_69>:
    {
        vol_ctrl_aux_channel_t *aux_ptr=op_extra_data->aux_channel;
84200f44:	a7 f0 6c 20 	r5 = r8 + 108;
        i = 0;
84200f48:	01 09       	r7 = Null + Null;

84200f4a <Lc_vol_ctlr_process_data_70>:
        do
        {
            if(aux_ptr->state==AUX_STATE_IN_AUX)
84200f4a:	39 81       	rMAC = MBS[r5 + 4];
84200f4c:	88 24       	Null = rMAC - 2;
84200f4e:	0e 62       	if NE jump (m) Lc_vol_ctlr_process_data_73;

84200f50 <Lc_vol_ctlr_process_data_71>:
            {
                unsigned index_mask = (1<<i);
84200f50:	49 08       	rMAC = r7 + Null;
84200f52:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
                op_extra_data->aux_state |= index_mask;
84200f56:	a1 f0 b9 88 	rMAC = M[r8 + 740];
84200f5a:	89 12       	rMAC = rMAC OR r0;
84200f5c:	a1 f0 b9 8e 	M[r8 + 740] = rMAC;
                // only advance if used by a channel?
                if(!(op_extra_data->aux_in_use&index_mask))
84200f60:	a1 f0 ba 88 	rMAC = M[r8 + 744];
84200f64:	89 10       	rMAC = rMAC AND r0;
84200f66:	02 62       	if NE jump (m) Lc_vol_ctlr_process_data_73;

84200f68 <Lc_vol_ctlr_process_data_72>:
                {
                    aux_ptr->advance_buffer=0;
84200f68:	f8 8e       	M[r5 + 12] = Null;

84200f6a <Lc_vol_ctlr_process_data_73>:
                }
            }
            if(aux_ptr->advance_buffer)
84200f6a:	fb 88       	r1 = M[r5 + 12];
84200f6c:	0b 60       	if EQ jump (m) Lc_vol_ctlr_process_data_75;

84200f6e <Lc_vol_ctlr_process_data_74>:
            {
                touched_sink |= ( TOUCHED_SINK_0 << ((i<<1)+1) );
84200f6e:	00 f9 d2 d8 	r0 = r7 LSHIFT 1;
84200f72:	51 20       	rMAC = r0 + 1;
84200f74:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84200f78:	b6 12       	r4 = r4 OR r0;
                cbuffer_advance_read_ptr(aux_ptr->buffer,aux_ptr->advance_buffer);
84200f7a:	3a e8       	r0 = M[r5 + Null];
84200f7c:	ff fd c7 f1 	call (m) 0x39de2;
84200f80:	27 e3 

84200f82 <Lc_vol_ctlr_process_data_75>:
            }
            i++;
84200f82:	09 75       	r7 = r7 + 1;
            aux_ptr++;
84200f84:	3f 28       	r5 = r5 + 16;
            amount>>=1;
        }while(amount);
84200f86:	7f f8 d8 d8 	r6 = r6 LSHIFT -1;
84200f8a:	e0 63       	if NE jump (m) Lc_vol_ctlr_process_data_70;

84200f8c <Lc_vol_ctlr_process_data_76>:
    }

   touched->sinks |= touched_sink;
84200f8c:	49 d8       	rMAC = M[FP + 36];
84200f8e:	0a 00       	r0 = rMAC + Null;
84200f90:	49 88       	rMAC = M[rMAC + 4];
84200f92:	89 13       	rMAC = rMAC OR r4;
84200f94:	51 8e       	M[r0 + 4] = rMAC;
   touched->sources = op_extra_data->touched_src;
84200f96:	a1 f0 19 88 	rMAC = M[r8 + 100];
84200f9a:	11 ee       	M[r0 + Null] = rMAC;

84200f9c <Lc_vol_ctlr_process_data_77>:

}
84200f9c:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200f9e:	d8 4c       	rts;

84200fa0 <$_vol_ctlr_opmsg_obpm_set_control>:


/* **************************** Operator message handlers ******************************** */

bool vol_ctlr_opmsg_obpm_set_control(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200fa0:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200fa2:	11 09       	r7 = r0 + Null;
84200fa4:	43 de       	M[FP + 32] = r1;
84200fa6:	27 00       	r5 = r2 + Null;
84200fa8:	4d de       	M[FP + 36] = r3;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200faa:	ef fd fa ff 	call (m) 0x4e6;
84200fae:	3d e9 
84200fb0:	16 00       	r4 = r0 + Null;
bool vol_ctlr_opmsg_obpm_set_control(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T    *op_extra_data = get_instance_data(op_data);
    unsigned            i,num_controls,cntrl_value;
    CPS_CONTROL_SOURCE  cntrl_src;
    OPMSG_RESULT_STATES result = OPMSG_RESULT_STATES_NORMAL_STATE;
84200fb2:	50 de       	M[FP + 40] = Null;
    vol_ctrl_gains_t *lpvols =&op_extra_data->host_vol;
84200fb4:	68 f0 f8 20 	r6 = r4 + 248;
    bool              bIsOBPM=FALSE;
84200fb8:	02 09       	r8 = Null + Null;

    patch_fn(volume_control_opmsg_obpm_set_control_patch);

    if(!cps_control_setup(message_data, resp_length, resp_data,&num_controls))
84200fba:	c5 12       	r3 = FP + 44;
84200fbc:	3b 00       	r1 = r5 + Null;
84200fbe:	4c d8       	r2 = M[FP + 36];
84200fc0:	42 d8       	r0 = M[FP + 32];
84200fc2:	ef fd fd ff 	call (m) 0xab2;
84200fc6:	31 e7 
84200fc8:	10 04       	Null = r0 - Null;
84200fca:	03 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_3;

84200fcc <Lc_vol_ctlr_opmsg_obpm_set_control_2>:
84200fcc:	02 00       	r0 = Null + Null;
84200fce:	8b 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_31;

84200fd0 <Lc_vol_ctlr_opmsg_obpm_set_control_3>:
84200fd0:	0b 71       	r9 = Null + 1;
    {
        return FALSE;
    }

    for(i=0;i<num_controls;i++)
84200fd2:	07 00       	r5 = Null + Null;
84200fd4:	0e 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_8;

84200fd6 <Lc_vol_ctlr_opmsg_obpm_set_control_4>:
                 (cntrl_id<=VOL_CTRL_CONSTANT_TRIM8_GAIN_CTRL) )
        {
            lpvols->channel_trims[cntrl_id-VOL_CTRL_CONSTANT_TRIM1_GAIN_CTRL] = cntrl_value;
        }
        else if( (cntrl_id>=VOL_CTRL_CONSTANT_AUX_GAIN_CTRL1) &&
                 (cntrl_id<=VOL_CTRL_CONSTANT_AUX_GAIN_CTRL8) )
84200fd6:	10 3c       	Null = r0 - 48;
84200fd8:	29 64       	if NC jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_14;

84200fda <Lc_vol_ctlr_opmsg_obpm_set_control_5>:
84200fda:	d0 3d       	Null = r0 - 55;
84200fdc:	08 f0 cf e0 	if HI jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_14;

84200fe0 <Lc_vol_ctlr_opmsg_obpm_set_control_6>:
        {
            lpvols->auxiliary_gain[cntrl_id-VOL_CTRL_CONSTANT_AUX_GAIN_CTRL1] = cntrl_value;
84200fe0:	63 d8       	r1 = M[FP + 48];
84200fe2:	f2 f7 d0 7f 	r0 = r0 + -48;
84200fe6:	41 08       	rMAC = r6 + Null;
84200fe8:	52 54       	r0 = r0 LSHIFT 2;
84200fea:	51 00       	rMAC = r0 + rMAC;
84200fec:	8b 8e       	M[rMAC + 8] = r1;

84200fee <Lc_vol_ctlr_opmsg_obpm_set_control_7>:
    if(!cps_control_setup(message_data, resp_length, resp_data,&num_controls))
    {
        return FALSE;
    }

    for(i=0;i<num_controls;i++)
84200fee:	7f 20       	r5 = r5 + 1;

84200ff0 <Lc_vol_ctlr_opmsg_obpm_set_control_8>:
84200ff0:	59 d8       	rMAC = M[FP + 44];
84200ff2:	78 04       	Null = r5 - rMAC;
84200ff4:	02 f0 bb e0 	if C jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_15;

84200ff8 <Lc_vol_ctlr_opmsg_obpm_set_control_9>:
    {
        unsigned  cntrl_id=cps_control_get(message_data,i,&cntrl_value,&cntrl_src);
84200ff8:	45 13       	r3 = FP + 52;
84200ffa:	04 13       	r2 = FP + 48;
84200ffc:	3b 00       	r1 = r5 + Null;
84200ffe:	42 d8       	r0 = M[FP + 32];
84201000:	ef fd fd ff 	call (m) 0xb00;
84201004:	21 e8 

        /* Check for OBPM and Override.   Override is all or none, not per control */
        if((i==0)&&(cntrl_src != CPS_SOURCE_HOST))
84201006:	38 04       	Null = r5 - Null;
84201008:	0c 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_12;

8420100a <Lc_vol_ctlr_opmsg_obpm_set_control_10>:
8420100a:	a1 d1       	rMAC = MBS[FP + 52];
8420100c:	0a 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_12;

8420100e <Lc_vol_ctlr_opmsg_obpm_set_control_11>:
        {
            bIsOBPM = TRUE;
8420100e:	5a 09       	r8 = r9 + Null;
            lpvols  = &op_extra_data->obpm_vol;
84201010:	68 f0 40 21 	r6 = r4 + 320;
            /* Polarity of override enable/disable is inverted */
            op_extra_data->Ovr_Control = (cntrl_src == CPS_SOURCE_OBPM_DISABLE) ?  VOL_CTRL_CONTROL_VOL_OVERRIDE : 0;
84201014:	03 00       	r1 = Null + Null;
84201016:	c8 24       	Null = rMAC - 3;
84201018:	20 f0 43 ce 	if EQ r1 = Null + 1;
8420101c:	63 f0 3c 8e 	M[r4 + 240] = r1;

84201020 <Lc_vol_ctlr_opmsg_obpm_set_control_12>:
        }

        if(cntrl_id==VOL_CTRL_CONSTANT_POST_GAIN_CTRL)
84201020:	10 34       	Null = r0 - 32;
84201022:	1a 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_18;

84201024 <Lc_vol_ctlr_opmsg_obpm_set_control_13>:
        {
            if(bIsOBPM)
84201024:	0f fa 00 c2 	Null = r8 - Null;
84201028:	0c 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_17;

8420102a <Lc_vol_ctlr_opmsg_obpm_set_control_14>:
            {
                /* OBPM can not set post gain */
                result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
8420102a:	01 21       	rMAC = Null + 4;
8420102c:	51 de       	M[FP + 40] = rMAC;

8420102e <Lc_vol_ctlr_opmsg_obpm_set_control_15>:
            result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
            break;
        }
    }

    if(op_extra_data->Ovr_Control&VOL_CTRL_CONTROL_VOL_OVERRIDE)
8420102e:	61 f0 3c 88 	rMAC = M[r4 + 240];
84201032:	09 c0       	rMAC = rMAC AND 0x1;
84201034:	48 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_29;

84201036 <Lc_vol_ctlr_opmsg_obpm_set_control_16>:
    {
        op_extra_data->lpvols = &op_extra_data->obpm_vol;
84201036:	61 f0 40 21 	rMAC = r4 + 320;
8420103a:	61 f0 62 8e 	M[r4 + 392] = rMAC;
8420103e:	47 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_30;

84201040 <Lc_vol_ctlr_opmsg_obpm_set_control_17>:
                /* OBPM can not set post gain */
                result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
                break;
            }

            op_extra_data->post_gain = cntrl_value;
84201040:	61 d8       	rMAC = M[FP + 48];
84201042:	61 f0 3d 8e 	M[r4 + 244] = rMAC;

            op_extra_data->shared_volume_ptr->inv_post_gain = dB60toLinearQ5(-op_extra_data->post_gain);
84201046:	42 04       	r0 = Null - rMAC;
84201048:	ff fd b7 f1 	call (m) 0x37fbe;
8420104c:	37 eb 
8420104e:	61 f0 63 88 	rMAC = M[r4 + 396];
84201052:	ca 8e       	M[rMAC + 12] = r0;
84201054:	cd 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201056 <Lc_vol_ctlr_opmsg_obpm_set_control_18>:
        }
        else if(cntrl_id==VOL_CTRL_CONSTANT_MASTER_GAIN_CTRL)
84201056:	50 34       	Null = r0 - 33;
84201058:	0d 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_21;

8420105a <Lc_vol_ctlr_opmsg_obpm_set_control_19>:
        {
            lpvols->master_gain = cntrl_value;
8420105a:	61 d8       	rMAC = M[FP + 48];
8420105c:	81 f0 00 ee 	M[r6 + Null] = rMAC;
            if (!opmgr_op_is_running(op_data))
84201060:	4a 08       	r0 = r7 + Null;
84201062:	ff fd 23 f0 	call (m) 0x5700;
84201066:	3f e4 
84201068:	10 04       	Null = r0 - Null;
8420106a:	c2 63       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

8420106c <Lc_vol_ctlr_opmsg_obpm_set_control_20>:
            {
                op_extra_data->vol_initialised = 1;
8420106c:	6b f0 bf 8e 	M[r4 + 764] = r9;
84201070:	bf 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201072 <Lc_vol_ctlr_opmsg_obpm_set_control_21>:
            }
        }
        else if(cntrl_id==OPMSG_CONTROL_MUTE_ID)
84201072:	90 24       	Null = r0 - 2;
84201074:	10 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_24;

84201076 <Lc_vol_ctlr_opmsg_obpm_set_control_22>:
        {
            lpvols->mute = cntrl_value;
84201076:	61 d8       	rMAC = M[FP + 48];
84201078:	81 f0 01 8e 	M[r6 + 4] = rMAC;
            if (opmgr_op_is_running(op_data))
8420107c:	4a 08       	r0 = r7 + Null;
8420107e:	ff fd 23 f0 	call (m) 0x5700;
84201082:	23 e4 
84201084:	10 04       	Null = r0 - Null;
84201086:	b4 61       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201088 <Lc_vol_ctlr_opmsg_obpm_set_control_23>:
            {
                vol_ctrl_setup_mute(op_extra_data,lpvols->mute);
84201088:	83 f0 01 88 	r1 = M[r6 + 4];
8420108c:	32 00       	r0 = r4 + Null;
8420108e:	03 f0 2d e7 	call (m) Lc_vol_ctrl_setup_mute_1;
84201092:	ae 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201094 <Lc_vol_ctlr_opmsg_obpm_set_control_24>:
            }
        }
        else if(cntrl_id==VOL_CTRL_CONSTANT_MUTE_PERIOD_CTRL)
84201094:	90 34       	Null = r0 - 34;
84201096:	0b 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_26;

84201098 <Lc_vol_ctlr_opmsg_obpm_set_control_25>:
        {
            op_extra_data->mute_period = cntrl_value;
84201098:	61 d8       	rMAC = M[FP + 48];
8420109a:	61 f0 c0 8e 	M[r4 + 768] = rMAC;
            if (opmgr_op_is_running(op_data))
8420109e:	4a 08       	r0 = r7 + Null;
842010a0:	ff fd 23 f0 	call (m) 0x5700;
842010a4:	21 e3 
842010a6:	10 04       	Null = r0 - Null;
842010a8:	f0 63       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_23;

842010aa <Lc__ite_12>:
842010aa:	a2 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

842010ac <Lc_vol_ctlr_opmsg_obpm_set_control_26>:
            {
                vol_ctrl_setup_mute(op_extra_data,lpvols->mute);
            }
        }
        else if( (cntrl_id>=VOL_CTRL_CONSTANT_TRIM1_GAIN_CTRL) &&
                 (cntrl_id<=VOL_CTRL_CONSTANT_TRIM8_GAIN_CTRL) )
842010ac:	10 2c       	Null = r0 - 16;
842010ae:	be 65       	if NC jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_14;

842010b0 <Lc_vol_ctlr_opmsg_obpm_set_control_27>:
842010b0:	d0 2d       	Null = r0 - 23;
842010b2:	f8 ff a5 ee 	if HI jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_4;

842010b6 <Lc_vol_ctlr_opmsg_obpm_set_control_28>:
        {
            lpvols->channel_trims[cntrl_id-VOL_CTRL_CONSTANT_TRIM1_GAIN_CTRL] = cntrl_value;
842010b6:	63 d8       	r1 = M[FP + 48];
842010b8:	82 7c       	r0 = r0 + -16;
842010ba:	41 08       	rMAC = r6 + Null;
842010bc:	52 54       	r0 = r0 LSHIFT 2;
842010be:	51 00       	rMAC = r0 + rMAC;
842010c0:	8b 9e       	M[rMAC + 40] = r1;
842010c2:	96 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

842010c4 <Lc_vol_ctlr_opmsg_obpm_set_control_29>:
    {
        op_extra_data->lpvols = &op_extra_data->obpm_vol;
    }
    else
    {
        op_extra_data->lpvols = &op_extra_data->host_vol;
842010c4:	61 f0 f8 20 	rMAC = r4 + 248;
842010c8:	61 f0 62 8e 	M[r4 + 392] = rMAC;

842010cc <Lc_vol_ctlr_opmsg_obpm_set_control_30>:
    }
    op_extra_data->shared_volume_ptr->current_volume_level = op_extra_data->lpvols->master_gain;
842010cc:	61 f0 62 88 	rMAC = M[r4 + 392];
842010d0:	62 f0 63 88 	r0 = M[r4 + 396];
842010d4:	09 e8       	rMAC = M[rMAC + Null];
842010d6:	91 8e       	M[r0 + 8] = rMAC;


    cps_response_set_result(resp_data,result);
842010d8:	53 d8       	r1 = M[FP + 40];
842010da:	4a d8       	r0 = M[FP + 36];
842010dc:	ef fd fd ff 	call (m) 0xb4e;
842010e0:	33 e3 

    return TRUE;
842010e2:	5a 08       	r0 = r9 + Null;

842010e4 <Lc_vol_ctlr_opmsg_obpm_set_control_31>:
}
842010e4:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842010e6:	d8 4c       	rts;

842010e8 <$_vol_ctlr_opmsg_obpm_get_params>:

bool vol_ctlr_opmsg_obpm_get_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842010e8:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842010ea:	1f 00       	r5 = r1 + Null;
842010ec:	26 00       	r4 = r2 + Null;
842010ee:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842010f0:	ef fd f9 ff 	call (m) 0x4e6;
842010f4:	37 ef 

bool vol_ctlr_opmsg_obpm_get_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    return cpsGetParameterMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
842010f6:	02 f0 b4 46 	r0 = r0 + 692;
842010fa:	45 08       	r3 = r6 + Null;
842010fc:	34 00       	r2 = r4 + Null;
842010fe:	3b 00       	r1 = r5 + Null;
84201100:	ef fd fb ff 	call (m) 0x792;
84201104:	33 e4 

84201106 <Lc_vol_ctlr_opmsg_obpm_get_params_2>:
}
84201106:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201108:	d8 4c       	rts;

8420110a <$_vol_ctlr_opmsg_obpm_get_defaults>:

bool vol_ctlr_opmsg_obpm_get_defaults(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420110a:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420110c:	1f 00       	r5 = r1 + Null;
8420110e:	26 00       	r4 = r2 + Null;
84201110:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201112:	ef fd f9 ff 	call (m) 0x4e6;
84201116:	35 ee 

bool vol_ctlr_opmsg_obpm_get_defaults(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    return cpsGetDefaultsMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
84201118:	02 f0 b4 46 	r0 = r0 + 692;
8420111c:	45 08       	r3 = r6 + Null;
8420111e:	34 00       	r2 = r4 + Null;
84201120:	3b 00       	r1 = r5 + Null;
84201122:	ef fd fb ff 	call (m) 0x840;
84201126:	3f e8 

84201128 <Lc_vol_ctlr_opmsg_obpm_get_defaults_2>:
}
84201128:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420112a:	d8 4c       	rts;

8420112c <$_vol_ctlr_opmsg_obpm_set_params>:

bool vol_ctlr_opmsg_obpm_set_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420112c:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
8420112e:	19 09       	r7 = r1 + Null;
84201130:	27 00       	r5 = r2 + Null;
84201132:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201134:	ef fd f9 ff 	call (m) 0x4e6;
84201138:	33 ed 
8420113a:	16 00       	r4 = r0 + Null;
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    bool retval;

    patch_fn(volume_control_opmsg_obpm_set_params_patch);

    retval = cpsSetParameterMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
8420113c:	62 f0 b4 22 	r0 = r4 + 692;
84201140:	45 08       	r3 = r6 + Null;
84201142:	3c 00       	r2 = r5 + Null;
84201144:	4b 08       	r1 = r7 + Null;
84201146:	ef fd fb ff 	call (m) 0x914;
8420114a:	2f ee 

    /* Set the Reinit flag after setting the parameters */
    op_extra_data->ReInitFlag = 1;
8420114c:	41 20       	rMAC = Null + 1;
8420114e:	61 f0 ac 8e 	M[r4 + 688] = rMAC;

84201152 <Lc_vol_ctlr_opmsg_obpm_set_params_2>:

    return retval;
84201152:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201154:	d8 4c       	rts;

84201156 <$_vol_ctlr_opmsg_obpm_get_status>:
}

bool vol_ctlr_opmsg_obpm_get_status(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201156:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
84201158:	19 09       	r7 = r1 + Null;
8420115a:	27 00       	r5 = r2 + Null;
8420115c:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
8420115e:	ef fd f9 ff 	call (m) 0x4e6;
84201162:	29 ec 
84201164:	12 09       	r8 = r0 + Null;
}

bool vol_ctlr_opmsg_obpm_get_status(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    vol_ctrl_gains_t *lpvols = op_extra_data->lpvols;
84201166:	a6 f0 62 88 	r4 = M[r8 + 392];
    unsigned  *resp;

    patch_fn_shared(volume_control_wrapper);

    if(!common_obpm_status_helper(message_data,resp_length,resp_data,sizeof(VOL_CTRL_STATISTICS),&resp))
8420116a:	c1 11       	rMAC = FP + 28;
8420116c:	09 1c       	pushm <rMAC>;
8420116e:	05 f0 50 40 	r3 = Null + 80;
84201172:	44 08       	r2 = r6 + Null;
84201174:	3b 00       	r1 = r5 + Null;
84201176:	4a 08       	r0 = r7 + Null;
84201178:	ef fd fc ff 	call (m) 0xb64;
8420117c:	2d ef 
8420117e:	7f 4c       	SP = SP + -4;
84201180:	10 04       	Null = r0 - Null;
84201182:	03 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_get_status_3;

84201184 <Lc_vol_ctlr_opmsg_obpm_get_status_2>:
    {
        return FALSE;
84201184:	02 00       	r0 = Null + Null;
84201186:	4c 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_get_status_6;

84201188 <Lc_vol_ctlr_opmsg_obpm_get_status_3>:
    }

    if (resp)
84201188:	3c d8       	r2 = M[FP + 28];
8420118a:	49 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_get_status_5;

8420118c <Lc_vol_ctlr_opmsg_obpm_get_status_4>:
    {
        resp = cpsPack2Words(op_extra_data->Ovr_Control, op_extra_data->post_gain, resp);
8420118c:	a3 f0 3d 88 	r1 = M[r8 + 244];
84201190:	a2 f0 3c 88 	r0 = M[r8 + 240];
84201194:	ff fd c5 f1 	call (m) 0x39caa;
84201198:	37 e8 
8420119a:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->master_gain, lpvols->auxiliary_gain[0], resp);
8420119c:	3c d8       	r2 = M[FP + 28];
8420119e:	b3 88       	r1 = M[r4 + 8];
842011a0:	32 e8       	r0 = M[r4 + Null];
842011a2:	ff fd c5 f1 	call (m) 0x39caa;
842011a6:	29 e8 
842011a8:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[1], lpvols->auxiliary_gain[2], resp);
842011aa:	3c d8       	r2 = M[FP + 28];
842011ac:	33 89       	r1 = M[r4 + 16];
842011ae:	f2 88       	r0 = M[r4 + 12];
842011b0:	ff fd c5 f1 	call (m) 0x39caa;
842011b4:	3b e7 
842011b6:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[3], lpvols->auxiliary_gain[4], resp);
842011b8:	3c d8       	r2 = M[FP + 28];
842011ba:	b3 89       	r1 = M[r4 + 24];
842011bc:	72 89       	r0 = M[r4 + 20];
842011be:	ff fd c5 f1 	call (m) 0x39caa;
842011c2:	2d e7 
842011c4:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[5], lpvols->auxiliary_gain[6], resp);
842011c6:	3c d8       	r2 = M[FP + 28];
842011c8:	33 98       	r1 = M[r4 + 32];
842011ca:	f2 89       	r0 = M[r4 + 28];
842011cc:	ff fd c5 f1 	call (m) 0x39caa;
842011d0:	3f e6 
842011d2:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[7], lpvols->channel_trims[0], resp);
842011d4:	3c d8       	r2 = M[FP + 28];
842011d6:	b3 98       	r1 = M[r4 + 40];
842011d8:	72 98       	r0 = M[r4 + 36];
842011da:	ff fd c5 f1 	call (m) 0x39caa;
842011de:	31 e6 
842011e0:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[1], lpvols->channel_trims[2], resp);
842011e2:	3c d8       	r2 = M[FP + 28];
842011e4:	33 99       	r1 = M[r4 + 48];
842011e6:	f2 98       	r0 = M[r4 + 44];
842011e8:	ff fd c5 f1 	call (m) 0x39caa;
842011ec:	23 e6 
842011ee:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[3], lpvols->channel_trims[4], resp);
842011f0:	3c d8       	r2 = M[FP + 28];
842011f2:	b3 99       	r1 = M[r4 + 56];
842011f4:	72 99       	r0 = M[r4 + 52];
842011f6:	ff fd c5 f1 	call (m) 0x39caa;
842011fa:	35 e5 
842011fc:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[5], lpvols->channel_trims[6], resp);
842011fe:	3c d8       	r2 = M[FP + 28];
84201200:	33 a8       	r1 = M[r4 + 64];
84201202:	f2 99       	r0 = M[r4 + 60];
84201204:	ff fd c5 f1 	call (m) 0x39caa;
84201208:	27 e5 
8420120a:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[7], op_extra_data->aux_state, resp);
8420120c:	3c d8       	r2 = M[FP + 28];
8420120e:	a3 f0 b9 88 	r1 = M[r8 + 740];
84201212:	72 a8       	r0 = M[r4 + 68];
84201214:	ff fd c5 f1 	call (m) 0x39caa;
84201218:	37 e4 
8420121a:	3a de       	M[FP + 28] = r0;

8420121c <Lc_vol_ctlr_opmsg_obpm_get_status_5>:
    }

    return TRUE;
8420121c:	42 20       	r0 = Null + 1;

8420121e <Lc_vol_ctlr_opmsg_obpm_get_status_6>:
}
8420121e:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
84201220:	d8 4c       	rts;

84201222 <$_vol_ctlr_opmsg_set_ucid>:

    return TRUE;
}

bool vol_ctlr_opmsg_set_ucid(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201222:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84201224:	11 09       	r7 = r0 + Null;
84201226:	1a 09       	r8 = r1 + Null;
84201228:	27 00       	r5 = r2 + Null;
8420122a:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
8420122c:	ef fd f9 ff 	call (m) 0x4e6;
84201230:	3b e5 
84201232:	16 00       	r4 = r0 + Null;
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    PS_KEY_TYPE key;
    bool retval;

    retval = cpsSetUcidMsgHandler(&op_extra_data->parms_def,message_data,resp_length,resp_data);
84201234:	62 f0 b4 22 	r0 = r4 + 692;
84201238:	45 08       	r3 = r6 + Null;
8420123a:	3c 00       	r2 = r5 + Null;
8420123c:	53 08       	r1 = r8 + Null;
8420123e:	ef fd fb ff 	call (m) 0x9a6;
84201242:	29 eb 
84201244:	17 00       	r5 = r0 + Null;

    key = MAP_CAPID_UCID_SBID_TO_PSKEYID(base_op_get_cap_id(op_data),op_extra_data->parms_def.ucid,OPMSG_P_STORE_PARAMETER_SUB_ID);
84201246:	4a 08       	r0 = r7 + Null;
84201248:	ef fd f9 ff 	call (m) 0x4ea;
8420124c:	23 e5 
8420124e:	92 c6       	r0 = r0 AND 0xffff;
84201250:	61 f0 b1 88 	rMAC = M[r4 + 708];
84201254:	92 55       	r0 = r0 LSHIFT 7;
84201256:	8b c2       	r1 = rMAC AND 0x3f;
84201258:	1b 54       	r1 = r1 LSHIFT 1;
8420125a:	9b 12       	r1 = r1 OR r0;
    ps_entry_read((void*)op_data,key,PERSIST_ANY,ups_params_vc);
8420125c:	42 f0 05 f0 	r3 = Null + 69212197;
84201260:	25 70 
84201262:	04 00       	r2 = Null + Null;
84201264:	4a 08       	r0 = r7 + Null;
84201266:	ff fd 33 f0 	call (m) 0x7888;
8420126a:	23 e1 

    return retval;
8420126c:	3a 00       	r0 = r5 + Null;

8420126e <Lc_vol_ctlr_opmsg_set_ucid_2>:
}
8420126e:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84201270:	d8 4c       	rts;

84201272 <$_vol_ctlr_opmsg_get_ps_id>:

bool vol_ctlr_opmsg_get_ps_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201272:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84201274:	16 00       	r4 = r0 + Null;
84201276:	1a 09       	r8 = r1 + Null;
84201278:	20 09       	r6 = r2 + Null;
8420127a:	2f 00       	r5 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
8420127c:	ef fd f9 ff 	call (m) 0x4e6;
84201280:	2b e3 
84201282:	11 09       	r7 = r0 + Null;

bool vol_ctlr_opmsg_get_ps_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    return cpsGetUcidMsgHandler(&op_extra_data->parms_def,base_op_get_cap_id(op_data),message_data,resp_length,resp_data);
84201284:	32 00       	r0 = r4 + Null;
84201286:	ef fd f9 ff 	call (m) 0x4ea;
8420128a:	25 e3 
8420128c:	13 00       	r1 = r0 + Null;
8420128e:	39 1c       	pushm <r5>;
84201290:	92 f0 b4 22 	r0 = r7 + 692;
84201294:	45 08       	r3 = r6 + Null;
84201296:	54 08       	r2 = r8 + Null;
84201298:	ef fd fb ff 	call (m) 0x9c8;
8420129c:	31 e9 
8420129e:	7f 4c       	SP = SP + -4;

842012a0 <Lc_vol_ctlr_opmsg_get_ps_id_2>:
}
842012a0:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842012a2:	d8 4c       	rts;

842012a4 <$_vol_ctlr_opmsg_set_sample_rate>:

bool vol_ctlr_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842012a4:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842012a6:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842012a8:	ef fd f9 ff 	call (m) 0x4e6;
842012ac:	3f e1 
bool vol_ctlr_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    /* We received client ID, length and then opmsgID and OBPM params */
    op_extra_data->sample_rate = 25 * (OPMSG_FIELD_GET(message_data, OPMSG_COMMON_MSG_SET_SAMPLE_RATE, SAMPLE_RATE));
842012ae:	f1 88       	rMAC = M[r4 + 12];
842012b0:	89 c6       	rMAC = rMAC AND 0xffff;
842012b2:	49 46       	rMAC = rMAC * 25 (int);
842012b4:	21 f0 3b 8e 	M[r0 + 236] = rMAC;

    return TRUE;
842012b8:	42 20       	r0 = Null + 1;

842012ba <Lc_vol_ctlr_opmsg_set_sample_rate_2>:
}
842012ba:	f1 48       	popm <FP, r4, rLink>;
842012bc:	d8 4c       	rts;

842012be <$_vol_ctlr_opmsg_data_stream_based>:

bool vol_ctlr_opmsg_data_stream_based(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842012be:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842012c0:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842012c2:	ef fd f9 ff 	call (m) 0x4e6;
842012c6:	25 e1 
bool vol_ctlr_opmsg_data_stream_based(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    /* We received client ID, length and then opmsgID and OBPM params */
    op_extra_data->stream_based = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_MSG_SET_DATA_STREAM_BASED, IS_STREAM_BASED);
842012c8:	f1 88       	rMAC = M[r4 + 12];
842012ca:	89 c6       	rMAC = rMAC AND 0xffff;
842012cc:	21 f0 c3 8e 	M[r0 + 780] = rMAC;

    return TRUE;
842012d0:	42 20       	r0 = Null + 1;

842012d2 <Lc_vol_ctlr_opmsg_data_stream_based_2>:
}
842012d2:	f1 48       	popm <FP, r4, rLink>;
842012d4:	d8 4c       	rts;

842012d6 <$_vol_ctlr_opmsg_set_aux_time_to_play>:
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
bool vol_ctlr_opmsg_set_aux_time_to_play(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842012d6:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842012d8:	11 09       	r7 = r0 + Null;
842012da:	1f 00       	r5 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842012dc:	ef fd f9 ff 	call (m) 0x4e6;
842012e0:	2b e0 
842012e2:	16 00       	r4 = r0 + Null;


    /* get aux channel index */
    unsigned aux_channel_index = OPMSG_FIELD_GET(message_data,
                                                 OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                                 AUX_CHANNEL_INDEX);
842012e4:	f9 88       	rMAC = M[r5 + 12];
842012e6:	8b c6       	r1 = rMAC AND 0xffff;
        (TIME)OPMSG_FIELD_GET_FROM_OFFSET(message_data,
                                          OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                          AUX_TIME_TO_PLAY, 1) +
        ((TIME)OPMSG_FIELD_GET_FROM_OFFSET(message_data,
                                           OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                          AUX_TIME_TO_PLAY, 0) << 16);
842012e8:	39 89       	rMAC = M[r5 + 16];
842012ea:	8a c6       	r0 = rMAC AND 0xffff;
842012ec:	92 56       	r0 = r0 LSHIFT 16;
842012ee:	79 89       	rMAC = M[r5 + 20];
842012f0:	89 c6       	rMAC = rMAC AND 0xffff;
842012f2:	1f f2 08 c0 	r6 = r0 + rMAC;
    /* get drift rate */
    int aux_drift_rate = (int)(int16)OPMSG_FIELD_GET(message_data,
                                                     OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                                     AUX_DRIFT_RATE);
842012f6:	b9 89       	rMAC = M[r5 + 24];
842012f8:	0f 0c       	r5 = SE16 rMAC;

    /* Only channel 0 is supported */
    if(aux_channel_index != 0)
842012fa:	18 04       	Null = r1 - Null;
842012fc:	0d 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_5;

842012fe <Lc_vol_ctlr_opmsg_set_aux_time_to_play_2>:
    {
        L2_DBG_MSG1("Volume Control Aux Timed Playback, "
                    "only channel 0 supports this feature, channel=%d",
                    aux_channel_index);
842012fe:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84201302:	88 24       	Null = rMAC - 2;
84201304:	07 68       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

84201306 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_3>:
84201306:	55 f1 02 f0 	r0 = Null + 357564774;
8420130a:	66 41 
8420130c:	ef fd fc ff 	call (m) 0xcde;
84201310:	33 ee 

84201312 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_4>:
        return FALSE;
84201312:	02 00       	r0 = Null + Null;
84201314:	76 6e       	jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_17;

84201316 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_5>:
    }

    /* drift_rate is in 1/10 of ppm, so convert it to a
     * fractional number.
     */
    aux_drift_rate = aux_drift_rate * FRACTIONAL(0.0001);
84201316:	46 f3 dc f7 	r5 = r5 * 214748 (int);
8420131a:	97 d9 
    aux_drift_rate = frac_mult(aux_drift_rate, FRACTIONAL(0.001));
8420131c:	02 f0 62 f0 	r0 = Null + 2147483;
84201320:	9b 48 
84201322:	00 f2 77 c9 	r5 = r5 * r0 (frac);

    vol_ctrl_aux_channel_t  *aux_channel = &op_extra_data->aux_channel[aux_channel_index];
84201326:	61 f0 6c 20 	rMAC = r4 + 108;
     * if sent after that we aren't be able to meet the deadline for timed
     * playback so just return FALSE.
     */
    if(aux_channel->buffer != NULL &&
       aux_channel->state != AUX_STATE_NO_AUX &&
       aux_channel->state != AUX_STATE_END_AUX)
8420132a:	0a e8       	r0 = M[rMAC + Null];
8420132c:	11 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_10;

8420132e <Lc_vol_ctlr_opmsg_set_aux_time_to_play_6>:
8420132e:	09 81       	rMAC = MBS[rMAC + 4];
84201330:	0f 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_10;

84201332 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_7>:
84201332:	c8 24       	Null = rMAC - 3;
84201334:	0d 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_10;

84201336 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_8>:
    {
        L2_DBG_MSG1("Volume Control Aux Timed Playback: "
                    "aux channel %d is already active",
                    aux_channel_index);
84201336:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420133a:	88 24       	Null = rMAC - 2;
8420133c:	eb 69       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

8420133e <Lc_vol_ctlr_opmsg_set_aux_time_to_play_9>:
8420133e:	55 f1 02 f0 	r0 = Null + 357564858;
84201342:	ba 41 
84201344:	03 00       	r1 = Null + Null;
84201346:	ef fd fc ff 	call (m) 0xcde;
8420134a:	39 ec 
8420134c:	e3 6f       	jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

8420134e <Lc_vol_ctlr_opmsg_set_aux_time_to_play_10>:
        return FALSE;
    }

    /* Sanity check on time to play time */
    TIME current_time = time_get_time();
8420134e:	ff fd 26 f0 	call (m) 0x6100;
84201352:	33 ed 
84201354:	13 00       	r1 = r0 + Null;
    TIME_INTERVAL ttp_in_future = time_sub(aux_time_to_play, current_time);
84201356:	3f f8 01 c2 	rMAC = r6 - r1;
    if(ttp_in_future < (VOL_CTRL_AUX_MIN_TTP_IN_FUTURE_MS*MILLISECOND) ||
       ttp_in_future > (VOL_CTRL_AUX_MAX_TTP_IN_FUTURE_MS*MILLISECOND))
8420135a:	01 f0 10 f3 	Null = rMAC - 30000;
8420135e:	30 2d 
84201360:	05 68       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_12;

84201362 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_11>:
84201362:	c4 f4 10 f2 	Null = rMAC - 20000000;
84201366:	00 3d 
84201368:	0d 6c       	if LE jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_14;

8420136a <Lc_vol_ctlr_opmsg_set_aux_time_to_play_12>:
    {
        L2_DBG_MSG2("Volume Control Aux Timed Playback: "
                    "Requested time to play is too early or too late,"
                    "current time=%d, time to play=%d",
                    current_time, aux_time_to_play);
8420136a:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420136e:	88 24       	Null = rMAC - 2;
84201370:	d1 69       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

84201372 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_13>:
84201372:	55 f1 02 f0 	r0 = Null + 357564926;
84201376:	fe 41 
84201378:	44 08       	r2 = r6 + Null;
8420137a:	ef fd fc ff 	call (m) 0xcf2;
8420137e:	39 eb 
84201380:	c9 6f       	jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

84201382 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_14>:
     * aux_time_to_play will be for first sample of aux,
     * we have a ramping down time for main channel before
     * actual mixing happens.
     * */
    vol_ctrl_aux_params_t *aux_param = (vol_ctrl_aux_params_t *)
        (&op_extra_data->parameters.OFFSET_AUX1_SCALE);
84201382:	61 f0 94 21 	rMAC = r4 + 404;
    unsigned atk_tc = aux_param[aux_channel_index].atk_tc;
84201386:	4b 88       	r1 = M[rMAC + 4];
    TIME_INTERVAL start_period = (TIME_INTERVAL) ((1<<(DAWTH-1))/atk_tc)*10;
84201388:	00 f8 02 f0 	r0 = Null + -2147483648;
8420138c:	00 40 
8420138e:	ff fd c7 f0 	call (m) 0x1a290;
84201392:	23 e8 
84201394:	91 42       	rMAC = r0 * 10 (int);
    TIME ttp_gate_time = time_sub(aux_time_to_play, start_period);
84201396:	1f f8 0b c2 	r9 = r6 - rMAC;
    /* aux timed playback message in only for one tone/prompt,
     * if we don't receive the actual aux data within reasonable
     * time, timed playback will expire and later received aux data
     * will be mixed in normal non-ttp mode */
    TIME ttp_expiry_time = time_add(aux_time_to_play,
                                    VOL_CTRL_AUX_TTP_EXPIRY_PERIOD_MS*MILLISECOND);
8420139a:	06 f0 8a f0 	r8 = r6 + 100000;
8420139e:	a0 2a 

    L2_DBG_MSG4("Volume Control, setting auxiliary playback time:"
                " time=%d, channel=%d, ttp=%d, drift=%d",
                time_get_time(), aux_channel_index, aux_time_to_play, aux_drift_rate);
842013a0:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842013a4:	88 24       	Null = rMAC - 2;
842013a6:	0f 68       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_16;

842013a8 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_15>:
842013a8:	ff fd 26 f0 	call (m) 0x6100;
842013ac:	39 ea 
842013ae:	13 00       	r1 = r0 + Null;
842013b0:	39 1c       	pushm <r5>;
842013b2:	55 f1 02 f0 	r0 = Null + 357565042;
842013b6:	72 42 
842013b8:	04 00       	r2 = Null + Null;
842013ba:	45 08       	r3 = r6 + Null;
842013bc:	ef fd fc ff 	call (m) 0xd20;
842013c0:	25 eb 
842013c2:	7f 4c       	SP = SP + -4;

842013c4 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_16>:
    /* postpone processing just in case this update is preempted
     * by the operator's process. Normally user is expected to send
     * this message before auxiliary path starts sending audio data,
     * so practically perhaps not required.
     */
    opmgr_op_suspend_processing(op_data);
842013c4:	4a 08       	r0 = r7 + Null;
842013c6:	ff fd 21 f0 	call (m) 0x570c;
842013ca:	27 ea 
    op_extra_data->aux0_ttp.time_to_play = aux_time_to_play;
842013cc:	68 f0 c5 8e 	M[r4 + 788] = r6;
    op_extra_data->aux0_ttp.expiry_time = ttp_expiry_time;
842013d0:	6a f0 c6 8e 	M[r4 + 792] = r8;
    op_extra_data->aux0_ttp.gate_time = ttp_gate_time;
842013d4:	6b f0 c7 8e 	M[r4 + 796] = r9;
    op_extra_data->aux0_ttp.drift_rate = aux_drift_rate;
842013d8:	67 f0 c9 8e 	M[r4 + 804] = r5;
    op_extra_data->aux0_ttp.enabled = TRUE;
842013dc:	41 20       	rMAC = Null + 1;
842013de:	61 f0 c4 8e 	M[r4 + 784] = rMAC;

#ifdef VOLUME_CONTROL_AUX_TIMING_TRACE
    record_aux_ttr_event(op_data,
                         VOL_CTRL_TTR_EVENT_AUX_STATE,
                         pack_aux_state(op_extra_data),
                         aux_time_to_play);
842013e2:	32 00       	r0 = r4 + Null;
842013e4:	01 f0 3d ef 	call (m) Lc_pack_aux_state_1;
842013e8:	03 f0 44 40 	r1 = Null + 68;
842013ec:	45 08       	r3 = r6 + Null;
842013ee:	14 00       	r2 = r0 + Null;
842013f0:	4a 08       	r0 = r7 + Null;
842013f2:	02 f0 31 e0 	call (m) Lc_record_aux_ttr_event_1;
#endif /* VOLUME_CONTROL_AUX_TIMING_TRACE */
    opmgr_op_resume_processing(op_data);
842013f6:	4a 08       	r0 = r7 + Null;
842013f8:	ff fd 21 f0 	call (m) 0x573a;
842013fc:	23 ea 
    return TRUE;
842013fe:	42 20       	r0 = Null + 1;

84201400 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_17>:
}
84201400:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201402:	d8 4c       	rts;

84201404 <$_vol_ctlr_opmsg_set_downstream_latency_est>:

bool vol_ctlr_opmsg_set_downstream_latency_est(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201404:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201406:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201408:	ef fd f8 ff 	call (m) 0x4e6;
8420140c:	3f e6 
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    /* get downstream latency field */
    unsigned latency_est_ms = OPMSG_FIELD_GET(message_data,
                                              OPMSG_VOL_CTRL_SET_DOWNSTREAM_LATENCY_EST,
                                              LATENCY_EST_MS);
8420140e:	f1 88       	rMAC = M[r4 + 12];
84201410:	89 c6       	rMAC = rMAC AND 0xffff;
    /* check maximum value */
    if(latency_est_ms > VOL_CTRL_MAX_DOWNSTREAM_LATENCY_MS)
84201412:	10 f0 c8 24 	Null = rMAC - 200;
84201416:	09 f0 89 e0 	if LS jump (m) Lc_vol_ctlr_opmsg_set_downstream_latency_est_3;

8420141a <Lc_vol_ctlr_opmsg_set_downstream_latency_est_2>:
    {
        return FALSE;
8420141a:	02 00       	r0 = Null + Null;
8420141c:	04 6e       	jump (m) Lc_vol_ctlr_opmsg_set_downstream_latency_est_4;

8420141e <Lc_vol_ctlr_opmsg_set_downstream_latency_est_3>:

    /* set downstream latency config, change while
	   the operator is running is ok, but the value
	   will be used from next auxiliary burst.
	 */
    VOL_CTRL_DOWNSTREAM_LATENCY_EST(op_extra_data) = latency_est_ms;
8420141e:	21 f0 d2 8e 	M[r0 + 840] = rMAC;
    return TRUE;
84201422:	42 20       	r0 = Null + 1;

84201424 <Lc_vol_ctlr_opmsg_set_downstream_latency_est_4>:
}
84201424:	f1 48       	popm <FP, r4, rLink>;
84201426:	d8 4c       	rts;

84201428 <Lc_vol_ctrl_fixup_buffer_details_1>:
 */
static bool vol_ctrl_fixup_buffer_details(VOL_CTRL_DATA_T *op_extra_data, unsigned terminal_id, OP_BUF_DETAILS_RSP *resp)
{
    patch_fn_shared(volume_control_wrapper);

    return TRUE;
84201428:	42 20       	r0 = Null + 1;

8420142a <Lc_vol_ctrl_fixup_buffer_details_2>:
8420142a:	d8 4c       	rts;

8420142c <Lc_vol_ctrl_recalc_main_buffer_size_1>:
8420142c:	d8 4c       	rts;

8420142e <Lc_vol_ctrl_recalc_aux_buffer_size_1>:

/**
 * \brief Update aux_buffer_size with the minimum of connected aux buffers' sizes
 */
static void vol_ctrl_recalc_aux_buffer_size(VOL_CTRL_DATA_T *op_extra_data)
{
8420142e:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84201430:	16 00       	r4 = r0 + Null;
    unsigned ch;
    unsigned aux_buffer_min_size = MAXINT;
84201432:	ff f7 f8 f7 	r6 = Null + 2147483647;
84201436:	ff 7b 

    patch_fn_shared(volume_control_wrapper);

    for (ch = 0; ch < VOL_CTRL_CONSTANT_NUM_CHANNELS; ch += 1)
84201438:	07 00       	r5 = Null + Null;
8420143a:	69 f0 6c 20 	r7 = r4 + 108;

8420143e <Lc_vol_ctrl_recalc_aux_buffer_size_2>:
    {
        tCbuffer* aux_buffer = op_extra_data->aux_channel[ch].buffer;
        if (aux_buffer != NULL)
8420143e:	92 f0 00 e8 	r0 = M[r7 + Null];
84201442:	08 60       	if EQ jump (m) Lc_vol_ctrl_recalc_aux_buffer_size_5;

84201444 <Lc_vol_ctrl_recalc_aux_buffer_size_3>:
        {
            unsigned size = cbuffer_get_size_in_words(aux_buffer);
84201444:	ff fd 98 f0 	call (m) 0x14450;
84201448:	2d e0 
            aux_buffer_min_size = MIN(aux_buffer_min_size, size);
8420144a:	2f f8 00 c2 	Null = r6 - r0;
8420144e:	02 64       	if NC jump (m) Lc_vol_ctrl_recalc_aux_buffer_size_5;

84201450 <Lc_vol_ctrl_recalc_aux_buffer_size_4>:
84201450:	10 09       	r6 = r0 + Null;

84201452 <Lc_vol_ctrl_recalc_aux_buffer_size_5>:
    unsigned ch;
    unsigned aux_buffer_min_size = MAXINT;

    patch_fn_shared(volume_control_wrapper);

    for (ch = 0; ch < VOL_CTRL_CONSTANT_NUM_CHANNELS; ch += 1)
84201452:	7f 20       	r5 = r5 + 1;
84201454:	81 75       	r7 = r7 + 16;
84201456:	38 26       	Null = r5 - 8;
84201458:	f3 65       	if NC jump (m) Lc_vol_ctrl_recalc_aux_buffer_size_2;

8420145a <Lc_vol_ctrl_recalc_aux_buffer_size_6>:
        {
            unsigned size = cbuffer_get_size_in_words(aux_buffer);
            aux_buffer_min_size = MIN(aux_buffer_min_size, size);
        }
    }
    op_extra_data->aux_buff_size = aux_buffer_min_size;
8420145a:	68 f0 bb 8e 	M[r4 + 748] = r6;

8420145e <Lc_vol_ctrl_recalc_aux_buffer_size_7>:
}
8420145e:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201460:	d8 4c       	rts;

84201462 <Lc_vol_ctrl_kick_waiting_1>:
84201462:	d8 4c       	rts;

84201464 <Lc_vol_ctrl_handle_aux_metadata_1>:
 *          delete all other aux metadata
 * \param op_extra_data     volume control operator specific data
 * \returns                 EOF tag, if found
 */
static metadata_tag* vol_ctrl_handle_aux_metadata(VOL_CTRL_DATA_T *op_extra_data)
{
84201464:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
84201466:	17 00       	r5 = r0 + Null;
    metadata_tag* aux_tag_head = NULL;
84201468:	02 00       	r0 = Null + Null;
    metadata_tag* eoftag = NULL;
8420146a:	06 00       	r4 = Null + Null;
    metadata_tag* tmp_tag = NULL;
    metadata_tag* prev_tag = NULL;
8420146c:	00 09       	r6 = Null + Null;
    unsigned b4idx, afteridx;

    /* get aux metadata, if applicable */
    if (op_extra_data->metadata_aux_channel != NULL)
8420146e:	39 a9       	rMAC = M[r5 + 80];
84201470:	09 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_3;

84201472 <Lc_vol_ctrl_handle_aux_metadata_2>:
    {
        aux_tag_head = buff_metadata_remove(op_extra_data->metadata_aux_channel->buffer,
                                            op_extra_data->metadata_aux_channel->advance_buffer * OCTETS_PER_SAMPLE,
                                            &b4idx, &afteridx);
84201472:	85 11       	r3 = FP + 24;
84201474:	44 11       	r2 = FP + 20;
84201476:	ca 88       	r0 = M[rMAC + 12];
84201478:	53 54       	r1 = r0 LSHIFT 2;
8420147a:	0a e8       	r0 = M[rMAC + Null];
8420147c:	ff fd 9a f0 	call (m) 0x149ca;
84201480:	2f ea 

84201482 <Lc_vol_ctrl_handle_aux_metadata_3>:
    }

    /* only look for EOF if we could output it */
    if (op_extra_data->metadata_op_buffer != NULL)
84201482:	f9 a8       	rMAC = M[r5 + 76];
84201484:	14 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_12;

84201486 <Lc_vol_ctrl_handle_aux_metadata_4>:
    {
        /* search for eof tag in aux metadata */
        tmp_tag = aux_tag_head;
84201486:	11 00       	rMAC = r0 + Null;

84201488 <Lc_vol_ctrl_handle_aux_metadata_5>:
        while (tmp_tag != NULL && !METADATA_STREAM_END(tmp_tag))
84201488:	08 04       	Null = rMAC - Null;
8420148a:	11 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_12;

8420148c <Lc_vol_ctrl_handle_aux_metadata_6>:
8420148c:	4b 88       	r1 = M[rMAC + 4];
8420148e:	5b c0       	r1 = r1 AND 0x2;
84201490:	04 62       	if NE jump (m) Lc_vol_ctrl_handle_aux_metadata_8;

84201492 <Lc_vol_ctrl_handle_aux_metadata_7>:
        {
            prev_tag = tmp_tag;
84201492:	08 09       	r6 = rMAC + Null;
            tmp_tag = tmp_tag->next;
84201494:	09 e8       	rMAC = M[rMAC + Null];
    /* only look for EOF if we could output it */
    if (op_extra_data->metadata_op_buffer != NULL)
    {
        /* search for eof tag in aux metadata */
        tmp_tag = aux_tag_head;
        while (tmp_tag != NULL && !METADATA_STREAM_END(tmp_tag))
84201496:	f9 6f       	jump (m) Lc_vol_ctrl_handle_aux_metadata_5;

84201498 <Lc_vol_ctrl_handle_aux_metadata_8>:
            tmp_tag = tmp_tag->next;
        }
        if (tmp_tag != NULL)
        {
            /* EOF tag was found in aux metadata*/
            eoftag = tmp_tag;
84201498:	0e 00       	r4 = rMAC + Null;
            /* remove it from the list */
            if (prev_tag != NULL)
8420149a:	0f f8 00 c2 	Null = r6 - Null;
8420149e:	05 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_10;

842014a0 <Lc_vol_ctrl_handle_aux_metadata_9>:
            {
                prev_tag->next = eoftag->next;
842014a0:	0b e8       	r1 = M[rMAC + Null];
842014a2:	83 f0 00 ee 	M[r6 + Null] = r1;
842014a6:	02 6e       	jump (m) Lc_vol_ctrl_handle_aux_metadata_11;

842014a8 <Lc_vol_ctrl_handle_aux_metadata_10>:
            }
            else
            {
                aux_tag_head = eoftag->next;
842014a8:	0a e8       	r0 = M[rMAC + Null];

842014aa <Lc_vol_ctrl_handle_aux_metadata_11>:
            }
            eoftag->next = NULL;
842014aa:	08 ee       	M[rMAC + Null] = Null;

842014ac <Lc_vol_ctrl_handle_aux_metadata_12>:
        }
    }
    /* delete aux metadata anyways */
    buff_metadata_tag_list_delete(aux_tag_head);
842014ac:	ff fd 98 f0 	call (m) 0x145ee;
842014b0:	23 ea 

    return eoftag;
842014b2:	32 00       	r0 = r4 + Null;

842014b4 <Lc_vol_ctrl_handle_aux_metadata_13>:
}
842014b4:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
842014b6:	d8 4c       	rts;

842014b8 <Lc_vol_ctrl_handle_input_metadata_1>:
 * \brief Transport metadata from input to output and handle aux EOF.
 * \param op_extra_data     volume control operator specific data
 * \param eoftag            EOF tag, if found in aux metadata
 */
static void vol_ctrl_handle_input_metadata(VOL_CTRL_DATA_T *op_extra_data, metadata_tag* eoftag)
{
842014b8:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
842014ba:	16 00       	r4 = r0 + Null;
842014bc:	18 09       	r6 = r1 + Null;
    metadata_tag *ret_mtag;
    metadata_tag* tmp_tag = NULL;
    metadata_tag* prev_tag = NULL;
    unsigned b4idx, afteridx;
    unsigned input_amount = op_extra_data->tc.num_words * OCTETS_PER_SAMPLE;
842014be:	62 f0 b2 88 	r0 = M[r4 + 712];
842014c2:	01 f2 d9 c8 	r7 = r0 LSHIFT 2;

    /* get input metadata, if applicable*/
    if (op_extra_data->metadata_ip_buffer != NULL)
842014c6:	b2 a8       	r0 = M[r4 + 72];
842014c8:	09 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_3;

842014ca <Lc_vol_ctrl_handle_input_metadata_2>:
    {
        ret_mtag = buff_metadata_remove(op_extra_data->metadata_ip_buffer,
                                        input_amount, &b4idx, &afteridx);
842014ca:	c5 11       	r3 = FP + 28;
842014cc:	84 11       	r2 = FP + 24;
842014ce:	4b 08       	r1 = r7 + Null;
842014d0:	ff fd 9a f0 	call (m) 0x149ca;
842014d4:	3b e7 
842014d6:	17 00       	r5 = r0 + Null;
842014d8:	05 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_4;

842014da <Lc_vol_ctrl_handle_input_metadata_3>:
    }
    else
    {
        b4idx = 0;
842014da:	30 de       	M[FP + 24] = Null;
        afteridx = input_amount;
842014dc:	e9 f0 07 8e 	M[FP + 28] = r7;
        ret_mtag = NULL;
842014e0:	07 00       	r5 = Null + Null;

842014e2 <Lc_vol_ctrl_handle_input_metadata_4>:
    }

    if (op_extra_data->metadata_op_buffer != NULL)
842014e2:	f1 a8       	rMAC = M[r4 + 76];
842014e4:	78 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_36;

842014e6 <Lc_vol_ctrl_handle_input_metadata_5>:
    {
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
        if(op_extra_data->aux0_ttp.generate_ttp)
842014e6:	60 f0 c8 88 	Null = M[r4 + 800];
842014ea:	06 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_7;

842014ec <Lc_vol_ctrl_handle_input_metadata_6>:
        {
            /* Operator shall generate timestamp itself, this
             * is done by time-stamping VOID tags.
             */
            vol_ctrl_timestamp_void_tags(op_extra_data, ret_mtag, b4idx);
842014ec:	34 d8       	r2 = M[FP + 24];
842014ee:	3b 00       	r1 = r5 + Null;
842014f0:	32 00       	r0 = r4 + Null;
842014f2:	01 f0 21 e2 	call (m) Lc_vol_ctrl_timestamp_void_tags_1;

842014f6 <Lc_vol_ctrl_handle_input_metadata_7>:
        }
#endif
        if (ret_mtag == NULL)
842014f6:	38 04       	Null = r5 - Null;
842014f8:	31 62       	if NE jump (m) Lc_vol_ctrl_handle_input_metadata_19;

842014fa <Lc_vol_ctrl_handle_input_metadata_8>:
            /* No metadata in input: we cannot append EOF tags!
             * In this case we need to save the EOF tag until
             * a new input tag comes in.
             * If none does, we need to recognise the data closing
             * the last received tag and append the EOF there. */
            if (eoftag != NULL)
842014fa:	0f f8 00 c2 	Null = r6 - Null;
842014fe:	12 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_13;

84201500 <Lc_vol_ctrl_handle_input_metadata_9>:
            {
                /* Save it for next run. */
                if (op_extra_data->last_eoftag != NULL)
84201500:	72 a9       	r0 = M[r4 + 84];
84201502:	04 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_11;

84201504 <Lc_vol_ctrl_handle_input_metadata_10>:
                {
                    /* We already had a pending EOF tag. Delete it. */
                    buff_metadata_tag_list_delete(op_extra_data->last_eoftag);
84201504:	ff fd 98 f0 	call (m) 0x145ee;
84201508:	2b e7 

8420150a <Lc_vol_ctrl_handle_input_metadata_11>:
                }
                op_extra_data->last_eoftag = eoftag;
8420150a:	68 f0 15 8e 	M[r4 + 84] = r6;
                L2_DBG_MSG("volume_control: aux EOF saved for next run");
8420150e:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84201512:	88 24       	Null = rMAC - 2;
84201514:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_13;

84201516 <Lc_vol_ctrl_handle_input_metadata_12>:
84201516:	55 f1 02 f0 	r0 = Null + 357564416;
8420151a:	00 40 
8420151c:	ef fd fb ff 	call (m) 0xccc;
84201520:	31 ed 

84201522 <Lc_vol_ctrl_handle_input_metadata_13>:
            }
            if (op_extra_data->last_tag_data_remaining <= input_amount)
84201522:	b1 a9       	rMAC = M[r4 + 88];
84201524:	9f f1 00 c2 	Null = rMAC - r7;
84201528:	08 f0 ab e0 	if HI jump (m) Lc_vol_ctrl_handle_input_metadata_18;

8420152c <Lc_vol_ctrl_handle_input_metadata_14>:
            {
                /* The last received tag is closed now and no other tags
                 * came through. If we had a pending EOF tag,
                 * we need to output it now */
                if (op_extra_data->last_eoftag != NULL)
8420152c:	71 a9       	rMAC = M[r4 + 84];
8420152e:	10 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_17;

84201530 <Lc_vol_ctrl_handle_input_metadata_15>:
                {
                    ret_mtag = op_extra_data->last_eoftag;
84201530:	0f 00       	r5 = rMAC + Null;
                    /* clear backup ptr */
                    op_extra_data->last_eoftag = NULL;
84201532:	70 af       	M[r4 + 84] = Null;
                    b4idx = input_amount;
84201534:	e9 f0 06 8e 	M[FP + 24] = r7;
                    afteridx = 0;
84201538:	38 de       	M[FP + 28] = Null;
                    L2_DBG_MSG("volume_control: ORPHAN aux EOF moved to output");
8420153a:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420153e:	88 24       	Null = rMAC - 2;
84201540:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_17;

84201542 <Lc_vol_ctrl_handle_input_metadata_16>:
84201542:	55 f1 02 f0 	r0 = Null + 357564459;
84201546:	2b 40 
84201548:	ef fd fb ff 	call (m) 0xccc;
8420154c:	25 ec 

8420154e <Lc_vol_ctrl_handle_input_metadata_17>:
                }
                op_extra_data->last_tag_data_remaining = 0;
8420154e:	b0 af       	M[r4 + 88] = Null;
84201550:	3a 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_35;

84201552 <Lc_vol_ctrl_handle_input_metadata_18>:
            }
            else
            {
                /* update the number of octets to come to complete the last tag */
                op_extra_data->last_tag_data_remaining -= input_amount;
84201552:	00 f9 31 c2 	rMAC = rMAC - r7;
84201556:	b1 af       	M[r4 + 88] = rMAC;
84201558:	36 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_35;

8420155a <Lc_vol_ctrl_handle_input_metadata_19>:
        }
        else
        {
            /* Check if we found an EOF on a previous run where input had no
             * metadata and we could not append it on the output. */
            if (op_extra_data->last_eoftag != NULL && ret_mtag != NULL)
8420155a:	71 a9       	rMAC = M[r4 + 84];
8420155c:	0e 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_22;

8420155e <Lc_vol_ctrl_handle_input_metadata_20>:
            {
                /* Transport now at the beginning of the output*/
                op_extra_data->last_eoftag->next = ret_mtag;
8420155e:	0f ee       	M[rMAC + Null] = r5;
                ret_mtag = op_extra_data->last_eoftag;
84201560:	77 a9       	r5 = M[r4 + 84];
                /* clear backup ptr */
                op_extra_data->last_eoftag = NULL;
84201562:	70 af       	M[r4 + 84] = Null;
                L2_DBG_MSG("volume_control: previous aux EOF moved to output");
84201564:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84201568:	88 24       	Null = rMAC - 2;
8420156a:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_22;

8420156c <Lc_vol_ctrl_handle_input_metadata_21>:
8420156c:	55 f1 02 f0 	r0 = Null + 357564506;
84201570:	5a 40 
84201572:	ef fd fb ff 	call (m) 0xccc;
84201576:	3b ea 

84201578 <Lc_vol_ctrl_handle_input_metadata_22>:
            }

            /* find the last tag of input metadata */
            tmp_tag = ret_mtag;
84201578:	3a 00       	r0 = r5 + Null;
            prev_tag = NULL;
8420157a:	01 00       	rMAC = Null + Null;

8420157c <Lc_vol_ctrl_handle_input_metadata_23>:
            while (tmp_tag->next != NULL)
8420157c:	13 e8       	r1 = M[r0 + Null];
8420157e:	04 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_25;

84201580 <Lc_vol_ctrl_handle_input_metadata_24>:
            {
                prev_tag = tmp_tag;
84201580:	11 00       	rMAC = r0 + Null;
                tmp_tag = tmp_tag->next;
84201582:	1a 00       	r0 = r1 + Null;
84201584:	fc 6f       	jump (m) Lc_vol_ctrl_handle_input_metadata_23;

84201586 <Lc_vol_ctrl_handle_input_metadata_25>:
            }

            /* save the number of octets to come to complete the last tag*/
            if (afteridx > 0 && afteridx <= tmp_tag->length)
84201586:	3b d8       	r1 = M[FP + 28];
84201588:	08 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_28;

8420158a <Lc_vol_ctrl_handle_input_metadata_26>:
8420158a:	d4 88       	r2 = M[r0 + 12];
8420158c:	18 05       	Null = r1 - r2;
8420158e:	08 f0 8b e0 	if HI jump (m) Lc_vol_ctrl_handle_input_metadata_28;

84201592 <Lc_vol_ctrl_handle_input_metadata_27>:
            {
                op_extra_data->last_tag_data_remaining = tmp_tag->length - afteridx;
84201592:	e3 04       	r1 = r2 - r1;
84201594:	b3 af       	M[r4 + 88] = r1;
84201596:	02 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_29;

84201598 <Lc_vol_ctrl_handle_input_metadata_28>:
            }
            else
            {
                op_extra_data->last_tag_data_remaining = 0;
84201598:	b0 af       	M[r4 + 88] = Null;

8420159a <Lc_vol_ctrl_handle_input_metadata_29>:
            }

            if (eoftag != NULL)
8420159a:	0f f8 00 c2 	Null = r6 - Null;
8420159e:	13 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_35;

842015a0 <Lc_vol_ctrl_handle_input_metadata_30>:
            {
                /* We found an EOF on the aux channel on this run
                 * bring it on the output in second to last position:
                 * aux_tag is the last tag, place eof tag in front of it. */
                eoftag->next = tmp_tag;
842015a0:	82 f0 00 ee 	M[r6 + Null] = r0;
                if (prev_tag == NULL)
842015a4:	08 04       	Null = rMAC - Null;
842015a6:	03 62       	if NE jump (m) Lc_vol_ctrl_handle_input_metadata_32;

842015a8 <Lc_vol_ctrl_handle_input_metadata_31>:
                {
                    ret_mtag = eoftag;
842015a8:	47 08       	r5 = r6 + Null;
842015aa:	03 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_33;

842015ac <Lc_vol_ctrl_handle_input_metadata_32>:
                }
                else
                {
                    prev_tag->next = eoftag;
842015ac:	18 f0 00 ee 	M[rMAC + Null] = r6;

842015b0 <Lc_vol_ctrl_handle_input_metadata_33>:
                }
                L2_DBG_MSG("volume_control: aux EOF moved to output");
842015b0:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842015b4:	88 24       	Null = rMAC - 2;
842015b6:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_35;

842015b8 <Lc_vol_ctrl_handle_input_metadata_34>:
842015b8:	55 f1 02 f0 	r0 = Null + 357564555;
842015bc:	8b 40 
842015be:	ef fd fb ff 	call (m) 0xccc;
842015c2:	2f e8 

842015c4 <Lc_vol_ctrl_handle_input_metadata_35>:
            }
        }
        /* write metadata to output */
        buff_metadata_append(op_extra_data->metadata_op_buffer, ret_mtag, b4idx, afteridx);
842015c4:	3d d8       	r3 = M[FP + 28];
842015c6:	34 d8       	r2 = M[FP + 24];
842015c8:	f2 a8       	r0 = M[r4 + 76];
842015ca:	3b 00       	r1 = r5 + Null;
842015cc:	ff fd 98 f0 	call (m) 0x147b8;
842015d0:	2d ef 
842015d2:	05 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_37;

842015d4 <Lc_vol_ctrl_handle_input_metadata_36>:
    }
    else
    {
        /* we cannot output metadata, delete input metadata */
        buff_metadata_tag_list_delete(ret_mtag);
842015d4:	3a 00       	r0 = r5 + Null;
842015d6:	ff fd 98 f0 	call (m) 0x145ee;
842015da:	39 e0 

842015dc <Lc_vol_ctrl_handle_input_metadata_37>:
    }
}
842015dc:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
842015de:	d8 4c       	rts;

842015e0 <Lc_vol_ctrl_update_current_timestamp_1>:
 *        playback of aux inputs.
 * \param op_extra_data volume control operator specific data
 * \param amount_consumed amount of input consumed since last update
 */
static void vol_ctrl_update_current_timestamp(VOL_CTRL_DATA_T *op_extra_data)
{
842015e0:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
842015e2:	10 09       	r6 = r0 + Null;
    unsigned amount_consumed = op_extra_data->prev_consumed_samples;
842015e4:	87 f0 cf 88 	r5 = M[r6 + 828];
    /* This will be set again when op consumes samples from input */
    op_extra_data->prev_consumed_samples = 0;
842015e8:	80 f0 cf 8e 	M[r6 + 828] = Null;
#endif

    /* 1. See if we see timestamp in input buffer, if we do then that will
     *    be used for timed mixing of aux input.
     */
    unsigned b4idx = 0;
842015ec:	30 de       	M[FP + 24] = Null;
    metadata_tag *mtag = buff_metadata_peek_ex(op_extra_data->metadata_ip_buffer, &b4idx);
842015ee:	83 11       	r1 = FP + 24;
842015f0:	82 f0 12 88 	r0 = M[r6 + 72];
842015f4:	ff fd 99 f0 	call (m) 0x14930;
842015f8:	3d e9 
842015fa:	16 00       	r4 = r0 + Null;
842015fc:	06 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_3;

842015fe <Lc_vol_ctrl_update_current_timestamp_2>:

            /* Op isn't generating ttp itself */
            op_extra_data->aux0_ttp.generate_ttp = FALSE;
            return;
        }
        b4idx += mtag->length;
842015fe:	f1 88       	rMAC = M[r4 + 12];
84201600:	32 d8       	r0 = M[FP + 24];
84201602:	51 00       	rMAC = r0 + rMAC;
84201604:	31 de       	M[FP + 24] = rMAC;
        mtag = mtag->next;
84201606:	36 e8       	r4 = M[r4 + Null];

84201608 <Lc_vol_ctrl_update_current_timestamp_3>:
    /* 1. See if we see timestamp in input buffer, if we do then that will
     *    be used for timed mixing of aux input.
     */
    unsigned b4idx = 0;
    metadata_tag *mtag = buff_metadata_peek_ex(op_extra_data->metadata_ip_buffer, &b4idx);
    while(mtag != NULL)
84201608:	30 04       	Null = r4 - Null;
8420160a:	36 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_10;

8420160c <Lc_vol_ctrl_update_current_timestamp_4>:
    {
        /* Search the input buffer metadata, if we see a TTP tag, then we use input time
         * stamps for the purpose of mixing time of auxiliary inputs to main inputs.
         */
        if(IS_TIMESTAMPED_TAG(mtag))
8420160c:	71 88       	rMAC = M[r4 + 4];
8420160e:	12 f0 30 00 	r0 = rMAC AND 0x30;
84201612:	f6 61       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_2;

84201614 <Lc_vol_ctrl_update_current_timestamp_5>:
84201614:	c9 c2       	rMAC = rMAC AND 0x40;
84201616:	f4 63       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_2;

84201618 <Lc_vol_ctrl_update_current_timestamp_6>:
        {
            unsigned *err_offset_id;
            unsigned out_length;
            /* go back to first input sample */
            TIME_INTERVAL time_back = convert_samples_to_time(b4idx / OCTETS_PER_SAMPLE,
                                                              op_extra_data->sample_rate);
84201618:	83 f0 3b 88 	r1 = M[r6 + 236];
8420161c:	32 d8       	r0 = M[FP + 24];
8420161e:	52 50       	r0 = r0 LSHIFT -2;
84201620:	ff fd b6 f0 	call (m) 0x183fe;
84201624:	3f ee 
            op_extra_data->current_timestamp = time_sub(mtag->timestamp, time_back);
84201626:	31 89       	rMAC = M[r4 + 16];
84201628:	89 04       	rMAC = rMAC - r0;
8420162a:	81 f0 cc 8e 	M[r6 + 816] = rMAC;
            if (buff_metadata_find_private_data(mtag, META_PRIV_KEY_TTP_OFFSET, &out_length,
                                                (void **)&err_offset_id))
8420162e:	c5 11       	r3 = FP + 28;
84201630:	04 12       	r2 = FP + 32;
84201632:	43 20       	r1 = Null + 1;
84201634:	32 00       	r0 = r4 + Null;
84201636:	ff fd 98 f0 	call (m) 0x14762;
8420163a:	2d e9 
8420163c:	10 04       	Null = r0 - Null;
8420163e:	0e 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_9;

84201640 <Lc_vol_ctrl_update_current_timestamp_7>:
            {
                int *err_offset_ptr = ttp_info_get(*err_offset_id);
84201640:	39 d8       	rMAC = M[FP + 28];
84201642:	0a e8       	r0 = M[rMAC + Null];
84201644:	ff fd c2 f0 	call (m) 0x19c1a;
84201648:	37 ee 
                if (err_offset_ptr != NULL)
8420164a:	10 04       	Null = r0 - Null;
8420164c:	07 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_9;

8420164e <Lc_vol_ctrl_update_current_timestamp_8>:
                {
                    /* subtract the offset */
                    op_extra_data->current_timestamp =
                        time_sub(op_extra_data->current_timestamp, *err_offset_ptr);
8420164e:	81 f0 cc 88 	rMAC = M[r6 + 816];
84201652:	12 e8       	r0 = M[r0 + Null];
84201654:	89 04       	rMAC = rMAC - r0;
84201656:	81 f0 cc 8e 	M[r6 + 816] = rMAC;

8420165a <Lc_vol_ctrl_update_current_timestamp_9>:
            /* current_timestamp: time stamp associated with first sample of input
             * main_timestamp_valid: whether main input has valid timestamp
             * last_main_real_timestamp: last valid timestamp we received from main input
             */
            op_extra_data->last_main_real_timestamp =
                op_extra_data->current_timestamp;
8420165a:	81 f0 cc 88 	rMAC = M[r6 + 816];
8420165e:	81 f0 cb 8e 	M[r6 + 812] = rMAC;
            op_extra_data->main_timestamp_valid = TRUE;
84201662:	41 20       	rMAC = Null + 1;
84201664:	81 f0 ca 8e 	M[r6 + 808] = rMAC;
            op_extra_data->current_timestamp_valid = TRUE;
84201668:	81 f0 cd 8e 	M[r6 + 820] = rMAC;

            /* real timestamp from input update, no accumulated remainder*/
            op_extra_data->current_timestamp_update_remainder = 0;
8420166c:	80 f0 ce 8e 	M[r6 + 824] = Null;

            /* Op isn't generating ttp itself */
            op_extra_data->aux0_ttp.generate_ttp = FALSE;
84201670:	80 f0 c8 8e 	M[r6 + 800] = Null;
84201674:	5d 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_24;

84201676 <Lc_vol_ctrl_update_current_timestamp_10>:
     *    we can build based on last received timestamp from main
     *    buffer. We stop relying on main timestamp if we
     *    haven't received any timestamp from input in last
     *    MAX_REBUILD_TIMESTAMP_PERIOD milliseconds.
     */
    if(op_extra_data->main_timestamp_valid)
84201676:	80 f0 ca 88 	Null = M[r6 + 808];
8420167a:	13 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_14;

8420167c <Lc_vol_ctrl_update_current_timestamp_11>:
    {
        TIME_INTERVAL time_passed_since_last_real_timestamp =
            time_sub(op_extra_data->current_timestamp,
                     op_extra_data->last_main_real_timestamp);
8420167c:	81 f0 cc 88 	rMAC = M[r6 + 816];
84201680:	82 f0 cb 88 	r0 = M[r6 + 812];
84201684:	89 04       	rMAC = rMAC - r0;
        if(time_passed_since_last_real_timestamp >
           (int)(VOL_CTRL_AUX_USE_MAIN_TIMESTAMP_PERIOD_MS*MILLISECOND))
84201686:	0c f0 10 f0 	Null = rMAC - 200000;
8420168a:	40 3d 
8420168c:	07 6c       	if LE jump (m) Lc_vol_ctrl_update_current_timestamp_13;

8420168e <Lc_vol_ctrl_update_current_timestamp_12>:
        {
            /* stop using main timestamp */
            op_extra_data->main_timestamp_valid = FALSE;
8420168e:	80 f0 ca 8e 	M[r6 + 808] = Null;
            op_extra_data->current_timestamp_valid = FALSE;
84201692:	80 f0 cd 8e 	M[r6 + 820] = Null;
            op_extra_data->current_timestamp_update_remainder = 0;
84201696:	80 f0 ce 8e 	M[r6 + 824] = Null;

8420169a <Lc_vol_ctrl_update_current_timestamp_13>:
     * to process actual aux data.
     */
    if(!op_extra_data->main_timestamp_valid &&
       op_extra_data->aux0_ttp.enabled &&
       !op_extra_data->aux0_ttp.generate_ttp &&
       !op_extra_data->aux_active)
8420169a:	80 f0 ca 88 	Null = M[r6 + 808];
8420169e:	1b 62       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_19;

842016a0 <Lc_vol_ctrl_update_current_timestamp_14>:
842016a0:	80 f0 c4 88 	Null = M[r6 + 784];
842016a4:	15 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_18;

842016a6 <Lc_vol_ctrl_update_current_timestamp_15>:
842016a6:	80 f0 c8 88 	Null = M[r6 + 800];
842016aa:	15 62       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_19;

842016ac <Lc_vol_ctrl_update_current_timestamp_16>:
842016ac:	80 f0 b8 88 	Null = M[r6 + 736];
842016b0:	0f 62       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_18;

842016b2 <Lc_vol_ctrl_update_current_timestamp_17>:
    {
        /* Start self ttp generating, with an estimated
         * target latency from current time.
         */
        TIME cur_time = time_get_time();
842016b2:	ff fd 25 f0 	call (m) 0x6100;
842016b6:	2f e2 
        op_extra_data->current_timestamp_valid = TRUE;
842016b8:	41 20       	rMAC = Null + 1;
842016ba:	81 f0 cd 8e 	M[r6 + 820] = rMAC;
        op_extra_data->current_timestamp =
            time_add(cur_time, op_extra_data->downstream_latency_estimate);
842016be:	83 f0 d0 88 	r1 = M[r6 + 832];
842016c2:	9a 00       	r0 = r1 + r0;
842016c4:	82 f0 cc 8e 	M[r6 + 816] = r0;
        op_extra_data->aux0_ttp.generate_ttp = TRUE;
842016c8:	81 f0 c8 8e 	M[r6 + 800] = rMAC;
842016cc:	31 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_24;

842016ce <Lc_vol_ctrl_update_current_timestamp_18>:
     * if input has valid timestamp op will not
     * generate ttp itself.
     * */
    op_extra_data->current_timestamp_valid =
        op_extra_data->main_timestamp_valid ||
        op_extra_data->aux0_ttp.generate_ttp;
842016ce:	80 f0 ca 88 	Null = M[r6 + 808];
842016d2:	03 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_20;

842016d4 <Lc_vol_ctrl_update_current_timestamp_19>:
842016d4:	41 20       	rMAC = Null + 1;
842016d6:	06 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_21;

842016d8 <Lc_vol_ctrl_update_current_timestamp_20>:
842016d8:	41 20       	rMAC = Null + 1;
842016da:	80 f0 c8 88 	Null = M[r6 + 800];
842016de:	00 f0 01 c0 	if EQ rMAC = Null + Null;

842016e2 <Lc_vol_ctrl_update_current_timestamp_21>:

    /* Build timestamp from previous one considering number of samples
     * consumed since
     */
    if(op_extra_data->current_timestamp_valid && amount_consumed != 0)
842016e2:	81 f0 cd 8e 	M[r6 + 820] = rMAC;
842016e6:	24 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_24;

842016e8 <Lc_vol_ctrl_update_current_timestamp_22>:
842016e8:	38 04       	Null = r5 - Null;
842016ea:	22 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_24;

842016ec <Lc_vol_ctrl_update_current_timestamp_23>:
    {
        /* new_time_stamp = previous_time_stamp + amount_consumed/sample_rate
         * we keep a remainder to avoid the effect of truncation.
         */
        uint64 tm_mul = (uint64)amount_consumed * 1000000 +
            op_extra_data->current_timestamp_update_remainder;
842016ec:	82 f0 ce 88 	r0 = M[r6 + 824];
842016f0:	00 f0 42 ff 	rMAC = r5 * 0.00023283064365386962890625 (UU);
842016f4:	40 f7 11 cc 
842016f8:	09 50       	rMAC = rMAC LSHIFT -1 (56bit);
842016fa:	00 f1 d5 c8 	r3 = rMAC LSHIFT 0;
842016fe:	cc 57       	r2 = rMAC LSHIFT 32;
84201700:	16 01       	r4 = r0 + r2;
84201702:	47 03       	r5 = Null + r3 + Carry;
        TIME_INTERVAL time_passed = (TIME_INTERVAL) (tm_mul/op_extra_data->sample_rate);
84201704:	89 f0 3b 88 	r7 = M[r6 + 236];
84201708:	4c 08       	r2 = r7 + Null;
8420170a:	05 00       	r3 = Null + Null;
8420170c:	3b 00       	r1 = r5 + Null;
8420170e:	32 00       	r0 = r4 + Null;
84201710:	ff fd c5 f0 	call (m) 0x1a208;
84201714:	39 e7 
84201716:	11 00       	rMAC = r0 + Null;
        op_extra_data->current_timestamp_update_remainder =
            (unsigned)(tm_mul - ((uint64)time_passed*op_extra_data->sample_rate));
84201718:	32 00       	r0 = r4 + Null;
8420171a:	9f f1 83 c9 	r1 = rMAC * r7 (int);
8420171e:	d2 04       	r0 = r0 - r1;
84201720:	82 f0 ce 8e 	M[r6 + 824] = r0;
        op_extra_data->current_timestamp =
            time_add(op_extra_data->current_timestamp, time_passed);
84201724:	82 f0 cc 88 	r0 = M[r6 + 816];
84201728:	51 00       	rMAC = r0 + rMAC;
8420172a:	81 f0 cc 8e 	M[r6 + 816] = rMAC;

8420172e <Lc_vol_ctrl_update_current_timestamp_24>:
    }
}
8420172e:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
84201730:	d8 4c       	rts;

84201732 <Lc_vol_ctrl_timestamp_void_tags_1>:
 * \octets_before_tag octets before mtag first octet
 */
static void vol_ctrl_timestamp_void_tags(VOL_CTRL_DATA_T *op_extra_data,
                                         metadata_tag *mtag,
                                         unsigned octets_before_tag)
{
84201732:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201734:	16 00       	r4 = r0 + Null;
84201736:	1f 00       	r5 = r1 + Null;
84201738:	20 09       	r6 = r2 + Null;

8420173a <Lc_vol_ctrl_timestamp_void_tags_2>:
    while(NULL != mtag)
8420173a:	38 04       	Null = r5 - Null;
8420173c:	1d 60       	if EQ jump (m) Lc_vol_ctrl_timestamp_void_tags_7;

8420173e <Lc_vol_ctrl_timestamp_void_tags_3>:
    {
        /* traverse through all tags in the list*/
        if(IS_VOID_TTP_TAG(mtag))
8420173e:	79 88       	rMAC = M[r5 + 4];
84201740:	11 f0 70 00 	rMAC = rMAC AND 0x70;
84201744:	10 f0 50 24 	Null = rMAC - 80;
84201748:	13 62       	if NE jump (m) Lc_vol_ctrl_timestamp_void_tags_6;

8420174a <Lc_vol_ctrl_timestamp_void_tags_4>:
8420174a:	38 89       	Null = M[r5 + 16];
8420174c:	11 62       	if NE jump (m) Lc_vol_ctrl_timestamp_void_tags_6;

8420174e <Lc_vol_ctrl_timestamp_void_tags_5>:
            /* tags is a VOID tag, turn it to a TIMESTAMP tags.
             * Note: current_timestamp field holds ttp for octet 0
             */
            TIME_INTERVAL time_passed =
                convert_samples_to_time(octets_before_tag/ADDR_PER_WORD,
                                        op_extra_data->sample_rate);
8420174e:	63 f0 3b 88 	r1 = M[r4 + 236];
84201752:	7f f8 d2 c8 	r0 = r6 LSHIFT -2;
84201756:	ff fd b6 f0 	call (m) 0x183fe;
8420175a:	29 e5 
            METADATA_TIME_OF_ARRIVAL_UNSET(mtag);
8420175c:	79 88       	rMAC = M[r5 + 4];
8420175e:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
            METADATA_TIMESTAMP_SET(mtag,
                                   time_add(op_extra_data->current_timestamp, time_passed),
                                   METADATA_TIMESTAMP_LOCAL);
84201762:	c9 c9       	rMAC = rMAC OR 0x10;
84201764:	79 8e       	M[r5 + 4] = rMAC;
84201766:	61 f0 cc 88 	rMAC = M[r4 + 816];
8420176a:	51 00       	rMAC = r0 + rMAC;
8420176c:	39 8f       	M[r5 + 16] = rMAC;

8420176e <Lc_vol_ctrl_timestamp_void_tags_6>:
        }
        octets_before_tag += mtag->length;
8420176e:	f9 88       	rMAC = M[r5 + 12];
84201770:	08 0d       	r6 = rMAC + r6;
        mtag = mtag->next;
84201772:	3f e8       	r5 = M[r5 + Null];
 */
static void vol_ctrl_timestamp_void_tags(VOL_CTRL_DATA_T *op_extra_data,
                                         metadata_tag *mtag,
                                         unsigned octets_before_tag)
{
    while(NULL != mtag)
84201774:	e3 6f       	jump (m) Lc_vol_ctrl_timestamp_void_tags_2;

84201776 <Lc_vol_ctrl_timestamp_void_tags_7>:
                                   METADATA_TIMESTAMP_LOCAL);
        }
        octets_before_tag += mtag->length;
        mtag = mtag->next;
    }
}
84201776:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201778:	d8 4c       	rts;

8420177a <Lc_vol_ctrl_setup_mute_1>:
    op_extra_data->channels = NULL;
}


static void vol_ctrl_setup_mute(VOL_CTRL_DATA_T *op_extra_data,unsigned bMute)
{
8420177a:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
8420177c:	16 00       	r4 = r0 + Null;
8420177e:	1f 00       	r5 = r1 + Null;

    /*  cur_mute_gain = 0 at start, and default mute=FALSE
        To immediately unmute set mute_period=0
    */

    if((op_extra_data->sample_rate<1) || (op_extra_data->mute_period<1) )
84201780:	63 f0 3b 88 	r1 = M[r4 + 236];
84201784:	04 60       	if EQ jump (m) Lc_vol_ctrl_setup_mute_3;

84201786 <Lc_vol_ctrl_setup_mute_2>:
84201786:	62 f0 c0 88 	r0 = M[r4 + 768];
8420178a:	0b 62       	if NE jump (m) Lc_vol_ctrl_setup_mute_4;

8420178c <Lc_vol_ctrl_setup_mute_3>:
    {
        /* Immediately set mute gain */
        op_extra_data->cur_mute_gain  = bMute ? 0 : FRACTIONAL(1.0);
8420178c:	ff f7 f1 f7 	rMAC = Null + 2147483647;
84201790:	ff 7b 
84201792:	38 04       	Null = r5 - Null;
84201794:	01 f0 01 c0 	if NE rMAC = Null + Null;
84201798:	61 f0 c1 8e 	M[r4 + 772] = rMAC;
        mute_increment=1;
8420179c:	42 20       	r0 = Null + 1;
8420179e:	17 6e       	jump (m) Lc_vol_ctrl_setup_mute_7;

842017a0 <Lc_vol_ctrl_setup_mute_4>:
    }
    else
    {

        if(op_extra_data->mute_period<1000)
842017a0:	20 f0 e8 27 	Null = r0 - 1000;
842017a4:	02 f0 a1 e0 	if C jump (m) Lc_vol_ctrl_setup_mute_6;

842017a8 <Lc_vol_ctrl_setup_mute_5>:
        {
            mute_increment = pl_fractional_divide(op_extra_data->mute_period,1000);
842017a8:	03 f0 e8 43 	r1 = Null + 1000;
842017ac:	ff fd e0 f1 	call (m) 0x3d950;
842017b0:	25 ed 
            mute_increment = pl_fractional_divide(1,frac_mult(mute_increment,op_extra_data->sample_rate));
842017b2:	63 f0 3b 88 	r1 = M[r4 + 236];
842017b6:	3f f2 43 c9 	r1 = r0 * r1 (frac);
842017ba:	42 20       	r0 = Null + 1;
842017bc:	ff fd e0 f1 	call (m) 0x3d950;
842017c0:	35 ec 
842017c2:	05 6e       	jump (m) Lc_vol_ctrl_setup_mute_7;

842017c4 <Lc_vol_ctrl_setup_mute_6>:
        }
        else
        {
            mute_increment = pl_fractional_divide(1,op_extra_data->sample_rate);
842017c4:	42 20       	r0 = Null + 1;
842017c6:	ff fd e0 f1 	call (m) 0x3d950;
842017ca:	2b ec 

842017cc <Lc_vol_ctrl_setup_mute_7>:
        }
    }

    /* Set direction of transition */
    op_extra_data->mute_increment = (bMute) ? -mute_increment : mute_increment;
842017cc:	38 04       	Null = r5 - Null;
842017ce:	05 60       	if EQ jump (m) Lc_vol_ctrl_setup_mute_9;

842017d0 <Lc_vol_ctrl_setup_mute_8>:
842017d0:	81 04       	rMAC = Null - r0;
842017d2:	61 f0 c2 8e 	M[r4 + 776] = rMAC;
842017d6:	03 6e       	jump (m) Lc_vol_ctrl_setup_mute_10;

842017d8 <Lc_vol_ctrl_setup_mute_9>:
842017d8:	62 f0 c2 8e 	M[r4 + 776] = r0;

842017dc <Lc_vol_ctrl_setup_mute_10>:

}
842017dc:	f2 48       	popm <FP, r4, r5, rLink>;
842017de:	d8 4c       	rts;

842017e0 <Lc_pack_aux_state_1>:
}
#endif /* INSTALL_METADATA */

#ifdef VOLUME_CONTROL_AUX_TIMING_TRACE
static unsigned pack_aux_state(VOL_CTRL_DATA_T *op_extra_data)
{
842017e0:	48 1d       	pushm <FP(=SP)>, SP = SP + 0x10;
    VOL_CTRL_PACKED_AUX_STATE packed_aux_state;

    packed_aux_state.u.f.aux_state = op_extra_data->aux_channel[0].state;
842017e2:	21 f0 70 80 	rMAC = MBS[r0 + 112];
842017e6:	10 de       	M[FP + 8] = Null;
842017e8:	41 da       	MB[FP + 8] = rMAC;
    packed_aux_state.u.f.aux_pending = op_extra_data->aux_pending;
842017ea:	21 f0 bc 88 	rMAC = M[r0 + 752];
842017ee:	49 da       	MB[FP + 9] = rMAC;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
    packed_aux_state.u.f.ttp_enabled = op_extra_data->aux0_ttp.enabled;
842017f0:	21 f0 c4 88 	rMAC = M[r0 + 784];
842017f4:	51 da       	MB[FP + 10] = rMAC;
    packed_aux_state.u.f.generate_ttp = op_extra_data->aux0_ttp.generate_ttp;
842017f6:	21 f0 c8 88 	rMAC = M[r0 + 800];
842017fa:	59 da       	MB[FP + 11] = rMAC;
#endif

    return packed_aux_state.u.w;
842017fc:	12 d8       	r0 = M[FP + 8];

842017fe <Lc_pack_aux_state_2>:
}
842017fe:	48 49       	SP = SP - 0x10, popm <FP>;
84201800:	d8 4c       	rts;

84201802 <Lc_record_aux_ttr_event_1>:

static void record_aux_ttr_event(OPERATOR_DATA *op_data,
                                 TIMING_TRACE_OP_EVENT_TYPE event_type,
                                 unsigned arg1,
                                 unsigned arg2)
{
84201802:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201804:	1e 00       	r4 = r1 + Null;
84201806:	27 00       	r5 = r2 + Null;
84201808:	28 09       	r6 = r3 + Null;
    /* Always use the ID for sink terminal 1 */
    ENDPOINT_ID aux_in_ep_id = base_op_get_ext_op_id(op_data) | 0xa001;
8420180a:	ef fd f6 ff 	call (m) 0x4f4;
8420180e:	2b e7 
84201810:	a0 f0 01 f2 	r0 = r0 OR 0xa001;
84201814:	52 d8 
    opmgr_record_timing_trace_op_term_event(aux_in_ep_id, event_type, arg1, arg2);
84201816:	45 08       	r3 = r6 + Null;
84201818:	3c 00       	r2 = r5 + Null;
8420181a:	33 00       	r1 = r4 + Null;
8420181c:	01 f0 21 e2 	call (m) $_opmgr_record_timing_trace_op_term_event;

84201820 <Lc_record_aux_ttr_event_2>:
}
84201820:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201822:	d8 4c       	rts;

84201824 <Lc_ups_params_vc_1>:



static bool ups_params_vc(void* instance_data,PS_KEY_TYPE key,PERSISTENCE_RANK rank,
                          uint16 length, unsigned* data, STATUS_KYMERA status,uint16 extra_status_info)
{
84201824:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201826:	2f 00       	r5 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201828:	ef fd f6 ff 	call (m) 0x4e6;
8420182c:	3f e5 
8420182e:	16 00       	r4 = r0 + Null;
static bool ups_params_vc(void* instance_data,PS_KEY_TYPE key,PERSISTENCE_RANK rank,
                          uint16 length, unsigned* data, STATUS_KYMERA status,uint16 extra_status_info)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data((OPERATOR_DATA*)instance_data);

    cpsSetParameterFromPsStore(&op_extra_data->parms_def,length,data,status);
84201830:	e5 d5       	r3 = MHS[FP + -8];
84201832:	fc d9       	r2 = M[FP + -4];
84201834:	62 f0 b4 22 	r0 = r4 + 692;
84201838:	3b 00       	r1 = r5 + Null;
8420183a:	ef fd f8 ff 	call (m) 0xa0a;
8420183e:	31 ee 

    /* Set the Reinit flag after setting the parameters */
    op_extra_data->ReInitFlag = 1;
84201840:	41 20       	rMAC = Null + 1;
84201842:	61 f0 ac 8e 	M[r4 + 688] = rMAC;

    return TRUE;
84201846:	0a 00       	r0 = rMAC + Null;

84201848 <Lc_ups_params_vc_2>:
}
84201848:	f2 48       	popm <FP, r4, r5, rLink>;
8420184a:	d8 4c       	rts;

8420184c <$_VOL_CTRL_GetDefaults>:
   0x7999999Au,			// LIMIT_ADAPTATION_RATIO
   0xFFD57A44u			// LIMIT_THRESHOLD_LOG
};

unsigned *VOL_CTRL_GetDefaults(unsigned capid){
	switch(capid){
8420184c:	20 f0 48 24 	Null = r0 - 72;
84201850:	05 60       	if EQ jump (m) Lc_VOL_CTRL_GetDefaults_3;

84201852 <Lc_VOL_CTRL_GetDefaults_2>:
84201852:	01 f0 20 f0 	Null = r0 - 16468;
84201856:	54 24 
84201858:	05 62       	if NE jump (m) Lc_VOL_CTRL_GetDefaults_4;

8420185a <Lc_VOL_CTRL_GetDefaults_3>:
		case 0x0048: return defaults_vol_ctrlVOL_V2PLUS;
8420185a:	f8 ff 02 f0 	r0 = Null + -8388604;
8420185e:	04 40 
84201860:	02 6e       	jump (m) Lc_VOL_CTRL_GetDefaults_5;

84201862 <Lc_VOL_CTRL_GetDefaults_4>:
		case 0x4054: return defaults_vol_ctrlVOL_V2PLUS;
	}
	return((unsigned *)0);
84201862:	02 00       	r0 = Null + Null;

84201864 <Lc_VOL_CTRL_GetDefaults_5>:
84201864:	d8 4c       	rts;

84201866 <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_vol_ctlr_cap_data;
84201866:	07 f0 02 f0 	r0 = Null + 7340176;
8420186a:	90 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
8420186c:	20 f0 f8 42 	Null = Null + 17144;

84201870 <$_vol_ctrl_update_aux_state>:
.CONST $vol_ctrl.axfp.period        4*ADDR_PER_WORD;  // r3
.MODULE $M.vol_ctrl_update_aux_state;
    .CODESEGMENT PM;

$_vol_ctrl_update_aux_state:
    pushm <r5,r7>;
84201870:	28 f0 40 e0 	pushm <r5, r7>;

    LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($vol_ctrl_update_aux_state.PATCH_ID_0, r7)

    // Check if any AUX to monitor
    r7 = r1;
84201874:	19 09       	r7 = r1 + Null;
    if Z jump update_aux_state_abort;
84201876:	b7 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_abort;

    r5 = r0;
84201878:	17 00       	r5 = r0 + Null;

    /* Setup Parameters Pointer */
    r1 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD +
               $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_AUX1_SCALE_FIELD);
8420187a:	23 f0 94 21 	r1 = r0 + 404;
    /* Setup Aux Pointer */
    r0 = r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
8420187e:	72 f0 6c 20 	r0 = r5 + 108;
    /* setup period */
    r3 = M[r2 + $volume_control_cap.vol_time_constants_struct.PERIOD_FIELD];
84201882:	25 89       	r3 = M[r2 + 16];
    /* Get number of words to process */
    r2 = M[r2 + $volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
84201884:	24 88       	r2 = M[r2 + 0];

    pushm <FP(=SP),r0,r1,r2,r3,r4,r6,r8,rLink>;
84201886:	57 f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r3, r4, r6, r8, rLink>;

    r8 = NULL;
8420188a:	02 09       	r8 = Null + Null;
    r6 = 1;
8420188c:	08 71       	r6 = Null + 1;

8420188e <$M.vol_ctrl_update_aux_state.vol_ctrl_update_aux_state_next>:

    // r0: vol_ctrl_aux_channel_t *aux
    // r1: vol_ctrl_aux_params_t *aux_params

    // Get aux->state
    r4 = M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
8420188e:	56 88       	r4 = M[r0 + 4];
    // In aux timed playback mode we don't allow aux data
    // to be consumed until the right time.

    // Auxiliary timed playback is only for channel 0, skip ttp handling
    // if this isn't first aux channel.
    r1 = r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
84201890:	73 f0 6c 20 	r1 = r5 + 108;
    NULL = r1 - r0;
84201894:	98 04       	Null = r1 - r0;
    if NZ jump aux_ttp_gate_control_done;
84201896:	22 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // timed playback requires that aux ttp to have been enabled by the user and
    // also we have valid timestamp to honour the ttp request, check both below,
    // if any fails then no gate control.

    // see if TTP is enabled for this aux channel
    NULL = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)];
84201898:	70 f0 c4 88 	Null = M[r5 + 784];
    if Z jump aux_ttp_gate_control_done;
8420189c:	1f 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // also see if we have a valid timestamp to handle aux timed playback
    // if not as if aux ttp isn't enabled
    NULL = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_VALID_FIELD];
8420189e:	70 f0 cd 88 	Null = M[r5 + 820];
    if Z jump aux_ttp_gate_control_done;
842018a2:	1c 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // time to open the gate. We open the gate when time passes TTP_GATE_TIME,
    // this is a bit before AUX_TTP time (default 10ms but user configurable) it will
    // give time to main channel for fading.
    // r1 = time stamp for first sample
    // r3 = ttp gate time
    r1 = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_FIELD];
842018a4:	73 f0 cc 88 	r1 = M[r5 + 816];
    r3 = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(GATE_TIME)];
842018a8:	75 f0 c7 88 	r3 = M[r5 + 796];
    r3 = r1 - r3;
842018ac:	5d 05       	r3 = r1 - r3;
    if POS jump check_aux_ttp_expiry;
842018ae:	05 f0 97 e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.check_aux_ttp_expiry;

    // gate time hasn't passed yet, AUX is expected to be
    // inactive, if for any reason it is in an active state
    // then we can't meet TTP deadline, just disable TTP playback.
    NULL = r4 - $volume_control_cap.AUX_STATE_NO_AUX;
842018b2:	30 24       	Null = r4 - 0;
    if NZ jump disable_aux_ttp;
842018b4:	0f 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.disable_aux_ttp;
    // see if it is the time to open the gate
    // we open the gate if the gate time lies in
    // a sample within this chunk, i.e between
    // current timestamp and and next timestamp
    // timestamp ----gate_time --- (timestamp+period)
    rMAC = M[FP + $vol_ctrl.axfp.period]; // rMAC = period in 10us
842018b6:	21 d8       	rMAC = M[FP + 16];
    rMAC = rMAC * 10 (int);               // rMAC = period in us
842018b8:	89 42       	rMAC = rMAC * 10 (int);
    NULL = r3 + rMAC;                     // rMAC > time left to gate?
842018ba:	68 00       	Null = r3 + rMAC;
    if POS jump aux_ttp_gate_control_done;// if yes then open the gate
842018bc:	05 f0 9f e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // keep the gate closed
    // it's not time to open the aux gate
    // don't allow anything to be consumed from aux
    M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD] = 0;
842018c0:	d0 8e       	M[r0 + 12] = Null;
    jump aux_ttp_gate_control_done;
842018c2:	0c 6e       	jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;

842018c4 <$M.vol_ctrl_update_aux_state.check_aux_ttp_expiry>:

check_aux_ttp_expiry:
    // if expiry time has reached and we haven't yet started
    // playing the aux then no longer need to honour the timed
    // playback request, we can't meet the deadline.
    NULL = r4 - $volume_control_cap.AUX_STATE_NO_AUX;
842018c4:	30 24       	Null = r4 - 0;
    if NZ jump aux_ttp_gate_control_done;
842018c6:	0a 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;

    r3 = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(EXPIRY_TIME)];
842018c8:	75 f0 c6 88 	r3 = M[r5 + 792];
    NULL = r1 - r3;
842018cc:	58 05       	Null = r1 - r3;
    if NEG jump aux_ttp_gate_control_done;
842018ce:	04 f0 8d e0 	if NEG jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;

842018d2 <$M.vol_ctrl_update_aux_state.disable_aux_ttp>:
    // Aux ttp has expired
disable_aux_ttp:
    // disabling aux timed playback
    M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)] = NULL;
842018d2:	70 f0 c4 8e 	M[r5 + 784] = Null;
    M[r5 + VOL_CTRL_AUX0_TTP_FIELD(GENERATE_TTP)] = 0;
842018d6:	70 f0 c8 8e 	M[r5 + 800] = Null;

842018da <$M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done>:
aux_ttp_gate_control_done:
#endif // VOLUME_CONTROL_AUX_TTP_SUPPORT
    // amount = aux_ptr->advance_buffer
    //        = aux_ptr->buffer ? cbuffer_calc_amount_data_in_words(aux_ptr->buffer) : 0
    r0 = M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD];
842018da:	d2 88       	r0 = M[r0 + 12];


    // Is Aux Data Present in sufficient quantity to mix?
    r1 = M[FP + $vol_ctrl.axfp.num_words];
842018dc:	1b d8       	r1 = M[FP + 12];
    NULL = r1 - r0;
842018de:	98 04       	Null = r1 - r0;
    if GT jump update_aux_state_insufficient_data;
842018e0:	50 6a       	if GT jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_insufficient_data;

842018e2 <$M.vol_ctrl_update_aux_state.update_aux_state_sufficient_data>:

    update_aux_state_sufficient_data:
        r3 = M[FP + $vol_ctrl.axfp.aux_ptr];
842018e2:	0d d8       	r3 = M[FP + 4];
        // aux_ptr->advance_buffer = volume_tc.num_words;
        M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD]=r1;
842018e4:	eb 8e       	M[r3 + 12] = r1;

        NULL = r4 - $volume_control_cap.AUX_STATE_IN_AUX;
842018e6:	b0 24       	Null = r4 - 2;
        if Z jump update_aux_state_done;
842018e8:	6c 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_done;
        /* Not in IN_AUX state */
        NULL = r4 - $volume_control_cap.AUX_STATE_START_AUX;
842018ea:	70 24       	Null = r4 - 1;
        if Z jump update_aux_state_in_AUX_START;
842018ec:	04 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_START;
            /* Not in START_AUX state, enter START_AUX state
               Start count down.  Don't use data until in IN_AUX state */
            r1 = $volume_control_cap.AUX_STATE_START_AUX;
842018ee:	43 20       	r1 = Null + 1;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
842018f0:	6b 8e       	M[r3 + 4] = r1;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = NULL;
842018f2:	a8 8e       	M[r3 + 8] = Null;

842018f4 <$M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_START>:
           // jump update_aux_do_not_use_data;
        update_aux_state_in_AUX_START:
            /* Continue count down */
            r0 = M[FP + $vol_ctrl.axfp.period];
842018f4:	22 d8       	r0 = M[FP + 16];
            r1 = M[FP + $vol_ctrl.axfp.aparm_ptr];
842018f6:	13 d8       	r1 = M[FP + 8];
            r1 = M[r1 + $volume_control_cap.vol_ctrl_aux_params_struct.ATK_TC_FIELD];
842018f8:	5b 88       	r1 = M[r1 + 4];
            rMAC = r0 * r1;
842018fa:	3f f2 c1 cc 	rMAC = r0 * r1 (SS);
            rMAC = rMAC ASHIFT (DAWTH-1) (56bit);
842018fe:	89 5f       	rMAC = rMAC ASHIFT 31 (56bit);
            r0 = M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD];
84201900:	aa 88       	r0 = M[r3 + 8];
            r2 = 1.0;
84201902:	ff f7 f4 f7 	r2 = Null + 2147483647;
84201906:	ff 7b 
            rMAC = rMAC + r0;
84201908:	51 00       	rMAC = r0 + rMAC;
            if V rMAC = r2;
8420190a:	06 f4 01 c0 	if V rMAC = r2 + Null;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = rMAC;
8420190e:	a9 8e       	M[r3 + 8] = rMAC;
            NULL = rMAC - r2;
84201910:	08 05       	Null = rMAC - r2;
            if NZ jump update_aux_do_not_use_data;
84201912:	56 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;

#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
            /* auxiliary timed playback is only for channel 0, skip ttp handling
             * if this isn't first aux channel.
             */
            r1 = r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
84201914:	73 f0 6c 20 	r1 = r5 + 108;
            NULL = r1 - r3;
84201918:	58 05       	Null = r1 - r3;
            if NZ jump aux_ttp_start_done;
8420191a:	2d 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;
            // time we start mixing aux into main channel. In ttp mode we
            // might need to delay it to make sure aux starts mixing at a time
            // as close as to requested playback time.

            // see if TTP is enabled at all for aux channel
            NULL = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)];
8420191c:	70 f0 c4 88 	Null = M[r5 + 784];
            if Z jump aux_ttp_start_done;
84201920:	2a 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;
            // and we have valid timestamp
            NULL = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_VALID_FIELD];
84201922:	70 f0 cd 88 	Null = M[r5 + 820];
            if Z jump aux_ttp_start_done;
84201926:	27 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;

            // r1 = aux requested ttp, this is the timestamp we want the aux to be mixed with main
            // r2 = timestamp, this is the timestamp for first sample of main
            r1 = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(TIME_TO_PLAY)];
84201928:	73 f0 c5 88 	r1 = M[r5 + 788];
            r2 = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_FIELD];
8420192c:	74 f0 cc 88 	r2 = M[r5 + 816];
            r1 = r1 - r2;
84201930:	1b 05       	r1 = r1 - r2;

            // because of the gate we expect to be very close to TTP time. If that
            // not the case, i.e. it's unexpectedly far in the future then something
            // should have gone wrong, to avoid stalling of mixing for long time ignore
            // TTP and let it go ahead with mixing.
            NULL = r1 - $vol_ctrl.MAX_EXTENDING_START_TRANSIENT_TIME_US;
84201932:	01 f0 30 f3 	Null = r1 - 30000;
84201936:	30 2d 
            if POS jump aux_ttp_start_done_without_ttp;
84201938:	05 f0 b9 e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done_without_ttp;
            // Good news, we are very close to TTP time, lets work out how
            // many sample we are to TTP time
            // samples = time * fs
            // r1 = time*1000000, so we calculate it this way:
            // samples = (r1 / 2000) * (fs/500)
            r2 = M[r5 + $volume_control_cap._vol_ctrl_data_struct.SAMPLE_RATE_FIELD];
8420193c:	74 f0 3b 88 	r2 = M[r5 + 236];
            r2 = r2 * (1/500.0)(frac);
84201940:	04 f0 89 f1 	r2 = r2 * 0.0019999998621642589569091796875 (frac);
84201944:	37 f4 54 c9 
            r2 = r2 * r1 (int)(sat);
84201948:	00 f3 f4 c9 	r2 = r2 * r1 (int) (sat);
            r2 = r2 * (1.0/2000.0)(frac); // r2 = samples to ttp time
8420194c:	01 f0 62 f0 	r2 = r2 * 0.000500000081956386566162109375 (frac);
84201950:	4e f4 54 c9 
            // negative r2 means that ttp was in a sample in the past
            // i.e. already exited the operator, this shall not happen
            // since we open the gate at right time, however in case that
            // happened continue without ttp.
            if NEG jump aux_ttp_start_done_without_ttp;
84201954:	04 f0 9d e0 	if NEG jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done_without_ttp;

            // r2 = 0, means TTP is exactly at first sample,
            // lucky, go to IN_AUX state now and start mixing
            if Z jump aux_ttp_start_done;
84201958:	0e 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;

            // if TTP is for later than whole of this chunk then extend transient time
            rMAC = M[FP + $vol_ctrl.axfp.num_words];
8420195a:	19 d8       	rMAC = M[FP + 12];
            NULL = r2 - rMAC;
8420195c:	60 04       	Null = r2 - rMAC;
            if POS jump update_aux_do_not_use_data;
8420195e:	05 f0 e1 e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;

            // TTP lies somewhere within current chunk, we split the
            // current chunk, so only samples before TTP are consumed
            // from the main channel, so next time will be start of TTP
            rMAC = r5 + $volume_control_cap._vol_ctrl_data_struct.TC_FIELD;
84201962:	71 f0 c8 22 	rMAC = r5 + 712;
            M[rMAC + $volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD] = r2;
84201966:	0c 8e       	M[rMAC + 0] = r2;
            M[FP + $vol_ctrl.axfp.num_words] = r2;
84201968:	1c de       	M[FP + 12] = r2;
            r1 = r1 * 10 (int);
8420196a:	9b 42       	r1 = r1 * 10 (int);
            M[FP + $vol_ctrl.axfp.period] = r1;
8420196c:	23 de       	M[FP + 16] = r1;
            jump update_aux_do_not_use_data;
8420196e:	28 6e       	jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;

84201970 <$M.vol_ctrl_update_aux_state.aux_ttp_start_done_without_ttp>:
            // We are here since either ttp time passed or is quite into the future.
            // We aren't expected to come to this point if gate opened at right time.
            // We go to IN_AUX now and timed playback won't be honoured.
            // clearing TTP_ENABLED field but not stopping TTP generation if active,
            // this is to avoid unnecessary disturbance it timed playback.
            M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)] = 0;
84201970:	70 f0 c4 8e 	M[r5 + 784] = Null;

84201974 <$M.vol_ctrl_update_aux_state.aux_ttp_start_done>:
aux_ttp_start_done:
            // debug var only, just shows that started to mix aux, the flag shall be
            // cleared by the caller.
            r1 = 1;
84201974:	43 20       	r1 = Null + 1;
            M[r5 + $volume_control_cap._vol_ctrl_data_struct.DBG_AUX_MIXING_STARTED_FIELD] = r1;
84201976:	73 f0 d1 8e 	M[r5 + 836] = r1;
#endif // VOLUME_CONTROL_AUX_TTP_SUPPORT
            /* Entering IN_AUX state */
            r1 = $volume_control_cap.AUX_STATE_IN_AUX;
8420197a:	83 20       	r1 = Null + 2;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
8420197c:	6b 8e       	M[r3 + 4] = r1;
            jump update_aux_state_done;
8420197e:	21 6e       	jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_done;

84201980 <$M.vol_ctrl_update_aux_state.update_aux_state_insufficient_data>:

     update_aux_state_insufficient_data:
        r3 = M[FP + $vol_ctrl.axfp.aux_ptr];
84201980:	0d d8       	r3 = M[FP + 4];
        // aux_ptr->advance_buffer = amount;

        NULL = r4 - $volume_control_cap.AUX_STATE_NO_AUX;
84201982:	30 24       	Null = r4 - 0;
        if Z jump update_aux_do_not_use_data;
84201984:	1d 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;
        /* Not in NO_AUX state */
        NULL = r4 - $volume_control_cap.AUX_STATE_END_AUX;
84201986:	f0 24       	Null = r4 - 3;
        if Z jump update_aux_state_in_AUX_END;
84201988:	07 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_END;
            /* Not in END_AUX state, enter END_AUX state
               Start count down.  Don't purge data until in NO_AUX state */
            r1 = $volume_control_cap.AUX_STATE_END_AUX;
8420198a:	c3 20       	r1 = Null + 3;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
8420198c:	6b 8e       	M[r3 + 4] = r1;
            r1 = 1.0;
8420198e:	ff f7 f3 f7 	r1 = Null + 2147483647;
84201992:	ff 7b 
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = r1;
84201994:	ab 8e       	M[r3 + 8] = r1;

84201996 <$M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_END>:
           // jump update_aux_do_not_use_data;
       update_aux_state_in_AUX_END:
            /* Continue count down */
            r0 = M[FP + $vol_ctrl.axfp.period];
84201996:	22 d8       	r0 = M[FP + 16];
            r1 = M[FP + $vol_ctrl.axfp.aparm_ptr];
84201998:	13 d8       	r1 = M[FP + 8];
            r1 = M[r1 + $volume_control_cap.vol_ctrl_aux_params_struct.DEC_TC_FIELD];
8420199a:	9b 88       	r1 = M[r1 + 8];
            rMAC = r0 * r1;
8420199c:	3f f2 c1 cc 	rMAC = r0 * r1 (SS);
            rMAC = rMAC ASHIFT (DAWTH-1) (56bit);
842019a0:	89 5f       	rMAC = rMAC ASHIFT 31 (56bit);
            r2 = M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD];
842019a2:	ac 88       	r2 = M[r3 + 8];
            rMAC = r2 - rMAC;
842019a4:	61 04       	rMAC = r2 - rMAC;
            if NEG rMAC=NULL;
842019a6:	04 f0 01 c0 	if NEG rMAC = Null + Null;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = rMAC;
842019aa:	a9 8e       	M[r3 + 8] = rMAC;
            if GT jump update_aux_do_not_use_data;
842019ac:	09 6a       	if GT jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
            // timed playback is only for one tone/prompt, once
            // finished disable aux timed playback
            M[r5 + VOL_CTRL_AUX0_TTP_FIELD(GENERATE_TTP)] = 0;
842019ae:	70 f0 c8 8e 	M[r5 + 800] = Null;
            M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)] = 0;
842019b2:	70 f0 c4 8e 	M[r5 + 784] = Null;
#endif
            /* Entering NO_AUX state */
            r1 = $volume_control_cap.AUX_STATE_NO_AUX;
842019b6:	03 00       	r1 = Null + Null;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
842019b8:	6b 8e       	M[r3 + 4] = r1;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = NULL;
842019ba:	a8 8e       	M[r3 + 8] = Null;
            jump update_aux_state_done;
842019bc:	02 6e       	jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_done;

842019be <$M.vol_ctrl_update_aux_state.update_aux_do_not_use_data>:

update_aux_do_not_use_data:
    M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD] = NULL;
842019be:	e8 8e       	M[r3 + 12] = Null;

842019c0 <$M.vol_ctrl_update_aux_state.update_aux_state_done>:
update_aux_state_done:

    // Next aux channel
    r0 = M[FP + $vol_ctrl.axfp.aux_ptr];
842019c0:	0a d8       	r0 = M[FP + 4];

    /* Is NO_AUX */
    NULL = M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
842019c2:	50 88       	Null = M[r0 + 4];
    if NZ r8 = r8 OR r6;
842019c4:	81 fa 4a c8 	if NE r8 = r8 OR r6;
    r0 = r0 + ($volume_control_cap.vol_ctrl_aux_channel_struct.STRUC_SIZE*ADDR_PER_WORD);
842019c8:	12 28       	r0 = r0 + 16;
    M[FP + $vol_ctrl.axfp.aux_ptr]=r0;
842019ca:	0a de       	M[FP + 4] = r0;

    r1 = M[FP + $vol_ctrl.axfp.aparm_ptr];
842019cc:	13 d8       	r1 = M[FP + 8];
    r1 = r1 + ($volume_control_cap.vol_ctrl_aux_params_struct.STRUC_SIZE*ADDR_PER_WORD);
842019ce:	1b 23       	r1 = r1 + 12;
    M[FP + $vol_ctrl.axfp.aparm_ptr]=r1;
842019d0:	13 de       	M[FP + 8] = r1;

    r6 = r6 LSHIFT 1;
842019d2:	00 f8 d8 d8 	r6 = r6 LSHIFT 1;
    r7 = r7 LSHIFT -1;
842019d6:	7f f9 d9 d8 	r7 = r7 LSHIFT -1;
    if NZ jump vol_ctrl_update_aux_state_next;
842019da:	5a 63       	if NE jump (m) $M.vol_ctrl_update_aux_state.vol_ctrl_update_aux_state_next;

    /* Save overall state */
    M[r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_ACTIVE_FIELD] = r8;
842019dc:	7a f0 b8 8e 	M[r5 + 736] = r8;

    popm <FP,r0,r1,r2,r3,r4,r6,r8,rLink>;
842019e0:	57 f2 6d e0 	popm <FP, r0, r1, r2, r3, r4, r6, r8, rLink>;

842019e4 <$M.vol_ctrl_update_aux_state.update_aux_state_abort>:

update_aux_state_abort:
    popm <r5,r7>;
842019e4:	28 f0 60 e0 	popm <r5, r7>;
    rts;
842019e8:	d8 4c       	rts;

842019ea <$_vol_ctrl_compute_time_constants>:
    .CODESEGMENT PM;

    .CONST POS_ONE_Q16_N   (1<<(DAWTH-16));  // 1.0 in Q16.8 (arch4: Q16.16)

$_vol_ctrl_compute_time_constants:
    pushm <r4,r5,r6,r7,rlink>;
842019ea:	b4 1c       	pushm <r4, r5, r6, r7, rLink>;
// r0:  unsigned sample_rate
// r1:  unsigned vol_tc  (r-1)
// r2:  vol_time_constants_t *lpvcs

    r3 = r1;
842019ec:	1d 00       	r3 = r1 + Null;
    r1 = M[r2+$volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
842019ee:	23 88       	r1 = M[r2 + 0];

    // compute period in 100th of msec  (samples/sample_rate)*100,000
    rMAC = r1 * 3125 (int);
842019f0:	0c f0 35 f3 	rMAC = r1 * 3125 (int);
842019f4:	91 d9 
    rMAC = rMAC LSHIFT (5-DAWTH) (56bit);
842019f6:	72 f1 d1 d8 	rMAC = rMAC LSHIFT -27 (56bit);
    Div  = rMAC / r0;
842019fa:	91 4c       	Div = rMAC / r0;
    r4 = DivResult;
842019fc:	c6 4c       	r4 = DivResult;
    M[r2 + $volume_control_cap.vol_time_constants_struct.PERIOD_FIELD] = r4;
842019fe:	26 8f       	M[r2 + 16] = r4;

    r4 = r4 ASHIFT (DAWTH-14);
84201a00:	09 f6 16 c9 	r4 = r4 ASHIFT 18;
    // compute volume update coeff: 11.5*n/fs (roughly 0.1dB/ms)
    r5 = r4 * 0.942071589546666;      // update coef in Q1.23 (arch4: Q1.31)
84201a04:	89 f7 cd f5 	r5 = r4 * 0.942071589641273021697998046875 (SS);
84201a08:	46 f6 d7 cc 
    // positive VOL_TC will increase the rate.
    // modified_coef ~= coef*r*(1+(r-1)*coef) (r = ramp factor)
    r1 = r3 + POS_ONE_Q16_N;
84201a0c:	04 f0 53 f0 	r1 = r3 + 65536;
84201a10:	00 20 
    if NEG r1 = 0;          // safeguard
84201a12:	04 f0 03 c0 	if NEG r1 = Null + Null;
    rMAC = r1 * r5;
84201a16:	7f f3 c1 cc 	rMAC = r1 * r5 (SS);
    r1 = rMAC ASHIFT 15;    // coef*r                in Q1.23 (arch4: Q1.31)
84201a1a:	07 f1 13 d9 	r1 = rMAC ASHIFT 15;
    rMAC = POS_ONE_Q16_N;
84201a1e:	81 f0 00 40 	rMAC = Null + 65536;
    rMAC = rMAC + r5 * r3;  // (1+(r-1)*coef)        in Q16.8 (arch4: Q16.16)
84201a22:	5f f7 c1 ca 	rMAC = rMAC + r5 * r3 (SS);
    rMAC = rMAC ASHIFT 8 (56bit);
84201a26:	c9 5d       	rMAC = rMAC ASHIFT 8 (56bit);
    rMAC = rMAC * r1;       // coef*r*(1+(r-1)*coef) in Q8.16 (arch4: Q8.24)
84201a28:	3f f1 c1 cc 	rMAC = rMAC * r1 (SS);
    r1 = rMAC ASHIFT 7;     // convert modified_coef to Q1.23 (arch4: Q1.31)
84201a2c:	8b 5d       	r1 = rMAC ASHIFT 7;
    M[r2 + $volume_control_cap.vol_time_constants_struct.VOL_TC_FIELD] = r1;
84201a2e:	63 8e       	M[r2 + 4] = r1;


   // calculate release coeff(reaches 99% in 50ms)
   r0 = r4 * 0.6553593446;
84201a30:	3e f5 d0 f2 	r0 = r4 * 0.65535934455692768096923828125 (SS);
84201a34:	a4 f6 d2 cc 
   r0 = r0 * (log(0.01)/0.05/log(2.0)/128.0/100.0)(frac);
84201a38:	ea ff d5 fb 	r0 = r0 * -0.010381025262176990509033203125 (frac);
84201a3c:	a6 f2 52 c9 
   call $math.pow2_table;
84201a40:	ff fd 95 f3 	call 0x74514;
84201a44:	34 e6 
   M[r2 + $volume_control_cap.vol_time_constants_struct.SAT_TC_FIELD] = r0;
84201a46:	a2 8e       	M[r2 + 8] = r0;

   // attack coeff, 5 times faster
   r1 = r0 * r0 (frac);
84201a48:	2f f2 43 c9 	r1 = r0 * r0 (frac);
   r1 = r1 * r1 (frac);
84201a4c:	00 f3 73 c9 	r1 = r1 * r1 (frac);
   r1 = r0 * r1 (frac);
84201a50:	3f f2 43 c9 	r1 = r0 * r1 (frac);
   M[r2 + $volume_control_cap.vol_time_constants_struct.SAT_TCP5_FIELD] = r1;
84201a54:	e3 8e       	M[r2 + 12] = r1;

   popm <r4,r5,r6,r7,rlink>;
84201a56:	b4 48       	popm <r4, r5, r6, r7, rLink>;
   rts;
84201a58:	d8 4c       	rts;
Disassembly of section .text_minim_private:

84201a5c <$_opmgr_record_timing_trace_op_term_event>:
84201a5c:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
void opmgr_record_timing_trace_op_term_event(
        ENDPOINT_ID opep_id,
        TIMING_TRACE_OP_EVENT_TYPE event_type,
        unsigned arg1,
        unsigned arg2)
{
84201a5e:	16 00       	r4 = r0 + Null;
84201a60:	18 09       	r6 = r1 + Null;
84201a62:	27 00       	r5 = r2 + Null;
84201a64:	29 09       	r7 = r3 + Null;
    if (timing_trace_is_enabled())
84201a66:	0b 4e       	call (m) $_timing_trace_is_enabled;
84201a68:	10 04       	Null = r0 - Null;
84201a6a:	07 60       	if EQ jump (m) Lc_opmgr_record_timing_trace_op_term_event_3;

84201a6c <Lc_opmgr_record_timing_trace_op_term_event_2>:
    {
        timing_trace_record_op_event_int(
                (((unsigned)event_type)<<16) | opep_id,
                arg1,
                arg2);
84201a6c:	08 f8 d2 c8 	r0 = r6 LSHIFT 16;
84201a70:	4c 08       	r2 = r7 + Null;
84201a72:	92 13       	r0 = r0 OR r4;
84201a74:	3b 00       	r1 = r5 + Null;
84201a76:	34 4e       	call (m) $_timing_trace_record_op_event_int;

84201a78 <Lc_opmgr_record_timing_trace_op_term_event_3>:
    }
}
84201a78:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201a7a:	d8 4c       	rts;

84201a7c <$_timing_trace_is_enabled>:
84201a7c:	c8 1c       	pushm <FP(=SP), rLink>;
    return (NULL != ttg) && (NULL != ttg->ttr.inst);
}

bool timing_trace_is_enabled(void)
{
    TIMING_TRACE_GLOBAL *ttg = timing_trace_get_global();
84201a7e:	54 4e       	call (m) $_timing_trace_get_global;
    return (NULL != ttg) && ttg->is_enabled;
84201a80:	10 04       	Null = r0 - Null;
84201a82:	06 60       	if EQ jump (m) Lc_timing_trace_is_enabled_3;

84201a84 <Lc_timing_trace_is_enabled_2>:
84201a84:	01 00       	rMAC = Null + Null;
84201a86:	90 88       	Null = M[r0 + 8];
84201a88:	21 f0 41 ce 	if NE rMAC = Null + 1;
84201a8c:	02 6e       	jump (m) Lc_timing_trace_is_enabled_4;

84201a8e <Lc_timing_trace_is_enabled_3>:
84201a8e:	01 00       	rMAC = Null + Null;

84201a90 <Lc_timing_trace_is_enabled_4>:
84201a90:	0a 00       	r0 = rMAC + Null;

84201a92 <Lc_timing_trace_is_enabled_5>:
}
84201a92:	c8 48       	popm <FP, rLink>;
84201a94:	d8 4c       	rts;

84201a96 <$_timing_trace_record_begin_run>:
84201a96:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    .const $_timing_trace_record_begin_run ENTRY_POINT_TIMING_TRACE_RECORD_BEGIN_RUN;
#else /* DISABLE_PATCH_BUILD_ID_CHECK */
$_timing_trace_record_begin_run:
    /* Check patch version */
    rMAC = M[$_patched_fw_version];
    Null = rMAC - PATCH_BUILD_ID;
84201a9a:	00 f0 10 f2 	Null = rMAC - 10276;
84201a9e:	24 34 
    if EQ jump ENTRY_POINT_TIMING_TRACE_RECORD_BEGIN_RUN;
84201aa0:	fc ff 30 f0 	if EQ jump (m) 0x4003a12;
84201aa4:	f3 ee 
    /* if not matching then just return */
    rts;
84201aa6:	d8 4c       	rts;

84201aa8 <$_timing_trace_record_end_run>:
#ifdef DISABLE_PATCH_BUILD_ID_CHECK
    .const $_timing_trace_record_end_run ENTRY_POINT_TIMING_TRACE_RECORD_END_RUN;
#else /* DISABLE_PATCH_BUILD_ID_CHECK */
$_timing_trace_record_end_run:
    /* Check patch version */
    rMAC = M[$_patched_fw_version];
84201aa8:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84201aac:	00 f0 10 f2 	Null = rMAC - 10276;
84201ab0:	24 34 
    if EQ jump ENTRY_POINT_TIMING_TRACE_RECORD_END_RUN;
84201ab2:	fc ff 30 f0 	if EQ jump (m) 0x4003a1a;
84201ab6:	e9 ee 
    /* if not matching then just return */
    rts;
84201ab8:	d8 4c       	rts;

84201aba <$_timing_trace_record_kicked>:
#ifdef DISABLE_PATCH_BUILD_ID_CHECK
    .const $_timing_trace_record_kicked ENTRY_POINT_TIMING_TRACE_RECORD_KICKED;
#else /* DISABLE_PATCH_BUILD_ID_CHECK */
$_timing_trace_record_kicked:
    /* Check patch version */
    rMAC = M[$_patched_fw_version];
84201aba:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84201abe:	00 f0 10 f2 	Null = rMAC - 10276;
84201ac2:	24 34 
    if EQ jump ENTRY_POINT_TIMING_TRACE_RECORD_KICKED;
84201ac4:	fc ff 30 f0 	if EQ jump (m) 0x4003a16;
84201ac8:	d3 ee 
    /* if not matching then just return */
    rts;
84201aca:	d8 4c       	rts;

84201acc <$_timing_trace_record_buffer_levels>:
#ifdef DISABLE_PATCH_BUILD_ID_CHECK
    .const $_timing_trace_record_buffer_levels ENTRY_POINT_TIMING_TRACE_RECORD_BUFFER_LEVELS;
#else /* DISABLE_PATCH_BUILD_ID_CHECK */
$_timing_trace_record_buffer_levels:
    /* Check patch version */
    rMAC = M[$_patched_fw_version];
84201acc:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84201ad0:	00 f0 10 f2 	Null = rMAC - 10276;
84201ad4:	24 34 
    if EQ jump ENTRY_POINT_TIMING_TRACE_RECORD_BUFFER_LEVELS;
84201ad6:	fc ff 30 f0 	if EQ jump (m) 0x4003a22;
84201ada:	cd ee 
    /* if not matching then just return */
    rts;
84201adc:	d8 4c       	rts;

84201ade <$_timing_trace_record_op_event_int>:
#ifdef DISABLE_PATCH_BUILD_ID_CHECK
    .const $_timing_trace_record_op_event_int ENTRY_POINT_TIMING_TRACE_RECORD_OP_EVENT_INT;
#else /* DISABLE_PATCH_BUILD_ID_CHECK */
$_timing_trace_record_op_event_int:
    /* Check patch version */
    rMAC = M[$_patched_fw_version];
84201ade:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84201ae2:	00 f0 10 f2 	Null = rMAC - 10276;
84201ae6:	24 34 
    if EQ jump ENTRY_POINT_TIMING_TRACE_RECORD_OP_EVENT_INT;
84201ae8:	fc ff 30 f0 	if EQ jump (m) 0x4003a0e;
84201aec:	a7 ee 
    /* if not matching then just return */
    rts;
84201aee:	d8 4c       	rts;

84201af0 <$_timing_trace_setup_op_create>:
#ifdef DISABLE_PATCH_BUILD_ID_CHECK
    .const $_timing_trace_setup_op_create ENTRY_POINT_TIMING_TRACE_SETUP_OP_CREATE;
#else /* DISABLE_PATCH_BUILD_ID_CHECK */
$_timing_trace_setup_op_create:
    /* Check patch version */
    rMAC = M[$_patched_fw_version];
84201af0:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84201af4:	00 f0 10 f2 	Null = rMAC - 10276;
84201af8:	24 34 
    if EQ jump ENTRY_POINT_TIMING_TRACE_SETUP_OP_CREATE;
84201afa:	fc ff 30 f0 	if EQ jump (m) 0x4003a06;
84201afe:	8d ee 
    /* if not matching then just return */
    rts;
84201b00:	d8 4c       	rts;

84201b02 <$_timing_trace_setup_kick_prop_add>:
#ifdef DISABLE_PATCH_BUILD_ID_CHECK
    .const $_timing_trace_setup_kick_prop_add ENTRY_POINT_TIMING_TRACE_SETUP_KICK_PROP_ADD;
#else /* DISABLE_PATCH_BUILD_ID_CHECK */
$_timing_trace_setup_kick_prop_add:
    /* Check patch version */
    rMAC = M[$_patched_fw_version];
84201b02:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84201b06:	00 f0 10 f2 	Null = rMAC - 10276;
84201b0a:	24 34 
    if EQ jump ENTRY_POINT_TIMING_TRACE_SETUP_KICK_PROP_ADD;
84201b0c:	fc ff 30 f0 	if EQ jump (m) 0x4003a0a;
84201b10:	ff ed 
    /* if not matching then just return */
    rts;
84201b12:	d8 4c       	rts;

84201b14 <$_timing_trace_setup_kick_prop_rem>:
#ifdef DISABLE_PATCH_BUILD_ID_CHECK
    .const $_timing_trace_setup_kick_prop_rem ENTRY_POINT_TIMING_TRACE_SETUP_KICK_PROP_REM;
#else /* DISABLE_PATCH_BUILD_ID_CHECK */
$_timing_trace_setup_kick_prop_rem:
    /* Check patch version */
    rMAC = M[$_patched_fw_version];
84201b14:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84201b18:	00 f0 10 f2 	Null = rMAC - 10276;
84201b1c:	24 34 
    if EQ jump ENTRY_POINT_TIMING_TRACE_SETUP_KICK_PROP_REM;
84201b1e:	fc ff 30 f0 	if EQ jump (m) 0x4003a02;
84201b22:	e5 ed 
    /* if not matching then just return */
    rts;
84201b24:	d8 4c       	rts;

84201b26 <$_timing_trace_get_global>:
#ifdef DISABLE_PATCH_BUILD_ID_CHECK
    .const $_timing_trace_get_global ENTRY_POINT_TIMING_TRACE_GET_GLOBAL;
#else /* DISABLE_PATCH_BUILD_ID_CHECK */
$_timing_trace_get_global:
    /* Check patch version */
    rMAC = M[$_patched_fw_version];
84201b26:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84201b2a:	00 f0 10 f2 	Null = rMAC - 10276;
84201b2e:	24 34 
    if EQ jump ENTRY_POINT_TIMING_TRACE_GET_GLOBAL;
84201b30:	fc ff 20 f0 	if EQ jump (m) 0x400301a;
84201b34:	eb e9 
    /* if not matching then just return NULL */
    R0 = Null;
84201b36:	02 00       	r0 = Null + Null;
    rts;
84201b38:	d8 4c       	rts;

84201b3a <$_timing_trace_set_enable>:
#ifdef DISABLE_PATCH_BUILD_ID_CHECK
    .const $_timing_trace_set_enable ENTRY_POINT_TIMING_TRACE_SET_ENABLE;
#else /* DISABLE_PATCH_BUILD_ID_CHECK */
$_timing_trace_set_enable:
    /* Check patch version */
    rMAC = M[$_patched_fw_version];
84201b3a:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84201b3e:	00 f0 10 f2 	Null = rMAC - 10276;
84201b42:	24 34 
    if EQ jump ENTRY_POINT_TIMING_TRACE_SET_ENABLE;
84201b44:	fc ff 20 f0 	if EQ jump (m) 0x400302a;
84201b48:	e7 e9 
    /* if not matching then just return */
    rts;
84201b4a:	d8 4c       	rts;

84201b4c <$_timing_trace_get_build_options>:
#ifdef DISABLE_PATCH_BUILD_ID_CHECK
    .const $_timing_trace_get_build_options ENTRY_POINT_TIMING_TRACE_GET_BUILD_OPTIONS;
#else /* DISABLE_PATCH_BUILD_ID_CHECK */
$_timing_trace_get_build_options:
    /* Check patch version */
    rMAC = M[$_patched_fw_version];
84201b4c:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84201b50:	00 f0 10 f2 	Null = rMAC - 10276;
84201b54:	24 34 
    if EQ jump ENTRY_POINT_TIMING_TRACE_GET_BUILD_OPTIONS;
84201b56:	fc ff 20 f0 	if EQ jump (m) 0x4003058;
84201b5a:	83 ea 
    /* if not matching then just return NULL */
    R0 = Null;
84201b5c:	02 00       	r0 = Null + Null;
    rts;
84201b5e:	d8 4c       	rts;
